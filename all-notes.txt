***************************************** HTML index.html *****************************************

<!DOCTYPE html> <!--to tell the browser what version of HTML(Hypertext Markup Language) document you are writing-->
<!-- if you didn't write DOCTYPE render mode = quirks mode // if you write DOCTYPE render mode = standards mode-->
<html lang="en"><!--opening tag--> <!-- lang="en" good for accessibilty-->
    <head>
        <!-- meta tags will not appear on the web page this is a data or instruction to the Browser -->
        <meta charset="UTF-8"/> <!--character set = specify the character encoding for the HTML document // self-closing tag --> 
        <title>Book Store</title> <!--while be shown on tab and as title on google search-->
        <meta name="description" content="Book Store" /> <!--will be shown as description on google search-->
        <!-- when you declare attribute you can write single quot or double quot 
        and if the value only one word you can writ it without quotation if more than one word the attribute will take only the first word -->
        <style></style> <!-- for css codes -->
        <script></script> <!--for Java scripts codes-->
        <link rel="stylesheet" href=""> <!-- the link element creates a link between your HTML doument and an external resource // the rel attribute specifies the relationship between two documents-->
    </head>
    <body>
        <h1> <!--when you inspect you will find user agent style sheet and add some styles to specialize the h1-->
            <!-- user agent style sheet builtin in browser (chrome) -->
            Book Store
        </h1>
            <h2>Book Store</h2>
                <h3>chapter title inside book</h3>
                    <h4>story title inside chapter</h4>
                        <h5>more tiltes</h5>
                            <h6>more titles</h6>
        <!-- we have 2 types on elements ( block element and inline element ) 
        block element = always starts on a new line
        inline element = does not start on a new line-->
        <!-- class is global attribute used to select and access this element and do a change to them all by CSS and JS like (title , style , class, id, hidden )
        you can write class attribute with or without quotation marks but if you will write something after class like ID you should write quotation-->
        <p class="one"> This is my <b>Book Store</b>, welcome</p> <!--block element--> <!--<b> Bold-->
        <p class="two"> This is my <strong>Book Store</strong>, welcome</p> <!--<strong> = <b> + important text // the difference that search engine will recognize it as important also usefull for blind people-->
        <p class="three"> This is my <i>Book Store</i>, welcome</p> <!-- <i> italic <em> and <strong> are semantic tags <i> and <b> not-->
        <p class="four"> This is my <em>Book Store</em>, welcome</p> <!--<em> =  <i> + important text Emphasized-->
        <p class="five"> This is my Book Store,<mark>welcome</mark></p> <!--<mark> =  higlight the word with yellow-->
        <p class="six"> This is my Book Store,<u>welcome</u></p> <!--<u> = underline -->
        <p class="seven"> This is my Book Store,<small>welcome</small></p> <!--<small> = smaller size -->
        <p class="eight"> This is my Book Store,<del>welcome</del></p> <!--<del> = to mark a word as deleted -->
        <p class="nine"> old price <del>100$</del> new Price 80$</p> <!--<del> = to mark a word as deleted -->
        <p class="ten"> This is my Book Store and <ins>Magazine Store</ins>, welcome</p> <!--<ins> = insert opposite of <del> // <ins> is semantic tag but <u> not -->
        <p class="eleven"> h<sup>2</sup>o</p> <!--<sup> = used in chemistry or math ( 2 will be up) -->
        <p class="twilve"> h<sub>2</sub>o</p> <!--<sub> = used in chemistry ( 2 will be down) -->
        <!-- we have 2 types of attributes : ( global attribute and element attribute)
        global attribute you can use it on any tags and anywhere in html file like hidden 
        element attribute specific to each tag like src in img tag -->
        <p hidden>We have a big Sale</p> <!--hiddden is global attribute  -->
        <span>Black friday</span> <!--inline element--><!--you can write the word without <span>-->
        <span>cyber monday</span> <!-- the use of span to select and access this element and do a change to them all by CSS and JS-->
        <hr>
        <!--src = source , alt = alternate Text--> <!-- element attribute // also like <link rel="stylesheet" href=""> -->
        <!--you can add the link of photo from website in src-->
        <img src="https://image.shutterstock.com/image-vector/black-friday-super-sale-realistic-600w-1841495770.jpg" alt=""> 
        <!--you can add a photo from the same folder in src by writing only it's name-->
        <img src="black.jpg" alt=""> <!--img is inline element but if it's big it will act as block element-->
        <img src="imgs/black.jpg" alt=""> <!--or you can choose from another folder-->
        <img src="../black.jpg" alt=""> <!--if it it outside the folder you can move backword by ../-->
        <img src="/Users/mido1_88/Desktop/games/black.jpg" alt=""> <!--if it it outside the folder you can write the path-->
        <img src="/Users/mido1_88/Desktop/games/black.jpg" alt="" width="200px" height="200px"> <!--width and height to control size of img-->
        <img src="missing-image.jpg" alt="no worries it's a test"> <!--alt = it's a message will show up only if the image not found -->
        <hr>
        <a href="https://www.google.com/" target="_blank">Google</a> <!-- a = anchor --> <!-- <a> inline element--> <!-- target="_blank" will open the link in new tab-->
        <a href="https://www.facebook.com/" target="_blank" title = "Go to Facbook">Facebook</a> <!--title ="" when the mouse point to the word a message will pop out-->
        <a href="test.html" target="_blank" title = "Go to my local page ">local test</a> <!--you can use href also with file on your computer-->
        <a href="#soliman"  title = "Go to soliman ">soliman paragraph</a> <!--you can use href also to go to specific paragraph (with special id) and write this id after # in href attribute-->
        <a href="mailto:o@nn.sa"  title = " Mail ">contact me</a> <!--you can use href also to go to mail (mailto: the Email you want to recieve Emails to it)-->
        <hr>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusamus, cumque. Autem nihil accusantium quibusdam natus. Ipsam, assumenda aspernatur! Illo veritatis repellendus magnam totam molestiae nesciunt, perferendis minus iure libero ea?</p>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusamus, cumque. Autem nihil accusantium quibusdam natus. Ipsam, assumenda aspernatur! Illo veritatis repellendus magnam totam molestiae nesciunt, perferendis minus iure libero ea?</p>
        <p id="soliman"> <i><u><b>here is soliman ID</b></u></i> Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusamus, cumque. Autem nihil accusantium quibusdam natus. Ipsam, assumenda aspernatur! Illo veritatis repellendus magnam totam molestiae nesciunt, perferendis minus iure libero ea?</p>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusamus, cumque. Autem nihil accusantium quibusdam natus. Ipsam, assumenda aspernatur! Illo veritatis repellendus magnam totam molestiae nesciunt, perferendis minus iure libero ea?</p>
        <p>Lorem ipsum dolor <br/> sit amet consectetur adipisicing elit.Accusamus, cumque. Autem nihil accusantium quibusdam natus. Ipsam, assumenda aspernatur! Illo veritatis repellendus magnam totam molestiae nesciunt, perferendis minus iure libero ea?</p>
        <!-- <br/> is like \n to create new line -->
        <!-- <hr/> horizontal rule to create new line and draw separetaing line -->
        <hr>
        <ul><!-- unordered lis-->
            <li>HTML</li> <!--list item-->
            <li>CSS</li>
            <li>
                JS
                <ul> <!--nested ul -->
                    <li>Angular</li>
                    <li>React</li>
                    <li>Vuejs</li>
                </ul>
            </li>
        </ul>
        <hr>
        <ol reversed> <!-- reversed attribute to reverse the list-->
            <li>Name</li> <!--will add no. to order the list -->
            <li>address</li>
            <li>ID</li>
        </ol>
        <hr> 
        <ol start="100"> <!-- start attribute to start from specific position-->
            <li>Name</li> 
            <li>address</li>
            <li>ID</li>
        </ol> 
        <hr>
        <ol type="a"> <!-- type="1" count by numbers // type="a" capital or small count by alphabetic // typr="I" roman count-->
            <li value="3">Name</li> <!-- you can add value="" in <li> instead of start="" in <ol>-->
            <li>address</li> <!-- or you can add both type="a" and value="" to start from third letter c-->
            <li>ID</li>
        </ol>
        <hr>
        <dl> <!-- description list-->
            <dt>HTML</dt> <!-- description term-->
            <dd>the language of web</dd> <!-- desciption of description term-->
            <dt>CSS</dt> <!-- description term-->
            <dd>the language of visuals</dd> <!-- desciption of description term-->
        </dl> 
        <!-- table have also header(thead) footer(tfoot) and body(tbody) those are optional you can use them or not-->
        <hr>
        <table border ="1" cellpadding = "20px"> <!--here red color because it's better to use CSS // cellpadding spaces between cells-->
            <caption>Students Marks</caption> <!--table title-->
            <thead>
                <tr> <!--table row-->
                    <th>First</th> <!--table header cell will change text to Bold -->
                    <th>Last</th>
                    <th>Marks</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>mohamed</td> <!--table data-->
                    <td>soliman</td>
                    <td>33</td>
                </tr>
                <tr>
                    <td>mohamed</td>
                    <td>soliman</td>
                    <td>33</td>
                </tr>
                <tr>
                    <td>mohamed</td>
                    <td>soliman</td>
                    <td>33</td>
                </tr>
            </tbody>
            <tfoot> <!--you can write for example tfoot before thead it will not affect the arrange of the table-->
                <tr>
                    <!-- we removed one of <td> from here and merge it with next <td> by colspan="2"-->
                    <td colspan="2">Total</td>
                    <td>99</td>
                </tr>
            </tfoot>
        </table>
        <hr>
        <div> <!-- division = is a containter for group of elements used to select and access a group of elements and do a change to them all by CSS and JS-->
            <h1>Book Store</h1>
            <p>This is my Book Store, Welcome</p>
        </div>
        <div class="all divisions of books">
            <div class="romantic">
                <div class="book1">
                    <h3>Book title</h3>
                    <p>Book description</p>
                    <span>$100</span>
                </div>
            </div>
            <div class="police">
                <div class="book2">
                    <h3>Book title</h3>
                    <p>Book description</p>
                    <span>$100</span>
                </div>
            </div>
            <div class="fantasy">
                <div class="book3">
                    <h3>Book title</h3>
                    <p>Book description</p>
                    <span>$100</span>
                </div>
            </div>
        </div>
        <hr>
        <!-- Entities every sympol has a code but all must start with & and ends with ; // < lt=less than , > gl= greater than ,& amp, copyright symbol = &copy;-->
        <p>test for &copy; Entities</p> 
        <!-- semantic elements = same like div but only with expressive name // can also take class-->
        <hr>
        <header></header>
        <nav></nav> <!-- navigation-->
        <section></section>
        <aside></aside> <!-- side bar-->
        <article></article>
        <footer></footer>
        <audio controls autoplay loop muted>
<!-- autopaly attribute play on some Browsers // will not autoplay at Chrome   -->
<!-- you can add audio by two ways attribute src="" or source tag-->
<!-- attribute controls to add buttons to play the file -->
<!-- the advantage to use source tag that you give the Browser option if he can't play from 1st source he can use the 2nd source for example different extension-->
<!-- MIME Type each type of audio file have special MIME type // for example Mp3 it's MIME type is audio/mpeg -->
            <source src="media/audio-test.mp3" type="audio/mpeg"> 
            <source src="media/audio-test.ogg" type="audio/ogg"> 
            <source src="media/audio-test.wav" type="audio/wav">
            your Browser does not support Audio Tags <!--this message will apear if the browser does not support this audio type-->
        </audio>
        <hr>
        <!--same comments of audio tag-->
        <!-- poster="" a pic will appear till the Browser load the video and start to play it -->
        <!-- preload attribute = preload has three values None / metadata / auto -->
        <!-- the Browser when it loads the page ot will downlaod metadata of video and the video itself and this called preload = "auto"
        but you can change it to None (fastet but you have to know the video's size to make placeholder by yourself)
        or you can change it to metadata (easy to setup the Browser will downlaod only some data not all data like dimesion of video ) -->
        <!-- if you put autoplay the Browser will ignore preload attribute -->
        <!-- <video controls autoplay width="400" height="200" loop muted poster="imgs/black.jpg"> 
            <source src="https://youtu.be/sMB_ozpcBHI" type="video/mp4">
            your Browser does not support Video Tags
            <track src="my_file.vtt" kind="subtitles" srclang="en" label="English">
            <track src="my_file_ar.vtt" kind="subtitles" srclang="ar" label="Arabic">
        </video> -->
        <iframe width="560" height="315" src="https://www.youtube.com/embed/sMB_ozpcBHI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        <hr>
        <form action="" method="get" novalidate target="_blank"> 
            <!-- traget="_blank will open an new tab after submition" -->
            <!-- when you use method Post the Bowser will give you error when you refresh the page because when you refresh will send the data to backend again 
            you can solve this by changing Post to get or by PRG(POST/Redirect/Get) method // PRG used to avoid duplicate form submission when you for exp. refreshing confirmation page in online shop-->
            <!--novalidate you can save and send data without filling every input  -->
            <!-- get method inserted data will appear at url link but with post method will not -->
            <!--action attribute to where send the data you inserted below-->
            <input type="hidden" value="M.Soliman"> <!-- will not appear used for example when a user insert his email and pass you want to send also his id with the inserted data to backend-dev-->
            <div>
                <label >User Name</label> <!--to descripe the type of input-->
                <input type="text" required placeholder="please insert your username" name="input1" readonly value="soliman"> 
                <!--name attribute to mark each input with specific name when you send data to another file for Backend-developer-->
                <!-- inline element // self-closing tag // required attribut to give you message that you have to fill this input when you press submit-->
                <!--readonly you can't change it anymore and we used value attribute to insert the unchangable input-->
            </div>
            <br> <!--to make space between two inputs-->
            <div>   
                 <label>Password</label>
                <input type="password" required name="input2" autofocus minlength="6" maxlength="10"> 
                <!-- type password will hide what you type inside input-->
            </div>
            <br>
            <div>   
                <label>Email</label>
                <input type="email" placeholder="Your Email" value="old@Email" name="input3" disabled> 
               <!-- value you can write here what will appear at input -->
               <!-- disable attribute ( this input will not send to backend-dev) -->
               <!-- difference between readonly and disabled both unchangabel but readonly data will be sent but diesabled not -->
            </div>
            <br>
            <div>   
                <label>Color</label>
                <input type="color" name="color">
            </div>
            <br>
            <div>   
                <label>Range</label>
                <input type="range" name="range" min='0' max="100" step="20" value="0"> <!--value="0" start from where-->
            </div>
            <br>
            <div>   
                <label for="num">number</label>
                <input id="num" type="number" name="range" min="0" max="100" step="5" value="15"> <!--value="0" start from where-->
                <!--( for and id )we can here link input and label (when you press on number label it will autofocus) -->
            </div>
            <br>
            <div>
                <input id= "win" type="radio" name="OS" value="Windows">
                <label for="win">Windows</label>
                <!-- to link the input with label we use id and for attributes -->
            </div>
            <div>
                <input id="mac" type="radio" name="OS" value="Mac" checked> <!-- when the page reload Mac option will be checked automatically-->
                <label for="mac">Mac</label>
            </div>
            <div>
                <input id="lin" type="radio" name="OS" value="Linux">
                <label for="win">Linux</label> <!--you can add link input with another label no problem-->
            </div>
            <!-- difference between radio and checkbox 
                with checkbox you can choose more than one option or all
                but radio only one option -->
            <br>
            <div>
                <input id= "win1" type="checkbox" name="OS" value="Windows"> <!-- name and value will sent to backend-->
                <label for="win1">Windwos</label>
                <!-- to link the input with label we use id and for attributes -->
            </div>
            <div>
                <input id="mac1" type="checkbox" name="OS" value="Mac" checked> <!-- when the page reload Mac option will be checked automatically-->
                <label for="mac1">Mac</label>
            </div>
            <div>
                <input id="lin1" type="checkbox" name="OS" value="Linux">
                <label for="win1">Linux</label> <!--you can add link input with another label no problem-->
            </div>
            <hr>
            <label for="coun">Choose country</label>
            <select id="coun" name="country" multiple> <!--you can choose more than one option by holding cmd-->
                <optgroup label="g1"> <!-- option group-->
                    <option value="1">Egypt</option>
                    <option value="2">Germany</option>
                    <option value="3">Kuwait</option>
                </optgroup>
                <optgroup label="g2">
                    <option value="4"selected>lebanon</option>
                    <option value="5">thailand</option>
                    <option value="6">USA</option> <!-- value sent to backend not the text we wrote in option -->
                </optgroup>
            </select>
            <hr>
            <textarea name="subject" id="" cols="30" rows="10" placeholder="please insert your text"></textarea> 
            <br>
            <input type="reset" value="reset">
            <input type="submit" value="save" > <!-- if you want to change the name of submit you can use value=""-->
            <br>
            <hr>
            <label>Upload</label>
            <input type="file" >
            <hr>
            <label>search</label>
            <input type="search" >
            <hr>
            <label>URL</label>
            <input type="url" >
            <hr>
            <label>Date</label>
            <input type="Date" value="1982-10-25">
            <hr>
            <label>Month</label>
            <input type="month" value="1982-10">
            <hr>
            <label>Time</label>
            <input type="time" >
            <hr>
            <label>programming languages</label>
            <input list="programming" name="prog" >
            <datalist id="programming"> <!--datalist like select but you can here search-->
                <!-- here we linked datalist and input by list="" and id="" -->
                <option value="python"></option>
                <option value="C"></option>
                <option value="PHP"></option>
                <option value="C#"></option>
            </datalist>
        </form>
        <hr>
        <q>this is quot</q> <!-- "" inline element-->
        <blockquote>this is Block</blockquote> <!-- semantic tag like <q> but the text will not start from the beginning of line-->
        <hr>
        <button>Click</button>
        <hr>
        <div>
            https://www.samsung.com/<wbr>us/watches/galaxy-watch4/buy/?<br>modelCode=SM-R860NZKAXAA
            <!-- wbr = word break opportunity break a line and start from new line 
            difference between wbr and br that wbr will break the line if it is too long and will not fit the screen but br will break the line anyway-->
        </div>
        <hr>
        <p>2 السلام welcome</p>
        <p> <bdi>السلام</bdi> 2 welcome</p> 
        <!-- bdi = bi directional isolation to isolate specicf word will be usefull when type 2 languages with 2 different directions like arabic and english-->
        <hr>
        <code>
            var x = 10;
            var y = 20;
            console.log(x + y);
        </code>
        <hr>
        <pre> <!-- pre-formatted text with pre tag the text will appear as it is with spaces p tag not-->
            This Is
            pre 
            formatted
            text
        </pre>
        <hr>
        <pre>
            <code>
                var x = 10;
                var y = 20;
                console.log(x + y);
            </code>
        </pre>
        <hr>
        <iframe src="https://elzero.org/" frameborder="0" style="width: 100%; height: 400px;"></iframe> 
        <!--to add website inside this page but some website refuse iframe-->
        <!-- frameborder ="0" no borders around webpage // frameborder="1" border around webpage-->
        <hr>
        <form action="">
            <input type="text">
            <button>send</button> <!--you can press tab to move between buttons-->
            <button>reset</button>
        </form>
        <hr>
        <!-- you can use <div> as checkbox because it will be easier to move netween options by TAB and this is better for accessiblity -->
        <div id="plan1" role="checkbox" aria-checked="true" tabindex="4">plan one</div>
        <label for="plan1"></label>
        <div role="checkbox"  tabindex="0">plan two</div>
        <div role="checkbox"  tabindex="0">plan three</div>
        <!-- aria-checked like checked in checkbox // tabindex to move between them by TAB -->
        <!-- tabindex="0" allows elements that are not natively focus such as (<div> <span> <p> <a> with no href) to recieve keyboard focus
            tabindex="-1" remove the element from the default navigation flow don't do it with buttons and links
            tabindex= positive no. cause unexpected TAB order try to avoid this-->
        
    </body> 
</html> <!--closing tag -->

***************************************** HTML semantic web sample *****************************************

<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Book Store</title>
        <meta name="description" content="This is our Book Store">
    </head>
    <body>
        <header> <!--instead of <div class="header"> // can also take class-->
            <h2>logo</h2>
            <ul> <!-- usually link will be writen on unordered list-->
                <li>Home</li> 
                <li>About</li> 
                <li>Services</li> 
                <li>Contact us</li> 
            </ul>
            <hr>
            <nav> <!-- instead of <ul class="navigation"> --> <!-- why ::marker on dev tools ??-->
                <li>Link</li>
                <li>Link</li>
                <li>Link</li>
                <li>Link</li>
            </nav>
        </header>
        <hr> <!--displayed as horizontal rule to separate content in an HTML page-->
        <section> <!--instead of div class="content"-->
            <article>
                <figure> <!--instead of <div> as a container of img-->
                    <img src="black.jpg" alt="">
                    <figcaption>Black Friday offers</figcaption> <!--instead of <p>-->
                </figure>
            </article>
        </section>
        <aside> <!--instead of div class="sidebar"-->
            Sidebar
        </aside>
        <hr>
        <footer> <!--instead of div class="footer"-->
            footer
        </footer>

    </body>
    
</html>


***************************************** HTML test table *****************************************

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Document</title>
    </head>
    <body>
        <table border ="1"  width="100%">
            <thead>
                <tr>
                    <th>Group</th>
                    <th>Avatar</th>
                    <th>Name</th>
                    <th>E-mail</th>
                    <th>Character</th>
                    <th>Profile</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td rowspan="2" style="vertical-align:top;">Ninja</td> <!-- you can use vertical aline in cell element -->
                    <td><img src="https://via.placeholder.com/40x40/F00" alt=""></td>
                    <td>Osama<br>Mohamed</td>
                    <td>o1@nn.sa<hr>o2@nn.sa</td>
                    <td>&copy;</td>
                    <td><a href="">Profile</a></td>
                </tr>
                <tr>
                    <td><img src="https://via.placeholder.com/40x40/0000FF" alt=""></td>
                    <td>Shady<br>Nabil</td>
                    <td>s@nn.sa</td>
                    <td>&trade;</td>
                    <td><a href="">Profile</a></td>
                </tr>
                <tr>
                    <td>Monsters</td>
                    <td><img src="https://via.placeholder.com/40x40/000000" alt=""></td>
                    <td>Mohamed<br>Ibrahim</td>
                    <td>m@nn.sa</td>
                    <td>&reg;</td>
                    <td><a href="">Profile</a></td>
                </tr>
            </tbody>
            <tfoot>
                <td colspan="5">Total members</td>
                <td>3</td>
            </tfoot>
    </body>
</html>

***************************************** HTML web sample *****************************************

<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Book Store</title>
        <meta name="description" content="This is our Book Store">
    </head>
    <body>
        <div class="header">
            <h2>logo</h2>
            <ul> <!-- usually link will be writen on unordered list-->
                <li>Home</li> 
                <li>About</li> 
                <li>Services</li> 
                <li>Contact us</li> 
            </ul>
            <hr>
            <ul class="navigation">
                <li>Link</li>
                <li>Link</li>
                <li>Link</li>
                <li>Link</li>
            </ul>
        </div>
        <hr> <!--displayed as horizontal rule to separate content in an HTML page-->
        <div class="content">
            <div>
                <br>
                <img id="img" src="black.jpg" alt="">
                <br>
                <label for="img">Black Friday offers</label>
            </div> 
        </div>
        <br>
        <div class="sidebar">
            Sidebar
        </div>
        <hr>
        <div class="footer">
            footer
        </div>

    </body>
    
</html>

***************************************** Css master.css *****************************************

/* p is selector (from index.html) and you can use name of tag 
or class but you should write . before name of class 
or id you should write # before name of id 
next example  p or .my_p or #my_p*/

/* p {
    color: green;
} */

.special {
    color: red;
}

.background {
    color:maroon;
    /* background-color: green; */
    /* background-color:#00ff00 ; Hexadecimal maximum value of each color is ff 
    opacity: 0.5; when you use opacity alone also the letters (child element) will be also transparent */
    /* background-color: rgb(0,255,0,0.5); */
    /* rgb = Red Green Blue maximum no for each color is 255 
    if all 255 will be white if all zero will be Black 
    alpha channel is transparencies */
    background-color: hsl(166, 73%, 62%);
    /* hsl(hue, saturation, lightness) */
    background-image: url("../../HTML-Zero/imgs/cover2.jpg");
    background-repeat: no-repeat; /* Default value is repeat will repeat the image on x an y 
    if you want to repreat only on x axis (repeat-x) if on y (repeat-y)*/
    background-attachment: scroll; /* Default value is scroll (background will not scroll with you and will be at same location at top of page
    but background-attachment: fixed; is moving with you during scrolling*/
    /*background-position: center;*/ 
    /*left top, left bottom, left center ,right top , right bottom, right center, center center
    if you did not write the 2nd word will be by default center */
    /*background-position: 500px 300px;*/ /* first value will move from left and 2nd value from above */
    /* fixed will not work good with background-position because when you change it to fixed it will move relative to the webpage not the background*/
    /* you can use % or px 50% 50% will be center */
    background-size: cover;
    /*default value is auto put the img with it's original size
    cover stretch the img to fit the background
    contain difference between contain and cover is cover will cut the img when you change the size of screen 
    but contain the img should be visible in all condition it will make the img smaller but visible*/
    /* you can also change the size of img by Background-size = 100px 200px */
    
}

.background1 {
    background-color:lightgreen;
    /* padding: 100px; */
    /* top right bottom left ( Clockwise ) and padding accept % or px but not negative*/
    /*if you write only one value this value will be same at 4 directions */
    /* padding: 100px 150px; */
    /* if you write two or three values the missing values will take same opposite value 
    last exp. top 100px right 150px so bottom will take 100px and left wil take 150px */
    padding : 0px 0px 20px;
    /* if you want to enter only one value for padding you can give other values 0 
    and here we did not write the last value because it will take 0 fom opposite side
    or you can easily write padding-bottom: 20px;  */
    margin: 20px;
    /* difference between margin and padding that margin outside background but padding from inside
     margin accept negative value because magin from outside and can move to other position on web page
    but padding inside background and text starts from the border of this background can't go outside
    also margin accepts % */
    width: 70% ;
    /* margin-left: 15% ; */
    /* if we want to change the position of background inside web page we use width and margin by % 
    to know it will fit the screen but px in css file not like webpage */
    /* margin-left: auto;
    margin-right: auto; */
    margin: auto;
     /* or you can better auto for all direction*/
    /* auto horizontally center the element within it's container and margin-top and margin-bottom by default is 0*/
    /* auto will only work with block elements not inline or inline-block because inline elements does not have width and inline-block default value of auto in margin-left and margin-right is 0 
    inline elements accept only vertical margin and padding ( it will show on inspect that have margin and padding at all directions but it will not affect the adjacent content from top or bottom only from left and right 
    to move child inside parent using margin you should add first border or padding to parent bacause of margin collapse
    if you did not separate between parent and child by padding or border the margin will collapse and if you add to child margin-top:10px
    and parent margin:0; so will collapse and final margin for both will be 10px then parent to move dwon 10px instead of moving 
    child inside parent 10px */
    /* or you can use auto function it's built in in Browser */
    /* you are editing a background inside this container <div> 
    and this container take all the width in limited length that why you can adjust width 
    but every container <div> have limited length*/  
    border-width: 10px;
    border-color: red blue black yellow;
    border-style:solid ridge dashed dotted;
    /* border: 10px red solid; */
    /* border: 10px red blue solid dotted;  */
    /* in shorthand border you can only add one value from each attribute*/
    
}

.background2 {
    background-color: cornflowerblue;
    width: 300px;
    padding: 10px;
    border: 10px solid red; /* box sizing:border-box it prevent border to count in element width*/
    outline: 10px solid green; /* outline outside the element and does not count in his width */
    /* in outline you cant change color or size or style of each direction all 4 direction will be the same*/
    
}

.Block {
    /* Block element
    - take full width if no width
    - add line break before and after 
    - accept padding , margin, width (respect every things) */
    background-color: coral;
    padding: 10px;
    margin: 10px;
}

.Inline {
    /* Inline
    - Elements at same line 
    - do not add line Break
    - does not accept ( width , height ) but accept padding and margin-left and margin-right
     */
     background-color: darkcyan;
     margin: 20px;
     width: 200px;
     padding: 15px;
     display: block; /* here we override the inline attribute of span and change it to block */

}

.Mix {
    /* Inline-Block
    - Elements at same line 
    
    - accept padding , margin, width (respect every things)
     */
    background-color:dimgray;
    display:inline-block ;
    padding: 10px;
    margin: 10px;
    width: 200px;
    height: 10px;
}

.visible {
    background-color: goldenrod;
    margin: 10px;
    display: none; /* none means not visible  // used when you press on list to view items inside 
    when you press display block when you press again display none */
}

.visible1 {
    background-color:lightseagreen;
    margin: 10px;
    visibility: hidden;
    /* difference between visibilty and display none that 
    when you write visible hidden the element will still have it's space 
    but with display none it will lose it's space */
}

.visible2 {
    background-color: mediumspringgreen;
    margin: 10px;
}

.one {
   
    border-bottom: 2px solid red;
    color: red;
   
}
.two {
 
    border-bottom: 2px solid green;
    color: green;
   
}
.three {
    
    border-bottom: 2px solid blue;
    color: blue;
   
}
.four {
    
    border-bottom: 2px solid black;
    color: black;
 
}
/* Grouping */
.one,
.two,
.three,
.four,
.add-on {
    padding: 10px;
    margin: 10px 0;
    background-color: #EEE;
}

/* nesting */
/* div p {
    color: red;
} you can use div p in nested elements to reach only p that inside <div> */
div .nesting { /* if p inside <div> and have class */
    color:red; 
} 

.nesting {
    color: blue;
} /* when you give the element two colors it will take the last one 
but if it's nested inside <div> it will prefer the color with div .nesting {} */ 

.name {
    background-color: blue;
    margin: 10px;
    display: inline-block; 
    /* width: fit-content; you have two options to make width fit the element 
    // you can use display inline-block or using width: fit-content 
    but it's better to use width: fit-content  */
    min-width: 400px; /* if you want the width to stretch when you add more text 
    there is  also max-width if you want to put limit*/
    min-height: 40px; /* like width // default value of height and width is auto*/
}

 .overflow {
     width: 150px;
     height: 150px;
     background-color:darkgrey;
     margin: 20px auto;
     border-radius: 6px;
     overflow: hidden; /* when the text overflow from background it will be hidden // default visible*/
     /* overflow: scroll; will add scroll to scroll the text inside container but disadvantage of scroll 
     if the text not big and do not go outside the container it still give you cursors for scrolling */
     overflow:auto; /* this is better than scroll because if the text not big it will not give you cursors for scrolling */
     /* overflow-y: hidden;
     overflow-x: auto;*/
 }

 .text {
     background-color:silver ;
     color: blue ;
     /* H-shadow(horizontal) , V-shadow(vertical) , Blur, Color */
     text-shadow: 1px 1px 1px red; 
 }

 .text2 {
     background-color: #eee;
     text-align:center;
     /* direction  ltr = left to right // rtl = right to left */
     direction: rtl; 
     /* difference between align and direction is align move the text to different location but does not change the direction of this text */
 }

.v-aline {
    vertical-align: top;
    /* vertical-align works only with ( inline - inline-block - table-cell elements(try this on file test-table.html )*/
}

.decor {
    background-color: gray;
    text-decoration: underline; /* for example underline or overline */
    text-transform: capitalize; /* first letter will be capital for all words   */

}

.google {
    background-color: red;
    color: white;
    padding: 12.5px 25px;
    display: inline-block;
    border-radius: 4px;
    text-decoration: none; /* to remove the underline from the link */
}

.space {
    background-color: gray;
    letter-spacing: 4px;
    word-spacing: 10px; /* spaces between words */
    text-indent: 100px; /* will give you space before text */
    /* difference between this and align that you can write by px 
    and you can move the text ouside the webpage */
    line-height: 2.5; /* spaces between lines the no means 2.5 x font-size */
    width: 800px;
    /* white-space: nowrap; usually when you have a width and the text reach the max width
     it will move to next line at next space but with this it will not move to next line and 
     will continue at same line ouside background width */
     word-break:break-all; /* when you reach the max width it will break the word */
     /* word-break:break-word; will break the word at specific characters like "-" "/" */
}

/* we have 
word-break // word-wrap // overflow-wrap
word-break: break-word; = word-wrap: break-word = overflow-wrap: break-word = overflow-wrap: anywhere => all of thoses has same effect ( diefference between anywhere and break-word is anywhere calculate min-content intrinsic sizes 
word-break: break-all will try to add maximum letters at each line 
word-break works good with flex and grid but word-wrap and overflow-wrap not except overflow-wrap: anywhere
white-space:nowrap will disable all of those
*/

.text-overflow {
    background-color: chartreuse;
    padding: 10px;
    width: 200px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* to put ... and this means the text not completed 
    and there is a part of text ouside width of background and hidden */

}
.text-overflow:hover {
    overflow: visible; /* when you point to the text by mouse the hidden part will apear 
    you can use title attribute at HTML go see there */
}



.family{
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    font-size: 20px;
    padding: 30px;
    background-color:blue;
    border: 10px solid;
    border-color:red;
}
    

/* elements will not inherit every things from family like ( padding and background) 
and will inherit ( text-align and font size) if the element have a default font-size like <h3> 
it will not inherit font-size and if you want to force it to inherit something 
like (padding and background) you must write it background: inherit;   */

.Inheritance {
    
    background-color: gray;
    border: 2px solid;
    border-color: inherit;
    padding:inherit;
    
}
/* if you have grand-father and father and you want to inherit from grand-father 
you should write inherit at son and also to the father    */

.Inheritance p 
{
    border: 2px solid;
    border-color: inherit;
    padding:inherit;
    
}

.testinline {
    display: inline-block;
    background-color: gray;
    text-align: center;
    width: 100%;
    /* margin-left :35%;  */
    /* text-align not working with inline element because inline element does not have enough width 
    to move to the center of the webpage but it will work with inline-block elements 
    if you give them the width (width:100%;) and it will for sure works with block elements 
    because it have full width  */
}

body {
    font-family: "cairo", sans-serif;
    
    
}
/* font family = you gave the website more than one option of fonts if the first one not applicable
 it will use the second one */
 /* you can take fonts links from here https://fonts.google.com/ and add thoses links to the Head and then write font-family at body*/
.font {
    background-color: #ddd;
    padding: 10px;
    
}
/* CSS Units
-px
-em = times
-rem = Root time
-vw (viewport width) 
-percentage
Read 
-vmin if h < w will take vh // if w < h will take vw
-vmax if h > w will take vh // if w > h will take vw
-vh (viewport height)  */

/* default Font size for Webpage is 16px but 1em not means 16px it means 1 time 
of font-size inherited from father if font size of for exp. <div> is 20 
then 2em for <span> will be 40px not 32px
ch (character unit)  is width of 0 which is 10px  */

/* if you used rem it will inherit the font-size from Root element ( html tag) 
and default value for this tag is 16px so if you write 2rem then will be 32 px  */

/* difference between rem and em 
rem = Root em will inherit from Root
em will inherit from Parent  */

/* percentage is percentage of font-size of father so if you write 50% and 
the font-size of father is 20px so the font-size of son is 10px */

/* vw= view port width 1vw means 1% of width of webpage for exp. if the width of webpage 900 
then the 1vw=9px this method is very good because if you change the wepage size 
it will change the font-size to adapt the new size of webpage */

/* you can use vmin with font-size or anything else like padding 
here we wrote font-size:10vmin means when the width or height of wepage become very small the size of text will be smaller to be fit to the screen 
we use this instead of media queries */

/* it's better to use vmin rather than vw because if we use vw at extremly large screen the Text will be tooo Large */
.vmin {
    background-color: tomato;
    min-height: 10vmax;
}

.vmin2 {
    color: white;
    font-size: 10vmin;
    text-align: center;
   
}

.font-size {
    font-size: 20px;
}

.font-test {
    font-size: 2vw;  
}

.fStyle {
    font-style: italic;
    font-variant:small-caps; /* will convert letters to capital but smaller size */
    font-weight:900; /*from 100 to 900 and the used font must support this no. of front weight */
    /* if you want to rest these values you can write font-weight/style/variant:normal  */
}

.click {
    background-color: transparent;
    border: none;
    color: red;
    font-weight: bold;
    cursor: pointer; /* means that element is clickable */
}

.grab {
    cursor: grab;
}

.move {
    cursor: move;
}

.parent {
    /* background-color: red; */
    /* padding: 10px; */
    border: 10px solid  blue;
    /* overflow: hidden; */
    /* height: 16px; */
    
}

.clear {
    clear: both; 
    /* better way to solve problem of float but you should add this clear 
    inside the container but different tag because we don't want the tag with clear style 
    to be counted as elements that will float also */
    /* the clear property is used to specify that which side of floating element are not allowed to float 
    / clear:both means floatings elements are not allowed to float on both sides */
    /* in this case the elements float above the container ( have no width) and the upper border of container appears 
    above floated elements and  lower border is below the floated elements once you write clear:both; 
    now it's forbidden any elements to be at same level of floated elements so the lower border will shift down 
    and the floated elements will be inside container*/
    /* difference between overflow:hidden; and clear both 
    if you wrote width of container and this width not enough for floated elements 
    with overflow:hidden; the excess of floated elements will cut and will be hidden ( but you can use overflow:auto; instead ) 
    but with clear:both; the browser will be confused there is no enough width to move lower border below floated elements 
    so the elements will still float above lower borders */
}

/* overflow: hidden; because now the elements float outside normal Flow 
    and when you use overflow:hidden it will return the elements to it's container because the parent now will creat BFC ( block formatting context )
    and will contain it's childs (floated elements )
    ( width of container will increase to fit the floated elements and remove any excess and the border of container will appear read about formatting context to understand this */

    /* Fromatting-Context Link */
    /* https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts */

    /* we have 3 options to keep float inside it's container 
 1. overflow:hidden; or overflow:auto; 
 2. hack way 
 hack way

.overflow::after {
    content: ".";
    visibility: hidden;
    display: block;
    clear: both;
    height: 0;
} 
 3. clear:both; on element inside the container*/

.parent div {
    padding-top: 10px;
    padding-bottom: 10px;
    text-align: center;
    background-color: #eee;
    /* display: inline-block;
    width: 25% by this way will 4 element be beside each other but 24% not 25% because inline-block add spaces between elements by default   */
    /*width: calc(94% / 5);*/     /* see calculation below */
    width: calc((100% - 90px) / 5);     /* see calculation below */
    /* margin-left: 1%;  */
    margin-left: 15px;
    float: left; 
    /* right if you write arabic // if you need 2 block level elements side by side you can use float */

}
/* (((Calculation 4 elements)))
content width is : 100%
5 spaces 1% * 5 = 5% from Content
(if you want spaces only between elements then will be 3 spaces but here also space from right and left)
95% Availabe Space
4 Elements the Width 95% / 4  */ 
/* (((Calculation 5 elements)))
content width is : 100%
6 spaces 1% * 6 = 6% from Content
94% Availabe Space
5 Elements the Width 94% / 5  */ 
/* (((Calculation 5 elements %-px)))
content width is : 100%
6 spaces 15 * 6 = 90 from Content
100%-90px Availabe Space
5 Elements the Width (100% - 90px) / 5  */ 


/* .hrmargin {
    margin: 0;  you can remove the margin of hr by this way
} */

/* .pmargin {
    margin: 0; 
} */

.trans {
    background-color: rgb(255, 0, 0);
    opacity: 0.1 ; /* transparent for every thing text and background */
}

.opac {
    background-color: rgba(255, 0, 0, 0.1);
/* opacity here  only for Background not for text */
}

.position {
    margin-top: 10px;
    color: white;
}

    /* position fixed and absolute will go outside layout but fixed related to layout and absolute related to it's parent 
       position sticky is hybrid between relative and absolute
    so if you write in HTML file one element ( position absolute or fixed or sticky ) before another element ( another position )
    the 1st element will be below 2nd element 
    if you write 1st element in HTML file after 2nd element the 1st element will be above
    if both relative or static every element will be at his position no one can be above other one
    if 2nd element have no position ( default value static position) 1st element (position absolute or fixed or sticky) will be always above 
    at psudo element ( before or after ) will be considered that it's written after element so will be above always*/

    /* to change position of son (position:absolute) inside container (position:relative or absolute) 
    we use left:px/% or right:px/% or top:px/% or bottom:px/% or margin no problem
    
    to change position of son (float:left or right) inside container 
    we use margin-left:px/% or margin-right:px/% or margin-top:px/% or margin-bottom:px/% 
    
    to change position of son (static default value) only margin no accepting left right top bottom*/

    /* (((very important read please))) */

    /* position absolute will move related to it's parent ( position : relative or absolute)
    if you write right:0; top:0; so will move to corner top right because this means 
    he will move till the right side has zero pixel on right and top side has zero pixel from the top
    and if you write right:20px; will push the element to left side and vice verse 
    but it will send the element to the right border of it's parent then will shift it to left*/


    /* position relative will move related to it self not to it's parent
    that's why when you write right:0; it will not move to right side like absolute because it 
    move related to it self and right:0; means right side has zero pixel to it's related container 
    but it related to it self so always it's zero pixel from right side */

    /* position sticky will move related to the layout but also can't go outside it's parent
    that's why right:; and bottom:; not working because you cant push the sticky element
    outside it's parent if you want to move it use left and top this at english version of website 
    at arabic version directions will be inverted 
    to move it you can use px or % but be ware that px or % will calculated from the layout not it's parent*/

    /* difference between position absolute and fixed that both will go outside work flow and both move related to viewport 
    but when you move viewport by scrolling to view another content of webpage fixed will move with you but absolute not */

 .pos1 {
    background-color: red;
    width: 100px;
    position: static;
    /* right: 0px; */
    /* margin: 0px; */
   
}

.pos2 {
    background-color: green;
    width: 100px;
    position: relative;
    /* position: static; */
    /* bottom: 10px; */
    /* margin: 0; */
}

.pos3 {

    background-color: yellow;
    width: 100px;
    position: absolute;
    /* right: 0; */
}
.pos4 {

    background-color:aqua;
    width: 100px;
    position: relative;
    /* right: 0; */
}

.pos5 {
    background-color: red;
    width: 100px;
    position: absolute;
    /* bottom: 20px; */
    /* margin: 200; */
    right: 0;
    
}

/* if you want to move element inside other element(parent = bigboss) the parent should be relative 
if the son element is relative it will move according to his position but if son absolute 
it will move according to position of parent*/
.bigboss {
    width: 500px;
    height: 300px;
    background-color: blue;
    position: relative;
}

.fixed {
    background-color:red;
    width: 100px;
    position: fixed;
    right:0;
    top: 0;
    /* fixed with page even with scrolling */
}

.sticky {
    background-color:yellow;
    width: 100px;
    position:sticky;
    bottom: 0;
    left: 100%;
    /* text-align: right; */
    /* margin-left: 850px; */
    
}

/* the element with highest z-index will be on the top
if all elements don not have z-index the last element will be above
if 2 elements have same z-index the last one will be above
z-index will not work if no position mentioned it does not matter which position even if it absolute and have higher z-index 
will be above relative or fixed 
but static will be always below if you other element to be below static element give this element negative value of z-index 
z-index = -1  every elements will be above him */
.zindex {
    padding: 10px;
    width: 100px;
    color: white;
    text-align: center;
    position: relative;
}

.index1 {
    background-color: red;
    position: inherit;
    padding: inherit;
    width: inherit;
    left: 20px;
    top: 40px;
    z-index: 3;
}
.index2 {
    background-color: blue;
    position: inherit;
    padding: inherit;
    width: inherit;
    left: 15px;
    top: 15px;
    z-index: 2;
}
.index3 {
    background-color: green;
    position: inherit;
    padding: inherit;
    width: inherit;
    left: 5px;
    bottom: 5px;
    z-index: 1;
}

.li-sons {
    background-color: #EEE;
    margin-bottom: 10px;

}

.ul-parents {
    /* list-style-type:circle;
    list-style-position: inside;   
    list-style-image: url(""); */
    /* shorthand  */
    list-style: circle inside url("");
    
    /* to reset the ul remove list-style and padding */
    /* list-style: none;
    padding: 0; */ 
} 

.table-styling {
    width: 100%;
   border-spacing: 5px;
   font-family: fantasy;
}

.table-styling td {
    padding: 15px;
    background-color: #EEE;
    border: 1px solid #ccc;
   
}

.table-styling thead td {
    background-color:burlywood;
    color: white;
    font-weight: bold;
    text-align: center;
    border-color: blue;
}

.psudo-one {
    background-color: red;
    color: white;
}

.psudo-two {
    background-color: #EEE;
    width: 100px;
    height: 100px;
}

.psudo-a {
    color: green;
    text-decoration: none;

}

/* we have 6 types of Psudo-elements
1. First Letter
2. First Line
3. After
4. Before
5. marker
6. selection */

/* marker works only with li so it's always li::marker or you can write only ::marker */
/* psudo class = special class will be active once you do special action like move cursor to link  */
/* psudo classes like hover focus action */
.psudo-a:hover {
    color:red
}

/* when you check the box the next label will change it's color to red */
.psudo-ch:checked + label {
    color:red
    
}

.psudo-a:visited {
    color: yellow;
}

/* that's mean any empty div (no text inside or no child inside) will take this border if you need any empty tag you can write (:empty) */
/* div:empty {
    border: 5px solid red;  
} */

.psudo-in {
    border: 2px solid red;
}

.psudo-in:focus {
    border: 10px dotted blue ;
    outline: none ; /* if you need to remove the default border of input ( called outline) */
}

/* ((old school)) */
.psudo-el1 span {
    display: inline-block;
    background-color: red;
    color: white;
    font-size: 60px;
    font-weight: bold;
}

/* ((new school with psudo class)) */
.psudo-el2:first-letter {
    display: inline-block;
    background-color:blue;
    color: white;
    font-size: 60px;
    font-weight: bold;
}
    
.psudo-el3:first-line {
    color: green;
    font-weight: bold;
    font-size: 20px;
}
    
.psudo-el4::selection {
   background-color: black;
   color: yellow;
}

.psudo-parent {
    margin-bottom: 20px;
    overflow: hidden;
    
    
}


.psudo-user {
    background-color: #eee;
    width: 50px;
    margin-right: 20px; 
    padding: 10px;
    height: 55.5px;
    float: left;
    font-size: 50px;
    text-align: center;
}

.psudo-one1 {
    background-color: #eee;
    padding: 10px;
    width: 600px;
    float:left;
    position: relative;
}

/* ((old school)) to put line beside element ( see the line at webpage) is using span and give it styles */

/* .psudo-one1 .pipline {
    position: absolute;
    width: 10px;
    height: 100%;
    if you want to move outside parent element write negative value
    right: -20px;
    top: 0;
    background-color: green;
} */

/* ((new school)) using psudo element  */

/* this is the cursor  */
.psudo-one1:before {
    content:"" ;
    width: 0px;
    height: 0px;
    left:-30px;
    top:50%;
    /* you can use margin-top = - half of element's height or you can use transform */
    margin-top:-10px;
    /* transform: translate(0, -50%); */
    background-color: transparent;
    position: absolute;
    border-width: 10px;
    border-style: solid;
    border-color: transparent green transparent transparent;
} 


/* this is the line after element  */
.psudo-one1:after {
    /* you should add content: ""; to make psudo elemet appear and you will find it at dev tools called (::after) 
    if you write text at content the text will appear before the element*/
    
    content: ""; 
    width: 10px;
    height: 100%;
    right: -20px;
    top: 0;
    background-color: green;
    position: absolute;
}





.psudo-parent2 {
    margin-bottom: 20px;
    overflow: hidden;
    counter-increment: members-counter;
     /*counter-increment will count elements and give each element a no.  */
    /* 2 steps look comments below */
}

.psudo-one2 {
    background-color: #eee;
    padding: 10px;
    width: 600px;
    float:left;
    position: relative;
    
}


.psudo-user2 {
    background-color: #eee;
    width: 50px;
    margin-right: 20px;
    padding: 10px;
    height: 55.5px;
    float: left;
    font-size: 50px;
    text-align: center;
    
}

.psudo-one2:before {
    /* we can add anything  text , link  we wrote in attribute in element in HTML file go see there */
    content:attr(data-text);
    /* width: 0px;
    height: 0px;
    left:-30px; */
    color: red;
    display: none;
 }


 /* default display of psudo-elements is inline because it's the initial value of display: inline it will not accept height or weight
position:absolute will accept width and height because it is outside normal flow and has it's own rules*/


 /* you can use psudo-element and psudo-class together here when you move mouse to the element psudo-element will appear  */
 .psudo-one2:hover:before {
     display: inline-block;
 }

.psudo-one2:after {
   /* we will write that name of counter-increment that we wrote on parent (members-counter)  */
    content: counter(members-counter); 
    position: absolute;
    background-color: red;
    color: white;
    width: 20px;
    height: 30px;
    text-align: center;
    font-weight: bold;
    right: -10px;
    top: 50%;
    margin-top: -15px; 
    /* margin-top always half-value of height after writing top:50%  */
}

.counter-parent {
    counter-reset: names-counter 0;
    /* 3 steps look comment below */
    /* this initializes counter if you need zero-based index use -1  */
}

.counter-sons{
    counter-increment: names-counter 1;
    /* like += 1 in python add 1 every count  */
}

.counter-sons:before {
    content: counter(names-counter) ". ";
    /* return value of count */
}

.counter-parent2 {
    counter-increment: namess-counter ;
    /* 2 steps look comment below */
   
}



.counter-sons2:before {
    content: counter(namess-counter) ". ";
    /* return value of count */
}

.counter-big {
    counter-reset: namesss-counter 0 ;
    /* 3 steps look comment below */
    /* this initializes counter if you need zero-based index use -1  */
}

.big-sons2 {
    counter-increment: namesss-counter 1;
}

.big-sons2:before {
    content: counter(namesss-counter) ". ";
    /* return value of count */
}

.psudo-attr:before {
    content: attr(data-text); /* you can add also url()*/
    font-weight: bold;
    font-size: x-large;
    color: white;
    background-color: red;
    width: 100px;
    padding: 10;
    display: none;

}


/* if youy elements have parent container ( with this you can controll count increment and you can start at any point you need counter-reset: namescounter 0 , 1 , 2 , 3 , 4 , ..... )
    counter-reset: namescounter 0  ( at parent) 
    counter-increment: namess-counter 1 ( at child) 
    content: counter(namesss-counter)  ( at psudo-element)
    
    if your elements have no container parent ( with this you can controll count increment only counter-increment: namess-counter 2 )
    counter-increment: namess-counter ( at element) 
    content: counter(namesss-counter) ( at psudo-element)
    */

    /* you can do it by 2 or 3 steps
    2 steps by adding counter-increment:list-counter 1 ; to real element and the content: counter(list-counter); at psudo element 
    3 steps by adding counter-reset: list-counter 0; at parent  counter-increment:list-counter 1 ; to real element 
    and the content: counter(list-counter); at psudo element  
    with 3 steps you can determine the count start from where and every count add 1 or 2 or .... 
    with 2 steps you can determine only every count add 1 or 2 or .... */

.psudo-attr:hover:before {
    display: inline;
}


.psudo-ul {
    list-style: none; 
    /* to reset the style of list */
}
.psudo-ul li {
    position: relative;
    
}

.psudo-ul li:before {
    content: "";
    width: 0px;
    height: 0px;
    left:-30px;
    top:50%;
    margin-top:-10px;
    background-color: transparent;
    position: absolute;
    border-width: 10px;
    border-style: solid;
    border-color: transparent green transparent transparent;
    /* margin-bottom: 10px; */
    /* margin-top negative will work but margin-bottom positive will not work because the rendering of browser is from above */

}

.radius {
    width: 100px;
    height: 100px;
    background-color: red;
    margin: 20px auto;
    /* border-radius: 50%; */
    /* if width and height are the same then there will be no difference between % and px
    but if width and height not equal with px will take smallest value see pic to understant the difference between px and % */
    /* if border-radius half of width and height the element will be circle
    or you can write border-radius 50% */
    outline: 10px solid yellow;
    border-top-left-radius: 20px 20px; /*2 values for 2 corners */
    border-bottom-right-radius: 20px 20px;
}

.boxshadow {
    padding: 20px;
    background-color: #EEE;
    margin: 20px auto;
    width: 300px;
    /* text-align: center */
    /* inset means shadow from inside and you must write it / outset means shadow from outside and it's the default you don't have to write it */
    /* H-shadow / V-shadow / Blur / spread / color / inset or outset */
    box-shadow: 9px 10px 5px 5px #909086;
    /* you can add more than one shadow  */
    /* box-shadow: 0px 10px 0px 0px yellow , 0px 20px 0px 0px black; */
    /* (vendor prefixes) */
    /* -webkit-box-shadow: inset 0 0 1px 1px red , 0 0 1px 1px blue ;
    -moz-box-shadow: inset 0 0 1px 1px red , 0 0 1px 1px blue ;
    -ms-box-shadow: inset 0 0 1px 1px red , 0 0 1px 1px blue;
    -o-box-shadow: inset 0 0 1px 1px red , 0 0 1px 1px blue;
    box-shadow: inset 0 0 1px 1px red , 0 0 1px 1px blue; */
    /* https://pixelbrewco.com/index.php?step=blog&step2=post10 */
}

/* you can use wildcard ;)  */
/* you can use wild card but you should add box-sizing: content-box to parent 
because if you didnot it will reverse it's action you can also use vedor prefix 
or not up to you */
 
/* * {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
} */

.box-model {
    width: 600px;
    overflow: hidden;
    margin: 20px auto;
    padding: 20px;
    background-color: #ddd;
    /* box-sizing: content-box; */
 
}

.boxone {
    background-color: #eee;
    width: 298px;
    /* float: left; */
    display: inline-block;
    padding: 10px;
    border: 10px solid red;
    height: 60px;
    /* box-sizing: content-box; */
    box-sizing: border-box;
    /* defaul value is content-box ( when you add padding or border  will add them 
    to width and height and the 2nd element will move to next line )
     but border-box will accept padding or border and will decrease the width and height 
     to maintain the original values and the elements remain beside each other
     but border-box does not accept margin or height or width once you increase one of them the element will move to next line  */
}

/* the difference between float and absolute position that float = the element float above other 
elements if both float they will stand beside each other
but with  absolute position the element exit the layout and other elements will take his place and he 
will be below them */

.blue {
    background-color: blue;
    float: right;
}
.red {
    background-color: red;
    float: right;
}
.green {
    background-color: green;
    /* margin-left: 10px; */
    /* float: right;  */
    /* here the green will be beside red */ 

}

/* second use of clear both is prevent not floated to shift up but you should write div tag with clear style before not floated element */
.clear2 {
    clear: both;
}
/* the clear property is used to specify that which side of floating element are not allowed to float / clear:both means floatings elements are not allowed to float on both sides */
/* if you write clear div before red the red will float at next line because now it's not allowed any element to float at previous level
that why we wrote clear div before green to stop it from shifting up .. it's like blocking previous level and no elements allowed to enter this level */


 
/* we can divide selector if it's two words and more than one element have same 2nd word you can do like this */
.box {
    height: 100px;
    width: 100px;
}

.transition {
    background-color: #eee;
    width: 200px;
    height: 100px;
    /* transition-duration: 5s; */
    /* transition-delay: 0.2s; */
    /* to change all proprites at Hover and this is the default Value */
    /* transition-property: all; */
    /* you can choose which properites you want to change the other proprites will change immediatly 
    without duration or delay*/
    /* transition-property: margin-left, margin-top ; */
    /* transition-property: width ; */
    /* transition-timing-function:ease; */
    /* transition-timing-function:linear; */
    /* ease = slow fast slow and this is the default value */
    /* linear= same speed */
    /* ease-in = slow fast fast */
    /* ease-ut = fast fast slow  */
    /* ease-in-out = slow-normal-slow */
    /* transition-timing-function:ease-in-out; */
    /* ((shorthand)) */
    /* transition: width 3s, height 1s; */
    /* transition: width 3s 1s linear, height 1s 2s ease; */
    /* property , duration, delay , timing function  */
    /* transition: all 10s 2s linear; */
   
}

.transition:hover {
    margin-left: 50px;
    margin-top: 50px;
    width: 500px;
    height: 200px;
}

.important {
    /* important will override the internal or inline style 
    even if you write in css file another color for this element it will also override it */
    background-color:blue !important;
    width: 250px;
}

/* margin-collapse happend vertically when 2 elements at same Formatting-context so there is no margin collapse for float and absolute
because float and absolute will be outside normal flow*/

/* Formatting Context Link */
/* https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts */


.margin-collapse {
    overflow: hidden;
    margin: auto;
    width: 400px;
    height: 200px;
    padding: 10px;
    background-color: #eee;
}

.margin1, .margin2  {
    float: left;
    width: 50%;
    height: 100%; 
    

}

.margin1 {
    background-color: #ddd;
}

.margin2 {
    float: left;
    width: 50%;
    height: 100%;
    
    
}
.marginson1 {
    background-color:red;
    height: 100px;
    margin-bottom: 40px;
}

.marginson2 {
    background-color:green;
    height: 100px;
    margin-top: 20px;
    /* margin collapse when you add margin from element and add another margin from next element 2 margins will collapse and will be one margin for both  */
    /* if 2 margins not equal the highest value will be the final margin collapse value */
    /* collapse margin only vertical */ /*nesting does not prevent collapse */
    /* 2 elements should be sticking to each other if there is anything between then margin will not collapse */
}

/* difference between * and :root ( psudo class) is * for each elements but :root for whole webpage 
for exp :root { background-color:red; } will change the background color of whole page ( like html{} but :root will override it if both witten
but *{ background-color:red; } will change background of each element inside webpage not the webpage itself  */

/* :root {
    --mainColor: blue;
    --padding: 20px;
} */

/* var ( variablename, Fallback value) */
/* fallback value = if variable color not availabe this will be 2nd option */
/* there are two types of var global and local  */
/* global variable means for all when you write it at :root{} 
local varaible when you write it at element or parent*/

/* usually we add variable at :root{} or you can write it at HTML tag on HTML file with style like
<html lang="en" style="--main-color: blue;"> */
.var {
    background-color: var(--mainColor);
    color: white;
    padding: calc(20px + var(--padding)) ; /* you can calculate with var */

}

.var2 {
    color:var(--mainColor);
    background-color: #eee;
    padding: var(--padding);

}

.var3 {
    color: var(--mainColor);
    border:2px solid  var(--mainColor);
    padding:var(--padding);

}

.var4:hover {
    color: var(--mainColor);
}

.localvar {
    --mainColor: black; 
    background-color: var(--mainColor);
    padding: var(--padding);
    color: white;
    /* you can set local variable for each element and will override the variable in :root */
}


/* we can use wildcard instead of writing it to each element  */

/* * {
    box-sizing: border-box;
} */


/* Flex Container shrinks elements (width) to prevent overflow 
(elements will go outside box only at rare case = when sum of their minimum width > parent's width) 
no matter how many elements will you add it will shrink them to be at same line 
even if you write at style of these elements margin or width of elements more than width of container 

but justify-content:space-between or space-evenly or space-around you need to give the flex box free space 
to create spaces between elements it will not shrink elements to create these spaces
 */

 /* flex-box childs will stretch to take height of parent because default-value of align-items is stretch and will not stretch to take width of parent because there is no justify-items in flex
    grid childs will stretch to take full height and width because both availabe in grid ( align-items and justify-items )   */
/* flex-box childs all will be at same line but in grid each child will take new line */


.flex {
    /* overflow: hidden; */
    background-color: #eee;
    width: 600px;
    padding: 20px;
    margin: 20px auto;
    display: flex;
    /* flex-direction: row-reverse; */
     /* or you can use direction: rtl; */
    /* flex-direction: column; */
    /* flex-direction: column-reverse; */
    /* flex-wrap: wrap; */ 
    /* will move the fifth element to previous line not next line*/
    /* flex-wrap: wrap-reverse;  */
    /* this is shorthand for both flex-wrap and wrap-direction */
    /* flex-flow: row wrap; */
    /* default value flex-start  */
    /* justify-content:flex-end; */
    justify-content:center; 
    /* to make space-between work you have to free space for it that's why we changed the the width from width: calc(100% / 3); 
    to width: calc(98% / 3); or you can without space-between add margin to 2nd element directly 
     the flex box will shrink items to handle this margin but float not 
     with float if you change width: calc(98% / 3); to lower value
     the extra space will be added to the end not between elements but with flex if you change it to lower value 
     it will add the extra space between elements*/
    /* justify-content: space-between; */
    /* space-around will add space before and after elements for if you have 3 elements now you have 6 spaces left and right */
    /* justify-content: space-around; */
    /* to understand the difference between space-around and space-evenly see the pic in coding album */
    justify-content: space-evenly;
    /* default value of align-items is stretch; so when you put elements inside parent ( display:flex;) they will stretch to fill all height of parent ( there is no justify-items in flex that's why child will not stretch to take full width 
       but if you give childs specific height they will not stretch or if you write ( align-items:flex-start; / align-items:flex-end; ) the childs will not stretch */
    /* align-item: flex-start is vertical from up to down but justify-content:flex-start; is horizonatl from left to right  */
    /* align-items: flex-start;  */
    /* align-item: flex-end is vertical from down to up but justify-content:flex-end; is horizonatl from right to left  */
    /* align-items: flex-end;  */
    align-items: center; 
    

}

 /* to move only one child on y-axis you can use 
        ( align-self:flex-end; / align-self:flex-start; / align-self:center; ) 
        or
        margin-top:auto; will move the child to bottom  ( it means it will add all width on top side of child ) 
        margin-bottom:auto; will move the child to top  ( it means it will add all width on bottom side of child ) 
        margin-top:auto; and margin-bottom:auto; will center the child vertical

    to move only one child on x-axis you don't have justify-self:; ( justify-self not work with flex work only with grid ) 
         but you can use margin:auto; 
        
        margin-left:auto; will move the child to right ( it means it will add all width on left side of child ) 
        margin-right:auto; will move the child to left ( it means it will add all width on right side of child ) 
        margin-left:auto; and margin-right:auto; will center the child horizontal

    you can use also position:absolute; to move childs but give the parent position:relative; if you need childs to move related to the parent if not childs will move related to webpage
      */

/* with display=flex you don't need overflow=hidden and float left  */
/* flex-direction : row this is default value and will arrange elements at same line*/
/* difference between float and flex that with float elements float and positions of them 
will be beside each others and not affected by direction of webpage but flex it will arrange 
elements beside each other according to direction of webpage so if you change direction to rtl 
flex will change the position of elements but float you must give him direction float:right or left  */
/* when we add fifth div to both flex and float -- flex will shrink items to keep all of them 
at one line (if you want to force the fifth element to move to next line you should write 
flex-warp: wrap; and it's default value flex-wrap;nowrap; ) but float fifth element will go to 
next line because the fifth element have width and box-sizing = border-box will only accept 
padding or border to keep element at same line*/

.float {
    overflow: hidden;
    background-color: #eee;
    width: 600px;
    padding: 20px;
    margin: 20px auto;
    direction: rtl;
}

.flex div {
    background-color: red;
    color: white;
    /* float: left; */
    width: 25%;
    /* width: calc(100% / 3); */
    /* we changed here to 98% because we want to add 2% margin at 2nd element by  */
    /* width: calc(94% / 3); */
    text-align: center;
    padding: 20px;
    box-sizing: border-box; 
        /* margin-right: 1%;
        margin-left: 1%; */
    
    
}

.float div {
    background-color: red;
    color: white;
    float: left;
    /* width: 25%; */
    /* width: calc(100% / 3); */
    /* we changed here to 98% because we want to add 2% margin at 2nd element by justify-content: space-between; */
    width: calc(94% / 3);
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
    /* direction: rtl; */
    margin-right: 1%;
    margin-left: 1%;
}

.onefloat {
    height: 80px;
}
.twofloat {
    height: 120px;
}
/* .threefloat {
    margin-left: 1%;
    margin-right: 1%;
} */

.oneflex {
    height: 80px;
}
.twoflex {
    height: 120px;
}
/* .threeflex {
    margin-left: 1%;
    margin-right: 1%;
} */

.center {
    background-color: blue;
    color: white;
    width: 300px;
    height: 200px;
    display: flex;
    /* horizontal */
    justify-content: center;
    /* vertical */
    align-items: center;
    /* or you can use this way but will not be accurate beause line-height not accurate */
    /* line-height: 200px;
    text-align: center; */
    /* or you can use position but to move the text (center) should be a child inside parent for exp. span inside div 
    then you can move it but with flex box no need for that you can move text directly */
    
}

/* .oneflex1 {
    height: 80px;
}
.twoflex1 {
    height: 120px;
} */
/* .threeflex1 {
    margin-left: 1%;
    margin-right: 1%;
}
.fourflex1 {
    margin-left: 1%;
    margin-right: 1%;
}
.fiveflex1 {
    margin-left: 1%;
    margin-right: 1%;
} */

.flex1 {
    background-color: #eee;
    width: 600px;
    height: 400px;
    padding: 20px;
    margin: 20px auto;
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    /* align-items work with elements but align-content work with line so of there is only one line so align-content has no effect */
    /* difference between align-content and align-items is align items will arrange the elements vertical but also with spaces 
    if the container big align-content will move all elements ( as one block without spaces between lines)   */
    /* align-content: flex-start;  */
    /* difference between justify-content: space-around; and align-content: space-around; that with justify the spaces between 
    each element (horizontal) but with align spaces between lines (vertical) */
    /* align-content: space-around; */
    /* align-content: space-between; */
   

}

.flex1 div {
    background-color: red;
    color: white;
    width: calc(94% / 3);
    text-align: center;
    padding: 20px;
    box-sizing: border-box; 
    

}
.flex2 {
    background-color: #eee;
    width: 600px;
    padding: 20px;
    margin: 20px auto;
    /* display:flex; container (parent) itself act as block level element but display:inline-flex; container (parent) act as inline level element */
    display: inline-flex;
    /* flex-direction:column; */
    height: 300px;
    align-items: flex-start;
    


}

.flex2 div {
    background-color: red;
    color: white;
    width: 80px;
    text-align: center;
    padding: 20px;
    box-sizing: border-box; 
    margin-right: 5px;
    /* default value of flex-grow is 0 which means no grow but 1 means all items will grow like each other to fill the remaining space */ 
    
    /* if one element have flex-grow:3; and the rest of elements 1 the element which have value 3 will grow by ration 3:1 
    only if there is availabe space ( sum of elements width + margins < parent's width)
    once the sum of elements width + margins = parent's width all elements will be same size */
    
    /* if one element have flex-grow:3; and the rest of elements default value 0 then the more space you give them 
    the element which have value 3 will increase in size till the rest of elements reach their minimum width */

    /* if one element have flex-shrink:3; and the rest of elements 1 the element which have value 3 will shrink by ratio 3:1 
    only if there is no availabe space ( sum of elements width + margins > parent's width) */


    /* if one element have flex-shrink:3; and the rest of elements value 0 then the more space you give them 
    the element which have value 3 will decrease in size till reach it's minimum width the elements will exit flex-box because 
    default value of flex-shrink is 1 ... it should be 1 because this how flex-box works 
    ( shrink elements to keep elements at same line and inside box ) */

    flex-grow: 1;
    

}

/* .threeflex2 {
    to override flex-grow: 1; in flex2 div you can write !important or write it a style in element i HTML file
    because inline style stronger than external style 
    flex-grow: 3 !important;
    flex-shrink: 3 !important;
  
} */

/* default value of oder is 0 so if you write 1 the element will be last one because 1 bigger of 0 which the rest of elements have 0 
if you enter negative value like -1 the element will be first one  */
.oneflex2 {
    order:6 ;
}
.twoflex2 {
    order:2 ;
    /* flex-basis:100px; means initial width of child will be 100px */
    /* flex-basis value can be considered as width or height depending on flex-direction columns or row */
    /* flex-basis default value auto */
    /* flex-basis will be useful in some cases like 
    flex-direction is columns and you wrote width at element style will give you wierd shape but if you write flex-basis 
    it will consider this width as height and vice versus */
    /* difference between flex-basis and min-width that when you decrease the parent width with flex-basis will shrink the childs width 
    but with min-width will not shrink childs width */
    /* if you write max-width the flex-basis will respect that  */
    /* width: 300px !important; */
    /* flex-basis: 300px; */
    /* max-width: 200px; */
    /* then the width will be 200px */
    /* shorthand (flex-grow - flex-shrink - flex-basis) */
    flex: 1 1 150px;
    /* here align-self will work and align-items not.. because align-self will override the align-items which written in .flex2 */
    align-self: flex-end;
    /* align-items: flex-end; */

    

    

}
.threeflex2 {
    order:3 ;
}
.fourflex2 {
    order:4 ;
}
.fiveflex2 {
    order:5 ;
}
.sixflex2 {
    order:1 ;
}

.inline-flex {
    display: inline-block;
}


.imgfilter {
    transition: 0.3s;
    /* filter: grayscale(100%); */
    /* filter: blur(4px); */
    filter: invert(100%);
}

.imgfilter:hover {
    /* filter: grayscale(0); */
    /* filter: blur(0); */
    filter: invert(0);
}

/* gradients = transition between one or more colors */
/* why fixed below gardients ???  */
.gradients {
    /* linear-gradient( direction or angle , color stop1, color stop2, ... ) */
    /* direction of color transition to right , to left , to top , to bottom */
    /* angle like angle of circle 0 means to top / 90deg means to right / 180 to bottom / 270 to left   */
    /* 20% or px 1st color will stop at 20% and the next color will fill the rest space  */
    /* background-image: linear-gradient(90deg, red, green 20% , blue); */
    width: 800px;
    height: 200px;
    background-color: #EEE;
    margin: 20px auto;
    position: relative;
    padding: 10px;
}

.gradients:before {
    content:"" ;
    position: absolute;
    top: -5px;
    left:0;
    width: 100%;
    background-color: red;
    height: 5px;
    /* if you give the 2nd color percentage it will not merge (gradiant) with previous color  */
    background-image: linear-gradient(to right,
     #2980b9 20%,
      #27ae60 20%,
       #27ae60 40%,
        #d35400 40%,
          #d35400 60%,
           #8e44ad 60%,
             #8e44ad 80%,
              #c0392b 80%,
                #c0392b 100% );
}

.pointerevent {
    
    pointer-events: none;
}

.caretcolor {
    caret-color: red;
    
}

/* grid system dividing you webpage to major regions ( like columns and rows)  */
/* grid-auto-rows and columns default value is auto that's why all child elements will stretch to fill all width and height but if you use place-items or place-content grid-auto will lose it's effect*/
/* when you use place-items or place-content in Grid childs will take width and height enough only for their content
and if you give only one child width the rest of childs will take this width ( in case of place content and if they don't have specific width) */
/* in case of place-content when you give child width:100% or height:100% childs will not take it from parents but with place-items will do  */
/* align-content in flex will work with line so you need 2 childs or more but in grid you can use it with one child only */

.grid-parent {
    margin: 20px auto;
    width: 800px;
    height: 500px;
    background-color: #eee;
    display: grid;
    /* when you write 3 values that' means you want 3 columns and you can write px or percentage or you can write auto auto auto 
    if you want three identical columns or you can write repeat(3, auto) */
    /* grid-template-columns: 100px repeat(2, 50px) 25% auto; */
    /* (( fraction is greedy and Auto is shy)) */
    /* here will not 25% 25% 25% 25% because fr always take more than auto // you can also use fr with repeat(2, 1fr) */
    /* in case of ( auto and fr )  auto will take minimum width (minimum width = is width to fit only the content 
    so if you increase content ( text for exp. ) Auto will take more width to fit new content and the rest fr will take it */
    /* grid-template-columns: auto auto 1fr 1fr; */
    /* but here fraction will take the rest and four columns will be like each other because total width 800px */
    /* grid-template-columns: 200px 200px 1fr 1fr; */
    /* grid-template-columns: repeat(4, 1fr); */
    /* if you write only one value then first row will be 100px and the rest of rows will take the rest of height */
    /* grid-template-rows: 100px; */
    /* you can also use % , px , auto, fr , repeat() */
    /* grid-template-rows: 200px 1fr auto ; */
    /* grid-template-rows: repeat(3, 1fr); */
    /* For example, grid-template: 50% 50% / 200px; will create a grid with two rows that are 50% each, and one column that is 200 pixels wide info from garden game */
    /* row-gap: 20px; */
    /* column-gap: 20px; */
    /* shorthand of row-gab and column-gap */
    gap: 10px 10px ;
    /* grid-template-columns: repeat(6, 1fr); */
    /* grid-template-rows: repeat(3, 1fr); */
    /* justify-content will move elements if columns and row is auto because auto will take the remaining space 
    but if there something want to take a space from him it will give him that space (auto is shy) 
    but fraction will take all the remaining space and it will not give that space to anyone 
    that's why justify-content not work with fraction */
    /* justify-content: flex-end; */
    /* look that shape of elements after justify-content: space-between; to do this is flexbox yoou should give each element width 
    to give flexbox hint how many elements in each row then you should write flex-wrap */
    /* justify-content: space-between; */
    /* justify-content: space-evenly;
    align-content: flex-start; */
    /* here you wrote head 5 times that's means 5 columns  */
    /* grid-template-areas: "head head head head head"; */
    grid-template-areas: "head head nav nav nav" "cont cont cont cont cont";
}

/* => with grid-sytem you can not make L shape with same element ( for exp. you can not write this [ grid-template-areas: "e1 e1 e1" "e1 e2 e2 " "e1 e3 e3" ]
   => with grid-system you can not put empty column inside same element ( for exp. you can not write grid-template-areas: "e1 . e1" 
    but you can do it with two elements ( grid-template-areas: " e1 . e2" */

/* align-items + justify-items = place-items // align-content + justify-content = place-content */

.grid-parent div {
    background-color: red;
    color: white;
    padding: 20px;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
}

.grid1 {
    /* grid-column:; shorthand of grid-column start and grid-column end will take space of elements from 1 to 7 (7 not included) 
    but be sure that you do not take space of elements more than columns if you take space of 7 elements and you have only 6 columns 
    extra column will be added automatically and will damage the design but with span it will not damage the design and add extra column
    for exp. if you want to 4th element to take space of 3 columns and and you have 5th and 6th columns in this row then it will not 
    add extra column it will move to next line but if you write grid-column:4 / 7;  it will add extra column */
    /* with grid-column-start and end you can use negative value to count from opposite site this info from garden game */
    /* you can move backword grid-column-start: 5; grid-column-end: 2; this info from garden game */
    /* you can write grid-column: 2 / span 3 here you give him start from position 2 and span 3 this info from garden game */
    /* instead of 1 / 7 you can write span 6 but the advantge of span that you do not write start and end 
    just write ant any element span and will take space of next elemets */
    /* grid-column: 1 / 7; */
    /* grid-column: span 6; */
    /* if you are on 1st element and write to start from 2nd column will give you empty space before the element and this space called 
    (offset)  */
    /* grid-column: 2 / 7; */
    /* grid-column: 1 /2 ; */
    /* like grid-row but when you take space of 2 rows the extra element will not find any space to go so will create a new row and move to it  */
    /* grid-row: 1 / 3; */
    /* here this element take space of 5 columns because 
    you write at .grid-paren  grid-template-areas: "head head head head head";  */
    /* grid-area: head ; */
    /* here this element take space of 2 columns because 
    you write at .grid-paren  grid-template-areas: "head head nav nav nav";  */
    grid-area: head ;


}

.grid2 {
    /* here this element take space of 3 columns because 
    you write at .grid-paren  grid-template-areas: "head head nav nav nav";  */
    grid-area: nav;
}

.grid3 {
    grid-area: cont;
}
/* .grid4 {
    grid-column: 4 / 8; will damage the design and add extra column but grid-column: span; will not add extra column
     and the element will go to next line
    grid-column: 4 / 8;
    grid-column: span 4;
    grid-column: 4 / 5;
} */

/* 
.grid9 {
    background-color: green !important;
    grid-row-start: 2;
    grid-column-start: 2;
    grid-row-end: 5;
    grid-column-end: 6;
    shorthand of all this 
    grid-area: 2 / 2 / 5 / 6;

    [ grid-column-start:2; grid-column-end:5;] = [ grid-column: 2 / 5; ] = [ grid-column: 2 / span 3; ]  
} */

.grid-parent2 {
    margin: 20px auto;
    height: 500px;
    background-color: #eee;
    display: grid;
    /* minmax stronger than fraction and fraction stronger than auto */
    /* grid-template-columns: minmax(200px, 400px) repeat(2, 1fr); */
    /* grid-template-columns:repeat(7, 1fr); */
    grid-template-columns:repeat(auto-fill, minmax(200px, 1fr));
    /* difference where between 2 last lines in 1st line you told him to give you 7 columns so if you increase the size of webpage by browser it will increase the width of elements but with 2nd line when you increase the size of webpage by Browser it will take more columns in the row because you wrote autofill and not give him exactly how many columns do you need 
    and we wrote minmax because when we increase the size of webpage without minmax() and the availabe width less than 200px it will be blank but with minmax() it will increase the width of elements till extra space reach 200px or more then will add more one column   */
    /* difference between auto-fit and auto-fill 
    auto-fill keep adding columns even if it's empty 
    but auto-fit keep columns only if there is another child need column
    for exp. you have parent and 3 childs and you write grid-template-columns:repeat(auto-fill, minmax(200px, 1fr));
    when you increase the size of webpage it will not add only 3 columns but the more size of webpage you increase the columns will be added
    but when you write grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); 
    it will only 3 columns and if you increase the size of webpage it will stretch childs to fit the new size */
    /* you can use auto-fill and auto-fit instead of media quires to build responsive webpage */
   
}

.grid-parent2 div {
    background-color: blue;
    color: white;
    padding: 20px;
    font-size: 30px;
    font-weight: bold;
    text-align: center;
    box-sizing: border-box;
    margin: 2px ;
    /* height: 100px; */
}

.two-d {
    margin: 200px auto;
    width: 200px;
    height: 200px;
    background-color: rgb(255 0 0 / 39%);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 30px;
    margin-top: 5%;
    margin-left: 5%;
    /* transform :scaleX(2); */
    /* transform:scaleY(2); */
    /* difference between transform and increasing width of height that when you increase width it will only increase width 
    but when you increase by transform it will increase every thing like stretching the webpage it will increase margin and content */
    /* shorthand for both */
    /* transform: scale(2, 2); */
    /* or you can write one value and will be considered for both x and y  */
    /* transform: scale(2); */
    transition: .3s;
    /* negative value will flipp the element  */
    /* transform: scaleX(-1); */
    /* transform: scaleY(-1); */
    /* transform: scaleX(-1); */
    /* deg = degree // rad= radians // grad = gradians   */
    /* 360deg = 6.28rad =400grad = 1 turn */
    transform: rotate(90deg);
    
}

/* differen between [ grid-template-columns or rows ] and [ grid-auto-columns or rows ] 
grid-template define no. and size of columns or rows 
grid-auto define only size of columns or rows
for exp. 9 divs inside container with display:grid; and you write [grid-template-rows: 100px 100px;] and [grid-auto-rows: 30px;]
first 2 rows will be 100px the the rest of rows will be 30px  */



/* 
.two-d:hover {
    transform: scaleX(1);
} */

.img-2d {
    overflow: hidden;
    width: 300px;
    height: 168px;
    
   
}

.img-2d img {
    /* this is the time of transition when you move the cursor away */
    transition: 3s;
    
}

/* to be sure the image scale and rotate inside it's container you should write at container overflow: hidden 
and the rotation looks good inside the container the width and the height of img should be the same like container */
.img-2d img:hover {
    transition: 0.5s;
    /*  the difference between scaling and width that scaling stretch everything box , content , padding and margin everything
     but the browser will not show you the new values of margin , padding or width / width only increase width */
    /* negative value at scale will flip the element */
    transform: scale(1.5) rotate(20deg);
    /* you can't write 2 transfrom with rotate and scale but you can write them at one transfrom at same line as shorthand  */
    /* transform: rotate(20deg); */
    opacity: 0.6;
}

.translate {
    margin: 200px auto;
    width: 200px;
    height: 200px;
    background-color: rgb(255 0 0 / 39%);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 30px;
    margin-top: 5%;
    margin-left: 5%;
    transition: 0.5s;
    /* ((translate)) */
    /* 1st value is X-axis and 2nd value is Y-axis and can be positive or negative values ( will move to opposite direction 
    and if you did not write 2nd value it will be default value 0 // you can also use % if you write 50% 
    it will move 50% of it's width if X-axis or of it's height if Y-axis*/
    /* translate use same concept of left and top in relative position */
    /* translate is better than position because translate give you better performance */
    /* translate is better than position 
    for exp. you want to center child inside container with position you will write top:50% left:50% 
    margin-top:-(half of height) margin-left:-(half of width) but if you change the width or height of child 
    you should change the margins value but with transform:translate(-50%, -50%) you don not have to change anything */
    /* transform: translate(100px , 100px); */
    /* you can use also deg , rad , grad , turn , - or + values  */
    /* 90deg will disapear at SkewY or X and rotateY or X */
    /* transform: skewY(20deg); */
    /* transform: skewX(20deg); */
    /* if you want to use transform:skew on title box for exp. if you use it directly on box it will bend the background and text itself 
    but you can use psudo-element ( background as before psudo ) and skew on it so will bend only the background */
    /* if you did not write 2nd value it will be default value 0 */
    /* transform: skew(20deg); */
    /* matrix (scaleX(), scaleY(), skewX(), skewY(), scaleY(), translateX(), translateY()) */
    /* you can also write all this at same line in transform but you should write name of each function 
    but with matrix you will write only the values */
    /* at skew you should know no. which equilvent to degree to know this search for tan of angle  */
    /* sequnce of matrix => scaleX skewY skewX scaleY translateX translateY */
    /* sequnce of transform : => translateX translateY scaleX skewY skewX scaleY */
    /* transform: matrix(1.2, 0.2679 , 0, 1.2, 20, 20);  2nd value is tan of angle*/
    transform: translateX(20px) translateY(20px) scaleX(1.2) skewY(15deg) skewX(0deg) scaleY(1.2) ;
    /* to give you same output you should write them in this sequence for exp. if you scale before translate the output will be different */

}

.skew {
    position: relative;
    color: white;
    margin: 20px auto;
    width: fit-content;
    padding: 20px;
    
}
.skew::before {
    content: "";
    background-color: red;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    /* if you write transform: skewY(20deg); at .skew not at psudo-element will bend the background and the text also 
    but here will bend the background only becasue it's sperated from text this is psudo-element and .skew is h2  */
    transform: skewY(20deg);
}

/* 
2D transform => tranform-origin(X, Y)
3D transform => transform-origin(X, Y, Z)
Default value of transform-origin: 50% 50% 0 
X-Axis accept values : css Units (px, em, rem) , % , keyword ( left= 0% / center= 50% / right=100%)
Y-Axis accept values : css Units (px, em, rem) , % , keyword ( top= 0% / center= 50% / bottom=100%) */



.main-origin {
    position: relative;
    height: 400px;
   
    
}



.origin {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    /* to center element you have to write these three lines why ?
    left:50% means the element's left edge is shifted by 50% 
    top:50% means the element's top edge is shifted by 50%
    and we use translate (-50%, -50%) because where center the edge of element 
    but we need to center the element istself */
    width: 300PX;
    height: 300PX;
    background-color: #EEE;
   
   

}

.origin .xaxis:before {
    content: "";
    width: 100%;
    height: 2px;
    background-color: black;
    bottom: -20px;
    position: absolute;
    
}
.origin .xaxis:after {
    content: "X-Axis";
    position: absolute;
    bottom: -28px;
    left: 50%;
    transform: translate(-50%);
    background-color: #fff;
    width: 60px;
    text-align: center;
    font-weight: bold;  
}

.origin .yaxis:before {
    content:"" ;
    width: 2px;
    height: 100%;
    background-color:black;
    left: -20px;
    position: absolute;
}
.origin .yaxis:after {
    content: "Y-Axis";
    position: absolute;
    left: -20px;
    top: 50%;
    transform: translate(-50%);
    background-color: #fff;
    height: 60px;
    text-align: center;
    font-weight: bold;
    writing-mode: vertical-lr;
}
.transform2 {
    width: 90%;
    height: 90%;
    background-color: rgb(255 0 0 / 39%);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 30px;
    margin: 5%; 
    /* meaning of transform origin is that you determine which point will the element rotate around */
    /* transform-origin: 50% 50%;  */
    /* same like
    transform-origin: center center;  */
    /*  using left and top concept like position of sticky
        right = 100% of left
        left = 0 
        top = 0 
        bottom = 100%  of top */
    /* transform-origin: right top; */
    /* transform-origin: 100% 0 ; */
    /* transform: rotate(40deg); */


}

.originspan {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: red;
    border-radius: 50%;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}



.main-origin1 {
    position: relative;
    height: 800px;
    /* width: 100%; */
    
}


.origin1 {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 300PX;
    height: 300PX;
    background-color: #EEE;
    /* distance between me and the element in 3D */
    perspective:300px ;
    /* perspective-origin: 100% 100%; */
    /* or perspective-origin: right bottom; */

}


.origin1 .xaxis1:before {
    content: "";
    width: 100%;
    height: 2px;
    background-color: black;
    bottom: -20px;
    position: absolute;
    
}
.origin1 .xaxis1:after {
    content: "X-Axis";
    position: absolute;
    bottom: -28px;
    left: 50%;
    transform: translate(-50%);
    background-color: #fff;
    width: 60px;
    text-align: center;
    font-weight: bold;  
}

.origin1 .yaxis1:before {
    content:"" ;
    width: 2px;
    height: 100%;
    background-color:black;
    left: -20px;
    position: absolute;
}
.origin1 .yaxis1:after {
    content: "Y-Axis";
    position: absolute;
    left: -20px;
    top: 50%;
    transform: translate(-50%);
    background-color: #fff;
    height: 60px;
    text-align: center;
    font-weight: bold;
    writing-mode: vertical-lr;
}
.origin1 .zaxis1:before {
    content:"" ;
    width: 2px;
    height: 100%;
    background-color:black;
    left: -21px;
    top: 17px;
    position: absolute;
    transform-origin: 100% 100% ;
    transform: rotate(225deg);
}
.origin1 .zaxis1:after {
    content: "Z-Axis";
    position: absolute;
    left: -170px;
    top: 119%;
    transform: translate(-50%);
    background-color: #fff;
    height: 60px;
    text-align: center;
    font-weight: bold;
    writing-mode: vertical-lr;
    transform-origin: 100% 100% ;
    transform: rotate(225deg);
}


.transform3 {
    width: 90%;
    height: 90%;
    background-color: rgb(255 0 0 / 39%);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 30px;
    margin: 5%; 
    /* rotate3d(X, Y, Z, 45deg) and 0 means off / 1 means on and accept value of px % also */
    /* transform: rotate3d(1, 1, 1, 45deg); */


    /* to make translateZ work you should add prespective at parent */
    /* transform: translatez(150px); */
    
}


/* .originspan1 {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: red;
    border-radius: 50%;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
} */



.backface {
    margin: 40px auto;
    width: 200px;
    perspective: 300px;
    /* to make it flip with 3d effect   */
}

.backfacebox {
    position: relative;
    width: 200px;
    height: 200px;
    transform-style: preserve-3d;
    /* this value enables the child to preserve their 3D position  */
    /* i think preserve 3D keep flipped element below non flipped element */
    transition: transform 1s;
    /* transform-origin: right center; */
   
   
    
}

.backfacebox:hover{
    /* you have to write two line to successfully flip entire box with 2 elements (transform-style: preserve-3d; in box itself) and (transform: rotateY(180deg);) at one element   */
    transform:rotateY(-180deg)
    /* transform:translate = (-100%) rotateY(-180deg) */
}

/* .backfacebox:hover .front {
    transform: rotateY(180deg);
} */

.backfacebox .face {
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 40px;
    color: white;
    
    
    
    
}

.backfacebox .front {
    background-color: red;
    backface-visibility: hidden;
     
    
}
.backfacebox .back {
    background-color: green;
    transform: rotateY(180deg);  
    backface-visibility: hidden;
    /* when you flip element you will not see it's back ( when it flipped) */
    
}

.anim-parent {
    position: relative;
    height: 300px;
}

.animation {
    width: 100px;
    height: 100px;
    background-color: red;
    position: absolute;
    left: 50%;
    top: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    transform: translate(-50%, -50%);
    animation-name: change-color;
    /* you should write duration because it's default value 0 / if you did not write duration animation will not work */
    animation-duration: 6s;
}

@keyframes change-color {
    /* from {
        background-color: red;
    }
    to {
        background-color: blue;
    } */
    /* you can use instead of (from to) to ( 0% 100%) */
    0% {
        background-color: red;
    }
    50% {
        background-color: blue;
    }
    100% {
        background-color: red;
    }

    /* animation-duration will be divided to each step by % if for example 0% 90% 100% and duration is 10s 
    then 1st step from 0% to 90% will take 9s and 2nd step from 90% to 100% will take only 1 sec */
}

.spinn-parent {
    position: relative;
    height: 300px;
}

.spinner {
    width: 100px;
    height: 100px;
    background-color: #eee;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
    animation-name: spin;
    animation-duration: 3s;
    border-radius: 50%;
    border: 5px solid #e91E63;
    transform: rotate(1turn);
    border-left-color:transparent ;
    animation-iteration-count: infinite;
    /* like True Loop */
    animation-timing-function: linear;
    /* ease will stop little bit every round but linear will continue without any stops */
    /* animation-direction: normal; is the default */
    /* animation-direction: reverse; */
    /* alternate means turn and turn back see the webpage to understand */
    animation-direction: alternate;
    /* animation-direction: alternate-reverse; */

    
}

@keyframes spin {
   
    0% {
        transform: rotate(0deg);
    }
 
    100% {
        transform: rotate(360deg);
    }

   
}
.color-parent {
    position: relative;
    height: 300px;
}

.coloring {
    width: 100px;
    height: 100px;
    background-color: #eee;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
    animation-name: coloring;
    animation-duration: 3s;
    border-radius: 50%;
    /* animation-iteration-count: infinite; */
    /* animation-timing-function: linear; */
    /* animation-direction: normal; */
    /* animation-delay: 2s ; */
    /* negative value means if duration is 5sec so it will skip 2 sec of duration */
    /* -o-animation-delay: -2s;  */
    /* animation-fill-mode: forwards; */
    /* forwards means it will take the style of last keyframes so here after animation finish it will take black color  */
    /* animation-fill-mode: backwards; */
    /* forwards means it will take the style of first keyframes before the animation start so here before animation start it will take red color  */
    /* animation-fill-mode: both; */
    /* it will take style of 1st or last keyframes according to animation direction */
    /* animation-direction: reverse; */
    /* animation-play-state: running; is thw default value */
    /* animation-play-state: running; */
    /* ((shorthand for Animation)) */
    /* name of animation duration delay animation-iteration-count animation-direction */
    animation: coloring 3s linear 2s infinite reverse;
    
}

.coloring:hover {
    animation-play-state: paused;

}
@keyframes coloring {
   
    0% {
        background-color: red;
    }
    50% {
        background-color: blue;
    }
 
    100% {
        background-color: black;
    }

   
}



.load {
    display: flex;
    justify-content: center;
    /* position: relative; */
    background-color: #eee;
    width: 400px;
    height: 400px;
    
}

.load div { 
    width: 20px;
    height: 20px;
    background-color: blue;
    border-radius: 50%;
    /* margin: 0 5px; */
    animation-name: up-and-down;
    animation-duration: .5s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
    /* position: absolute; */
    /* top:50%;
    transform: translate(-50%, -50%); */
    margin-left: 2px;
    margin-top: 200px;
   

}

.two-load {
    animation-delay: 0.3s;
}
.three-load {
    animation-delay: 0.6s;
}
/* i used to test only absolute position */

/* .one-load {
    right: 50%;
    
}
.two-load {
    right: calc(50% - 22px);
}
.three-load {
    right: calc(50% - 44px);
} */

@keyframes up-and-down {
   
    to {
        opacity: 0.1;
        transform: translateY(-20px);
    }
/* if you will write a default value in from you can remove from and write only to  */
}

/* CSS Selectors
* to target all elements
you can target tags but will target all elements that have same tag 
you can target child element inside parent ( div p )it will target p even it's grandson not only child
you can target element by .class-name
you can target element by #id-name (ID can be applied for only one element but class can be added to more than one element)
you can target child inside parent by .class-parent .class-child
you can target element have 2 classes like this ( class="class1 class2) by .class1.class2
you can grouping by .class-name div, .class-name p 
you can target only one element(p) if there are many elements have same class by p.class-name

the difference between targeting DIRECT CHILD and child 
.class-name > child 
it will only target the child not grandson
.class-name child 
it will target child and grandsons also

( div + p ) means will target only the first p which is directly after div 
( p ~ span ) means will targent all span (not only the first span) which is directly after p
.parent > * + * will select all childs except first one (info from youtube)

you can target element by it's attribute name by [title]
you can target element by it's attribute name and tag div[ title]
you can target element by it's attribute with value name by [ title=value]
you can target element by it's attribute name with value and tag div[ title=value]
you can target element by a word inside value of it's attribute by [ title ~= word ]
you can target element by string inside value of it's attribute by [ title *= word ] here word can be part of the value of attribute
you can target element by string at start of value of it's attribute by [ title ^= word ] 

:first-child like (div:first-child) means target fisrt div element inside any parent 
:last-child like (div:last-child) means target last div element inside any parent
:first-of-type (div:first-of-type) means target first div element ( inside a parent or not )even if it's 2nd or 3rd element
:last-of-type (div:first-of-type) means target last div element 
:only-child (div:only-child) means target div element but should be alone inside it's parent
:only-of-type (div:only-of-type) means target div element if he only the div element inside it's parent he can have brothers but should different tags
div:not(selector) will target all div elements except the one with this selector like div:not(:first-child)
div:nth:child(n) will target the 2nd div child if you write div:nth:child(2)
div:nth:child(n) will target the even div child if you write div:nth:child(even) or odd
div:nth:last-child(n) will count from last 
div:nth:of-type(n)  
div:nth:last-of-type(n)  div:nth:last-of-type(1) means last one / div:nth:last-of-type(2) will count from last

:nth-child(odd) [ 1, 3, 5 , .... ] = nth:nth-child(2n + 1) [ 2x0 + 1 = 1 / 2x1 + 1 = 3 / 2x2 + 1 = 5 / .... ] 
:nth-child(3n) [ 3x1 = 3 / 3x2 = 6 / 3x3 = 9 / ...... ] will add 3 every time
:nth-child(n+7) [0 + 7 = 7 / 1 + 7 = 8 / 2 + 7 = 9 / .... ]  will select the 7th element then all remaining elements after 7th element 
:nth-child(-n + 3) [ -0 + 3 = 3 / -1 + 3 = 2 / -2 + 3 = 1 ] will select first three elements
:nth-child(n+8):nth-child(-n+15) will select range from 8th to 15th  
when (+) start count from (0) but when (x) start count from (1)          

input[type="checkbox"]:checked + label means will target the label only when checked in input with attribute type and value checkbox
div:empty means will target div element only if it's empty
input:disabled will target disabled word ( HTML CODE => input type="text" disabled value="disabled" )
input:requird + span will traget span after input ( HTML CODE => input type="text" placeholder="please input here" required)
input:focus{ boder: 2px solid red; ) when you focus on input will add border with red color
div::selection { background-color: black; color: white; ) when you select this div the selection color will change
input::placeholder { color: red; } means the placeholder color will change to red

*/

/* input::placeholder {
    color:crimson
} */

/* input:focus{ 
    border: 5px solid red; 
} */

/* div::selection {
    background-color: black;
    color: white;
} */

.queries {
    display: flex;
    width: 1200px;
    justify-content: space-between;
    flex-wrap: wrap;
    margin: 20px auto;
}

.queries > div {
    background-color: red;
    color: white;
    text-align: center;
    font-size: 20px;
    width: 290px;
    
}

@media print {
    .queries > div {
        font-size: 100px;
    }

    .queries > div:first-child {
        display: none;
    }
}

/* that's means that it will work only in range 0 to 1000px / you can use also min-width*/

@media (max-width: 1000px) {
     
     .queries > div {
         background-color: blue;
     }

}

@media (min-width: 1000px) and (max-width: 1400px) {
     
     .queries > div {
         background-color: green;
     }

}

/* you can also create a new CSS file for exp. print.css and write this line in HTML file
<link rel="stylesheet" href="css/print.css" media="print"> you can also use any condition like media="(min-width: 1000px) and (max-width: 1400px)" 
and at CSS file you do not need now to use @media  */

/* or you can use Style tag in HTML file
<style media="print">
.queries > div {
    background-color: blue;
}
</style> */


/* Mobile */
@media (max-width: 767px) {
    
}
/* Small Screens */
@media (min-width: 768px) {

}
/* if the style is same we do not write max-width at previous media because once width reach 992px next media will override previous media */
/* but if the style different then the previous style will continue to infinity width so you need now to write max-width */

/* Medium Screens */
@media (min-width: 992px) {

}
/* Large Screens */
@media (min-width: 1200px) {

}

/* Custom */
/* here you can write style for all media before  */
@media (max-width: 1199px) {

}

.framework {
    position: relative;
    background-color: #eee;
    margin: 20px auto;
    width: 900px;
    height: 200px;
}

.product-parent {
    position: relative;
    margin-top: 100px;
    height: 200px;
}
.framework-product {

    background-color: red;
    color: white;
    
   
}

.framework-child {
    background-color: green;
    color: white;
   
}

/* here we create framework for us and you will write this class at element in HTML file */
.center-position {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.circle {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    text-align: center;
   
}

/* to center text inside Circle */
.text-center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.global-value {
    color: red;
    font-size: 40px;
    font-weight: bold;
    background-color: #eee;
    padding: 20px ;
    margin: 5px;
    border: 2px solid black;
    /* initial means restore all CSS properites to their initial state for exp. all elements is inline 
    but user agent stylesheet give div block level and span inline level // another exp. initial color of elements is black
    so when you write color:initial; will give you black color ( maybe the initial color differ from one browser to another */
    /* display: initial; */
    
    
    
}

.global-button {
    /* unset used as inherit if this properity can be inherited if not it will act as initial */
    /* color:unset; now means it will search if he can inherit from parent or not 
    if he can inherit so he will take the color of it's parent 
    if he can not inherit so the color will return to it's initial color */
    color: unset;
    /* we can not use unset with border because border is not a inherit property by default */
    border: unset;
    /* all:unset; means it will inherit all inherit properites (like color not border ) 
    and the non-inherit properites will return to it's initial state */
    all:unset;
    /* difference between revert and initial that initial restore all CSS properites to their initial state
    but revert restore all CSS properites to user agent stylesheet for exp if you write 
    * { box-sizing: border-box;
        margin:0; 
    }
    so all elements will be 0 margin but with margin: revert it will restore 8px which is given 
    by user agent stylesheet*/
    margin: revert;
}


/* to center text inside div */
/* you have 6 ways ti do it 
1. using vertical-align in table cell and parent display table
2.using position absolute inside parent div and left:50%; top:50%; transform:translate (-50%, -50%)
3.using flex without span inside div directly using justify-content:center; align-items:center;
4.using padding only with display:inline-block because block will take full width 
5.using display:grid; and place-items:center; 
6.using text-align:center; and line-height:px; ( same height of parent) but line-height is not accurate */

/* to center div inside div
1.using flex justify-content:center; align-items:center; 
2.using grid place-items:center; 
3.using display:table-cell; vertical-align:middle; text-align:center; and child display:inline-block; 
4.parent position:relatvie; child position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; */

.center-text {
    background-color: green;
    color: white;
    height: 100px;
    width: 100px;
    display: table;
    text-align: center;
}

.cent { 
    vertical-align: middle;
    display: table-cell;
}

/* to add icons you can add it at HTML file with dec code like this &#129409; or HEX code like this &#x1F981;  
or you can add it by using psudo-element and content:"\00AE*/

/* to maintain aspect ratio of img
width:100% 
height:auto; 
*/

/* 
height:100% means 100% of it's container
height:auto; means height of it's childs */

/* position absolute will move related to it's parent ( position : relative )
if you write right:0; top:0; so will move to corner top right because this means 
he will move till the right side has zero pixel on right and top side has zero pixel from the top
and if you write right:20px; will push the element to left side and vice verse */

/* position fixed like absolute but related to layout not to it's parent */

/* position relative will move related to it self not to it's parent
that's why when you write right:0; it will not move to right side like absolute because it 
move related to it self and right:0; means right side has zero pixel to it's related container 
but it related to it self so always it's zero pixel from right side */

/* position sticky will move related to the layout but also can't go outside it's parent
that's why right:; and bottom:; not working because you cant push the sticky element
 outside it's parent if you want to move it use left and top this at english version of website 
 at arabic version directions will be inverted 
 to move it you can use px or % but be ware that px or % will calculated from the layout not it's parent*/

/* default value of flex-grow is 0 which means no grow but 1 means all items will grow like each other to fill the remaining space 
    and if you want to grow one element more than others you can add flex-grow to this item for example flex-grow: 3 means will grow 
    by ration 3:1 but if there is availabe space  if you do not have extra space all items will grow 1:1 because we wrote  flex-grow: 1;
    in .flex2 div but if there is extra space by reducing width of each element the element with flex-grow:3 will grow till reach 
    ratio 3:1 */
    /* if you still grow the elements to infinity all elements will grow like each others and will be same size */

***************************************** JS  *****************************************

// single line comment

/* multi 
line 
comment */

// Script tag should be written at the bottom of HTML File 
// if you want to write scipt tag at the Head you show add 
// document.addEventListener("DomContentLoaded", function)

/* ----------------------------Data Type in JavaScript-------------------------------

[1] Primitive Value  ( passed by value)
  Boolean, null, undefined, String, Number, bigint, symbol

[2] Object ( passed by Reference)
  Object , Array , Function , ....
*/

// console.log(typeof "mohamed") // string
// console.log(typeof 5000) // number
// console.log(typeof 5000.99) // number
// console.log(typeof [10, 15, 17]) // object
// console.log(typeof ["Mo", "ha", "med"]) // Object
// console.log(typeof {name:"osama", Age:17, country:"Egypt"}) // object
// console.log(typeof true) // boolean
// console.log(typeof false) // boolean
// console.log(typeof undefined) //undefined
// console.log(typeof null) // object
// console.log(typeof 1n)//bigint

// * BigInt
/* 
The BigInt type is a numeric primitive in JavaScript that can represent integers 
with arbitrary precision. With BigInts, you can safely store and operate on large integers 
even beyond the safe integer limit for Numbers.

// BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); 
console.log(x)//9007199254740991n
console.log(typeof 1n)//bigint
console.log(1n == 1)//true
console.log(1n === 1)//false
console.log(x + 1n)//9007199254740992n
console.log(x + 2n)//9007199254740993n
console.log(x + 1n === x + 2n) // false

// Number
console.log(Number.MAX_SAFE_INTEGER + 1) //9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 2) //9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2) // true
*/

// -----------------------------console is Web API------------------------

/* API stands for Application Programming Interface. API is actually some kind of interface which is having a set of functions.
These set of functions will allow programmers to acquire some specific features or the data of an application.*/

/* 
console.log("hello to console");
console.error("404");
console.table(["osama", "ahmed", "mohamed"]);
%c called directive write it before what you want to style
/*console.log(
  "Hello from %cjs %cfile",
  "color:red; font-size:40px;",
  "color:blue; font-size:40px;"
);

you can add single quote inside double quot or vice versa but you can't add double inside double or single inside single
console.log('Elzero web "school"');
if you want to ignore that you can add \ ( Charachter Escape Sequences)
console.log("Elzero Web \"School\"");
console.log("\\");
if you want to line continue  you can add \
console.log("Elzero \
web \
School")
// if you want new line  you can add \n
// console.log("Elzero \n Web \n School" )

\n => new line
\t => horizontal tab
\v => vertical tab
\r => carriage return (like \n in old Mac)
*/

//--------------------------------variable-------------------------------------
// = called assignment operator
// == equality operator (check only the value) // 100 = "100" // true
// === strict equality (check value and data type) // 100 = "100" // false 
// you can't start varibale name with no. or special characters

// when you create Element in HTML files and give it an ID this ID is considered as Variable in JS
/* window.onload = function () {
  console.log(hello)
} */
// console.log(hello)
// to change content of html
// hello.innerHTML = "option"

/*  
var 
-- Redeclare (Yes)
-- Access Before Declare (undefined)
-- Variable Scope Drama [Added To Window object] (Yes)
-- Block or function Scope (not block Scope) ( Yes Function Scope)

Let 
-- Redeclare (No)
-- Access Before Declare (Error)
-- Variable Scope Drama [Added To Window object] (No)
-- Block or function Scope (Yes)

Const 
-- Redeclare (No)
-- Access Before Declare (Error)
-- Variable Scope Drama [ Added To Window object] (No)
-- Block or function Scope (Yes)

*/

// Redeclare with var will override and give you last value but let and const will give you Error
/* const a = 1;
const a = 2;
console.log(a) */

// Access Before Declare with variable will give you undefined but with let and Const will give Error ( cannot access 'a' before intialization)
/* console.log(a)
let a = 2; */

// variable Scope Drama meaning of added to window object (variable will be added as properity to window object)
// var a = 30;
// console.log(window.a)


// difference between let and const that with const you can not assign a new value for variable
// let x = 10; x= 100; //ok 
// const x =10; x = 100; // Error

/*
Function Scope: When a variable is declared inside a function,
it is only accessible within that function and cannot be used outside that function.

Block Scope: A variable when declared inside 
the if or switch conditions or inside for or while loops,
are accessible within that particular condition or loop.
To be consise the variables declared inside the curly braces are called as within block scope.
*/

// redeclaring var will not lose it's value because of hoisting
// var x ; 
// x = 10;
// var x ;
// console.log(x)
// beacuse of hoisting will be like this 
// var x ; 
// var x ;
// x = 10;
// console.log(x)

// Hint difference between declaring variable inside loop with let and var

// declaring variable here with var without value every cycle will not change it's value to undefined like let
// for (let i = 0; i < 3; i++){
//     var index;
//     console.log(index)
//     index = 5;
//     console.log(index)
// }

// here we cant use let because every cycle let index declare new variable each loop because it's block scope
// for (let i = 0; i < 3; i++){
//     let index;
//     console.log(index)
//     index = 5;
//     console.log(index)
// }

// you can create you own global object ( myGlobals = {} | myGlobals.variableName = 10;)


// -------------------------------document.write / console.log /  Template Literals----------------

// let a = "We Love"
// let b = "JavaScript"
// documet to write at HTML file but console to write at console
// for new line we should add <br/> not \n because we are writing in HTML file
// document.write(a + " " + b + "<br/>");
// document.write(a + " " + b );
// when you use console it will add space automatically but document not
// console.log(a,b);

/* let a = "We Love";
let b = "JavaScript";
let c = "And";
let d = "Programming"; */

// console.log(a + " " + b + "\n" + c + " " + d )
// console.log( a , b + "\n" + c , d )

// this from ES6 `` called Template Literals
// here no need for Escpaing you can write "" or '' but \ you should write \\
/* console.log(`${a} ${b} ${c} ${d}`)
console.log(`\\${a} '${b}\n${c} "${d}`)
console.log(`${a} ${ 100 + 5}
${c} ${d}`) */

// This is ES6 if you want to change it to legacy code visit : https://babeljs.io/
/* let Title = "Elzero";
let Para = "Elzero Web School";

let Template = `
<div class="card">
  <div class="child">
    <h2>${Title}</h2>
    <p>${Para}</p>
  </div>
</div>
`
document.write(Template) */

// ---------------------------loosely typed vs strongly typed language-----------------
/* loosely typed when you don’t have to explicitly specify types of variables and objects.
A strongly typed language on the contrary wants types specified. */

// JavaScript is loosely type that means you dont have to say this is int or this is num 
// for example python will give you Error you can not concatenate int to string but JS no you can
// let x = 20;
// let z = x + "dot"
// console.log(z)

// ------Challenge---------

/* let title_zero = "Elzero" , description_zero = "Elzero Web School" , date_zero = "30/01" 
let html = `
<div class="parent"> 
  <h3>${title_zero}</h3>
  <p>${description_zero}</p>
  <span>${date_zero}</span>
</div>
` */
// let four = html.repeat(4)

// document.write(`${html.repeat(4)}`)
// document.write(html.repeat(4))

// ------End Challenge---------

// -----------------------------number--------------------------------
// console.log(10 + 20);
// console.log(10 - 20);
// console.log(10 - "osama");
// console.log(typeof NaN); //number
// console.log(10 * 20);
// console.log(10 / 20);
// console.log(10 / 3);
// // % called Modulus 
// console.log(10 % 3);
// console.log(2 ** 4);

// // NaN !== NaN
// console.log(isNaN(2)) //false
// console.log(isNaN("Soliman")) //true
// console.log(isNaN("2")) // false
// console.log(NaN === NaN) //false

// var num = 1;
// pre increment ++num (in console and in browser will add 1 then will print variable)
// Post increment num++ ( in console and in browser will print variable then add 1)
// pre decrement --num (in console and in browser will remove 1 then will print vaiable)
// Post decrement num-- ( in console and in browser will print variable then remove 1)

// unary plus ( return Number if it's not number)
// console.log(+100)
// console.log(+"100")
// console.log(9.9999)
// console.log(+0xff)
// console.log(+null)
// console.log(+false)
// console.log(+true)
// console.log(+"Osama") //NaN

// unary Negation
// console.log(-100)
// console.log(-"100")
// console.log(-"-100")
// console.log(-9.9999)
// console.log(-0xff)
// console.log(-null)
// console.log(-false)
// console.log(-true)
// console.log(-"Osama") // NaN

/* console.log(Number("100"))
a = "100"
a = Number ("100")
console.log(typeof a) */

// --------------Type coercion (implicit ) vs  Type conversion ( explicit)----------

// [1]  -----------Type coercion (implicit )

// [a] + operator
/* 
Js Engine has two options convert 1 to "1" or "2" to 2 
because with + you can concatenate strings or numbers 
but under the hood Js will automatically convert 1 to "1" using toString() Method
*/
// console.log( 1 + "2") // 12
// under the Hood
// console.log((1).toString() + "2") // 12

// [b] * operator
/* 
Js Engine has only one option convert "2" to 2 
because with * you can only multiply numbers not string
but under the Hood Js will automatically convert "2" to 2 using Number() ( ia m not sure which method will be used)
*/
// console.log( 1 * "2") //2
// // under the Hood
// console.log( 1 * Number(2)) //2 

// [2] -------Type conversion ( explicit) 
/* 
Explicit means change data type by yourself not automatically by JS Engine
*/
// console.log(Number("2"))
// console.log(String(1))

//**exp. of Type coercion

// let a = "10";
// let b = 20;
// let c = true;
// let d = "osama";
// console.log(a + b);
// console.log(a - b);
// // Type casting (Type coercion) (a + b) will give 1020  + here has two meanings concatinate or plus
// // and a is string , b is number so will give you 1020
// // but - has only one meaning minus so will consider "10" as number
// console.log(+a + b);
// console.log(Number(a) + b);
// console.log(d - b);
// console.log(+"") // 0
// console.log("" - 2)
// console.log(true - 2)
// console.log(false - 2)
// console.log(false - true)
// // here Type coercion convert true to string because we added a + b and a is string
// console.log( a + b + c) //1020true
// console.log( +a + b + c)  31
// // here Type coercion convert true to number
// console.log( b + c) // 21
// console.log( a + c) // 10true
// console.log(true)
// true will change to no. if all number and will change to string if one of varaibles is string

// let a = 10;
// a = a + 20;
// a = a + 70;
// // a += 100; means a = a + 100;
// a += 100;
// a -= 50;
// a /= 60;
// console.log(a);

// ------Challenge---------

// let a = 10;
// let b = "20";
// let c = 80;
// console.log(++a + +b++ + +c++ - +a++);
// console.log(++a + -b + +c++ - -a++ + +a);
// console.log(--c + +b + --a * +b++ - +b * a + --a - +true);

// let d = "-100"
// let e = "20"
// let f = 30;
// let g = true;
// console.log(-d * +e); //2000
// console.log(++e * ++g + ++f + -d ); //173

// ------End Challenge---------

// ---------------------------------Number Methods-----------------------
// console.log(1000000);
// console.log(1_000_000); //Js ignore _ between number ( this called syntactic sugar)
// console.log(1e6); // e = number of zeros
// console.log(10 ** 6);
// console.log(1000000.0);
// console.log(Number.MAX_SAFE_INTEGER)
// console.log(Number.MIN_SAFE_INTEGER)
// console.log(Number.MAX_VALUE)
// console.log(Number.MIN_VALUE)

// console.log(100);
// console.log((100).toString());
// console.log(100.4.toString());
// console.log(100.4.toFixed());
// console.log(100.5.toFixed());
// console.log(100.555555555.toFixed(3));
// console.log(+("100 osama"));
// console.log(Number("100 Osama"));
// console.log(parseInt("100 Osama")); //return 100
// console.log(parseInt("Osama 100 Osama"));//retrun NaN
// but the number should be at the beginning
// console.log(parseInt("100 Osama Osama "));//100
// // + , Number , parseInt all of them will return number but parseInt will return number even
// // if it's number and word parseInt will return only the number but + and Number will return NaN
// console.log(parseInt("100.5 Osama"));
// parseInt(string , base)
// console.log(parseInt("123456", 10)) // decimal
// console.log(parseInt("123456", 2)) // binary 
// console.log(parseInt("123456", 16)) // hexadecimal
// console.log(parseFloat("100.5 Osama"));
// console.log(Number.isInteger("100"));
// console.log(Number.isInteger(100.5));
// console.log(Number.isInteger(100));
// console.log(Number.isNaN("osama" / 2));
// console.log(Number.isNaN(100));
// console.log(isNaN(100));

// **difference between Number.isNaN() and isNaN()
// Global isNaN() function first converts the argument to a number, and then returns true if the resulting value is NaN;
// Number.isNaN() returns true if and only if the argument is of type Number and the value equals to NaN.
// console.log(Number.isNaN("osama")); // false
// console.log(isNaN("osama")); // true

// console.log(Math.round(99.4)); //99
// console.log(Math.round(99.5)); //100
// console.log(Math.ceil(99));
// console.log(Math.ceil(99.2)); //100
// console.log(Math.floor(99.9)); //99
// console.log(Math.min(10, 20, 100, -100, 90));
// console.log(Math.max(10, 20, 100, -100, 90));
// console.log(Math.pow(2,4)) // like console.log(2**4)
// console.log(2**4)
// console.log(Math.random())
// console.log(Math.trunc(99.5)) //99
// // difference between trunc and floor that trunc will remove 0.5 only but floor will a smaller no.
// console.log(Math.trunc(99.5))
// console.log(Math.floor(99.5))
// console.log(Math.trunc(-99.5)) // return -99
// console.log(Math.floor(-99.5)) // return -100
// difference between ceil and round that ceil will return biggest no. only but round will return no. no matter - or +.
// console.log(Math.ceil(99.4))
// console.log(Math.round(99.4))
// console.log(Math.ceil(-99.6)) // return -99
// console.log(Math.round(-99.6)) // return -100

// Math.random() give you number from 0 to < 1
// to give it a range you have two options:

// 1st Option range from 0 to max 
// function randomMax(max) {
//   return Math.floor(Math.random() * max)
// }
// console.log(randomMax(5))

// 2nd Option from min to max 
// function randomMinMax(min,max) {
//   return Math.floor(Math.random() * (max - min) + min)
// }
// console.log(randomMinMax(5,10))

// ------Challenge---------

// let a = 1_00;
// let b = 2_00.5;
// let c = 1e2;
// let d = 2.4;

// console.log(Number.parseInt(Math.min(a, b, c, d)));
// console.log(Math.round(Math.min(a, b, c, d)));

// console.log(a ** Math.round(d));

// console.log(Math.round(d));
// console.log(Math.floor(d));
// console.log(Math.trunc(d));
// console.log(Number.parseInt(d));

// // toFixed return string because it's from toString family
// console.log((Math.floor(b) / Math.ceil(d)).toFixed(2)); //66.67 string
// console.log(Number((Math.floor(b) / Math.ceil(d)).toFixed(2))); //66.67 number
// console.log(Math.round(Math.floor(b) / Math.ceil(d))); //67 number

// Math.abs return absolute value of a number
// console.log(Math.abs(-5)) // output 5

// ------End Challenge---------

// -------------------------------string-------------------------

// let theName = "  Ahmed  ";
// console.log(theName);
// console.log(theName[2]);
// console.log(theName.charAt(2));
// console.log(theName.trim());
// console.log(theName.length);
// console.log(theName.toUpperCase());
// console.log(theName.toLowerCase());
// console.log(theName.trim().charAt(2).toUpperCase());

// let a = "Elzero Web School";
// let b = "Elzero|Web|School";
// // indexOf (Value, Start[] 0)
// console.log(a.indexOf("Web")); //if not found return -1
// console.log(a.indexOf("Web", 8)); //return -1
// console.log(a.lastIndexOf("Web"));
// console.log(a.indexOf("o"));
// // lastIndexOf (Value, Start) default of start is ( length -1 )and dont accept negative value  
// console.log(a.lastIndexOf("o"));
// console.log(a.lastIndexOf("o", 15));
// // Start , End ( not including the End)
// console.log(a.slice(0, 6));
// console.log(a.slice(2, 6));
// - value count from -1 not 0
// console.log(a.slice(-5));
// console.log(a.slice(-5, -3));
// console.log(a.repeat(5));
// // first value is separetor and 2nd value is limit ( no. of split) and return Array
// console.log(a.split(" "));
// console.log(b.split("|" , 2));

// let a = "Elzero Web School";
// // difference between substring and slice 
// // substring does not accept negative value
// // slice if start > end will return empty string but substring will swap start and End
// // start , End
// console.log(a.substring(2));
// console.log(a.substring(2, 6));
// console.log(a.slice(6, 2)); // Empty String
// console.log(a.substring(6, 2)); //same output
// console.log(a.substring(-10)); //here doesn't accept - value and will consider it 0
// console.log(a.substring(16));
// console.log(a.substring(a.length - 5, a.length - 3));
// // difference between substr and substring
// // substring have Start and End
// // substr have start and the count not end
// // substr accept negative value
// console.log(a.substr(-3));
// console.log(a.substring(-3)); // does not accept negative value and consider it 0
// console.log(a.substr(-5, 2));
// // difference between indexOf and includes
// // indexOf will return value of index ("web") if not found return -1
// // includes will return true or false ( found or not found)
// // both you can add End Value
// console.log(a.includes("Web"));
// console.log(a.includes("Web",8));

// console.log(a.startsWith("E"));
// // 2nd value is start
// console.log(a.startsWith("E", 2));
// console.log(a.startsWith("z", 2));
// console.log(a.endsWith("o"));
// // 2nd value is length
// console.log(a.endsWith("o", 6));

// ------Challenge---------

// let a = "Elzero Web School"

// console.log(a.charAt(2).toUpperCase() + a.slice(3,6));
// console.log(a.charAt(13).toUpperCase().repeat(8));
// console.log(a.split(" ", 1));
// console.log(a.substr(0, 6) + a.substr(10));
// console.log(a.charAt(0).toLowerCase() + a.slice(1, -1).toUpperCase() + a.slice(-1).toLowerCase())

// ------End Challenge---------

// -----------------------------------Operators------------------------------------------

// = assignment operator
// == Equal operator
// === Identical (Strict)
// !== Not Identical
// > larger than
// >= larger than or equal
// < smaller than
// <= smaller than or equal
// ! not
// && and
// || or


// console.log(10 == "10"); // compare value not compare type of data
// console.log(10 != "10"); // compare value not compare type of data
// console.log(10 === "10"); // compare value and type
// console.log(10 !== "10"); // compare value and type
// console.log(10 > 10);
// console.log(10 >= 10);
// console.log(10 < 10);
// console.log(10 <= 10);

// console.log(typeof"Osama" === typeof"Ahmed");

// console.log(!true);
// console.log(!(10 == "10"));
// console.log(10 == "10" && 10 > 8 && 10 >= 10);
// console.log(10 == "10" || 10 > 50 || 10 >= 10);

// let price = 100;
// let discount = true;
// let discount = false;
// let discountAmout = 30;
// let country = "Egypt";
// // let country = "Syria";
// // let country = "USA"
// let student = true;

// console.log(price);

/* if (condition) {
  block of code
} */

// if (discount === true) {
//   // price = price - 30;
//   price -= discountAmout;
// } else if (country === "Egypt") {
//   if (student === true) {
//     price -= discountAmout + 30;
//   } else {
//     price -= discountAmout + 10;
//   }
// } else if (country === "Syria") {
//   price -= discountAmout + 20;
// } else if (country === "KSA") {
//   price -= discountAmout + 30;
// } else {
//   price -= discountAmout - 20;
// }

// console.log(price);

// let theName = "Mona";
// let theGender = "Female";
// let theAge = 30;

// if (theGender === "Male") {
//   console.log("Mr");
// } else {
//   console.log("Mrs");
// }

// ------------------------------Ternary Condition Operator----------------------------
// //  condition ? if true : if false

// theGender === "Male" ? console.log("Mr") : console.log("Mrs");

// let result = theGender === "Male" ? "Mr" : "Mrs";
// console.log(result)

// document.write(result);
// console.log(theGender === "Male" ? "Mr" : "Mrs");
// console.log(`Hello ${theGender === "Male" ? "Mr" : "Mrs"} ${theName}`);
// console.log(`Hello ${result} ${theName}`);

// theAge < 20
//   ? console.log(20)
//   : theAge > 20 && theAge < 60
//   ? console.log(" 20 to 60")
//   : theAge > 60
//   ? console.log("larger than 60")
//   : console.log("unknown");

// let price = 0;
//----------------------------logical or || and Nullish Coalescing Operator ??-------------------------------

// //  will return value after || if value ( undefined or null or empty string "" or false or falsy value like 0)
// console.log(`The Price IS ${price || 200}`);

// //  will return value after ?? if value ( undefined or null )but not (false or falsy value like 0)
// console.log(`The Price IS ${price ?? 200}`);

// // Falsy Values
// console.log(Boolean(0))
// console.log(Boolean(""))
// console.log(Boolean(false))
// console.log(Boolean(null))
// console.log(Boolean(-0))
// console.log(Boolean(NaN))
// console.log(Boolean(undefined))
// console.log(Boolean(0n))

// with && falsy value will return and ignore anything after it but true value will return after &&
// console.log( false && "dog") // false
// console.log("dog" &&  false) // false
// console.log( true && "dog") // dog
// console.log("dog" &&  true  )  // true
// console.log( 0 && "dog") // 0
// console.log( 1 && "dog") // dog

// let a = 10;

// if (a < 10) {
//   console.log(10);
// } else if (a >= 10 && a <= 40) {
//   console.log("10 To 40");
// } else if (a > 40) {
//   console.log("> 40");
// } else {
//   console.log("unknown");
// }

// ------Challenge---------

// let st = "Elzero Web School";

// if (`${st.length + st.length}` === "34") {
//   console.log("Good");
// }

// if ((st.length + st.length).toString() === "34") {
//   console.log("Good");
// }

// if (st.charAt(st.indexOf("W")).toLowerCase() === "w") {
//   console.log("Good");
// }

// if (typeof st.length !== "string") {
//   console.log("Good")
// }

// if (typeof st.length === "number") {
//   console.log("Good");
// }

// if ( st.slice(0, 6) + st.slice(0, 6)  === "ElzeroElzero") {
//   console.log("Good");
// }
// if ( st.slice(0, 6).repeat(2)  === "ElzeroElzero") {
//   console.log("Good");
// }

// ------End Challenge---------

// ------------------------------if conditions and switch--------------------------

// let day = 2;

// // variable and case should be same type and same value (compare by identical operator === )

// switch (day) {
//   // default:
//   //   console.log("Unknown Day")
//   //   break
//   case 0:
//     console.log("Saturday")
//     break;
//   case 1:
//     console.log("Sunday")
//     break;
//   case 2:
//   case 3:
//     console.log("Monday")
//     break;
//   default:
//     console.log("Unknown Day")
// }

// in switch case you can not use logical or || just write two cases like case 2: case 3:
// in switch you can't combine between two condition like (typeof num = "number" && Number.isInteger(num)) 
// in switch you can use two variable like ( switch (var1 && var2) or | or many other characters but , will not work ) 
// if you want to put default at begining you should write break inside if you didn't it will give the next value no matter if it match case or not

// switch (true) (from assignments)

// function calculate(firstNum, secondNum, operation) {
//   switch(true) {
//       case firstNum === undefined:
//           console.log("First Number Not Found")
//           break
//       case secondNum === undefined:
//           console.log("Second Number Not Found")
//           break
//       case operation === undefined:
//           console.log("operation Not Found")
//           break
//       case operation === "add" :
//           console.log(firstNum + secondNum)
//           break
//       case operation === "subtract":
//           console.log(firstNum - secondNum)
//           break
//       case operation === "multiply":
//           console.log(firstNum * secondNum)
//           break
//   }
// }
// calculate(20)
// calculate(20,10)
// calculate(undefined,10)
// calculate(20,10,"add")
// calculate(20,10,"subtract")
// calculate(undefined,10,"subtract")
// calculate(20,10,"multiply")

// default like else in if condition (From Assignments )

// function ageInTime(age){
//   switch(true) {
//       case age > 110:
//       case age < 10:
//           console.log("Age Out Of The Range")
//           break
//       default:
//           console.log(`Months => ${age * 12}
// Days => ${age * 12 * 30}
// Hours => ${age * 12 * 30 * 24}
// Minutes => ${age * 12 * 30 * 24 * 60}
// Seconds => ${age * 12 * 30 * 24 * 60 * 60}
//           `)
//           break
//   }
// }
// ageInTime(33)

// let job = "Developer";
// let salary = 0;

// if (job === "Manager") {
//   salary = 8000;
// } else if (job === "IT" || job === "Support") {
//   salary = 6000;
// } else if (job === "Developer" || job === "Designer") {
//   salary = 7000;
// } else {
//   salary = 4000;
// }

// console.log(salary);

// switch (job) {
//   case "Manager":
//     salary = 8000;
//     break;
//   case "IT" || "Support" :
//     salary = 6000;
//     break;
//   case "Developer" || "Designer" :
//     salary = 7000;
//     break;
//   default:
//     salary = 4000;
// }

// console.log(salary)

// let holidays = 0;
// let money = 0;

// switch (holidays) {
//   case 0:
//     money = 5000;
//     console.log(`My Money is ${money}`);
//     break;
//   case 1:
//   case 2:
//     money = 3000;
//     console.log(`My Money is ${money}`);
//     break;
//   case 3:
//     money = 2000;
//     console.log(`My Money is ${money}`);
//     break;
//   case 4:
//     money = 1000;
//     console.log(`My Money is ${money}`);
//     break;
//   default:
//     money = "NO MONEY";
//     console.log(`My Money is ${money}`);
// }

// if (holidays === 0) {
//   money = 5000;
//   console.log(`My Money is ${money}`);
// } else if (holidays === 1 || holidays === 2) {
//   money = 3000;
//   console.log(`My Money is ${money}`);
// } else if (holidays === 3) {
//   money = 2000;
//   console.log(`My Money is ${money}`);
// } else if (holidays === 4) {
//   money = 1000;
//   console.log(`My Money is ${money}`);
// } else {
//   money = "NO MONEY";
//   console.log(`My Money is ${money}`);

// ----------------------------------array-----------------------------------------

// let myFriends = ["Mohamed", "Ahmed", "Soliman", ["Marwan", "Ali"]];
// let me = "soliman"
// console.log(`Hello ${myFriends[0]}`);
// console.log(`Hello ${myFriends[0][2]}`);
// console.log(`Hello ${myFriends[3][1]}`);
// console.log(`Hello ${myFriends[3][1][2]}`);
// console.log("Hello " + myFriends[2]);

// console.log(myFriends);
// myFriends[1] = "Hussein";
// console.log(myFriends[3])
// console.log(myFriends);
// myFriends[3] = "same7";
// console.log(myFriends);

// console.log(Array.isArray(myFriends)) //true
// console.log(Array.isArray(me)) //false ( string considered as list but give false with Array check)

// let myFriends = ["Mohamed", "Ahmed", "Soliman", "Hussein"];

// console.log(myFriends.length); //4
// // you can use myFriends.length to know where to put the input at end of Array
// myFriends[myFriends.length] = "Ali";
// // you can use (myFriends.length -1) to update last value in Array
// myFriends[myFriends.length - 1] = "Ali";
// //if you put location more than length will put empty spaces then will add "Ali"
// myFriends[6] = "Ali";
// // if you change myFriends.length manually will remove excess
// myFriends.length = 2;
// console.log(myFriends);

// let myFriends = ["Mohamed", "Ahmed", "Soliman", "Hussein"];

// console.log(myFriends);
// // unshift method to add elements at the begining of Array
// myFriends.unshift("Mr", "Dr");
// console.log(myFriends);
// push method to add elements at the End of Array
// myFriends.push("Mr", "Dr");
// console.log(myFriends);
// console.log(myFriends.push("Mr", "Dr")); // return the new length of Array
// // shift will remove first element from Array and save it and you can use it later
// myFriends.shift();
// console.log(myFriends);
// let first = myFriends.shift();
// console.log(first);
// // pop will remove last element from Array and save it and you can use it later
// myFriends.pop();
// console.log(myFriends);
// let last = myFriends.pop();
// console.log (last)

// unshift and push will return length of Array after adding the new elements into the Array
// shift and pop will return removed element 

// let myFriends = ["Mohamed", "Ahmed", "Soliman", "Hussein", "Ahmed"];

// console.log(myFriends);
// // if there is more than one "Ahmed" in the Array will give you index of first one only (also in string)
// console.log(myFriends.indexOf("Ahmed"));
// // 2nd value is start point of searching (default value 0), if there is no "Ahmed" will give you -1
// console.log(myFriends.indexOf("Ahmed", 2));
// // lastIndexOf will search from the end (opposite direction) of Array so he will find the 2nd"Ahmed"
// // meaning of opposite direction is if you start search from index 0 will give you -1 because
// // it will search in opposite direction and will not find anything
// console.log(myFriends.lastIndexOf("Ahmed"));
// // 2nd value is start point of searching (default value array.length -1)
// // 2nd value is start point of searching it's negative because we will search from the End or positive value no problem but in string does not accept negative value
// console.log(myFriends.lastIndexOf("Ahmed", -2));
// // difference between includes and indexOf : includes return true or false but indexOf give you index no. (also in string)
// console.log(myFriends.includes("Ahmed"));

// if (myFriends.indexOf("Ahmed", 5) === -1) {
//   console.log("Not Found")
// }

// let myFriends = [10, "Sayed", "Mohamed", "90", 1000, 100, 20, "10", -20, -10];

// console.log(myFriends);
// // in sorting you will find that 20 after 1000 because he will sort 1,2,3,4,.... and A,B,C,D...
// console.log(myFriends.sort());
// // reverse will only reverse not matter about who bigger than who
// console.log(myFriends.reverse());

// let myFriends = ["Mohamed", "Ahmed", "Soliman", "Hussein", "Ahmed"];
// console.log(myFriends.slice(1));
// console.log(myFriends.slice(1, 3));
// // with negative value will count from End but slicing direction normal not opposite like lastIndexOf
// console.log(myFriends.slice(-3));
// console.log(myFriends.slice(1, -2));
// // slicing Method return a new Array and will not effect original Array
// // that's why console.log(myFriends); will give you original Array without changes
// console.log(myFriends);
// // here will remove 1st element from original Array "mohamed" not "sameer"
// splice (start, delete count)
// myFriends.splice(0, 1, "sameer", "samara");
// // splicing Method will change the original Array
// console.log(myFriends);

// let myFriends = ["Mohamed", "Ahmed", "Soliman", "Hussein", "Ahmed"];
// let myNewFriends = ["Samar", "Sameh"]
// let schoolFriends = ["Haytham", "Shady"]
// // you can concatenate Arrays or Elements or Numbers
// let allFriends = myFriends.concat(myNewFriends,"Gamal",["Mans, Papo"],schoolFriends, 1)
// console.log(allFriends)

// array.flat() to remove nested arrays and merge it to parent array
// let myFriends = ["Mohamed", "Ahmed", ["Soliman",["nested", "Array"], "Hussein"], "Ahmed"];
// console.log(myFriends)
// console.log(myFriends.flat())
// // array.falt does not change original array
// myFriends[2].flat()
// console.log(myFriends.flat())
// myFriends.splice(2,1,...myFriends[2].flat())
// console.log(myFriends)

// Array.of() and Array()
// Array.of(7) will create Array with one element 7
// Array(7) will create empty array with length 7


// The join() method creates and returns a new string by concatenating all of the elements
//  in an array (or an array-like object), separated by commas or a specified separator string
// console.log(allFriends.join()) // sepertaor , 
// console.log(allFriends.join("")) // no seperator
// // you can choose the separetors
// console.log(allFriends.join(" @ "))

// --------Challenge----------

// let zero = 0;
// let counter = 3;

// let my = ["Ahmed", "Mazero", "Elham", "Osama", "Gamal", "Ameer"];

// ["Osama","Elham","Mazero","Ahmed"]
// let popped = my.reverse().pop()
// let sl = my.slice(-counter)
// sl.push(popped)
// console.log(sl)

//  --another Answer--
// console.log(my.slice(zero, ++counter).reverse())

// ["Elham", "Mazero"]
// my = my.slice(zero, counter)
// my.shift()
// console.log(my.reverse())

//  --another Answer--
// console.log(my.slice(++zero, counter).reverse())

// "Elzero"
// my.shift()
// let Mazero = my.shift()
// Mazero = Mazero.split("")
// Mazero.shift()
// Mazero.shift()
// let Zero = Mazero.shift() + Mazero.shift() + Mazero.shift() + Mazero.shift()
// let Elham = my.shift()
// Elham = Elham.split("")
// let El = Elham.shift() + Elham.shift()
// console.log(El + Zero)

//  --another Answer--
// my = my[++zero]
// my = my.split("")
// // splice only work with Array so you should split String first
// my.splice(--zero, --counter, "E", "l")
// my = my.join("")
// console.log(my)

//  --another Answer--
// console.log(my[--counter].slice(zero, counter) + my[++zero].slice(counter))

// "rO"
// my.shift()
// let Mazero = my.shift()
// Mazero = Mazero.split("")
// Mazero = Mazero.slice(counter)
// Mazero.shift()
// let r = Mazero.shift()
// let O = Mazero.pop()
// console.log(r + O.toUpperCase())

//  --another Answer--

// console.log(my[++zero].slice(++counter)[--zero] + my[++zero].slice(counter)[zero].toUpperCase())

// --------End Challenge----------

// ---------------------------------------for loop----------------------------
/* 
Steps of for loop 
[1] initialExpression => let i =0; 
    let i = 0 ; excuted only one time a the beginning of for loop and you can 
    declare another variables inside then step
[2] conditionExpression => i < 10;
[3] excute Statment
[4] incrementExpression 
[5] return to step [2]
*/

// for ([initialExpression][conditionExpression][incrementExpression]) {
  // statment
// }

// for (let i = 0; i < 10; i++){
//   console.log(i)
// }

// let my = [1, 2, "Ahmed", "Mazero", "Elham", "Osama", "Gamal"];
// for (let i = 0; i < my.length; i++) {
//   console.log(my[i]);
// }
// let onlyNames = [];

// for (let i = 0; i < my.length; i++) {
//   if (typeof my[i] === "string") {
//     onlyNames.push(my[i])
//   }
// }

// console.log(onlyNames)

// let products = ["Keyboard", "Mouse", "Pen", "Pad", "Monitor"];
// let colors = ["Red", "Green", "Black"];
// let models = [2020, 2021];

// for (let i =0; i < products.length; i++) {
//   console.log("#".repeat(10))
//   console.log(`# ${products[i]}`)
//   console.log("#".repeat(10))
//   console.log("Colors: ")
//   for ( let j = 0; j < colors.length; j++) {
//     console.log(`- ${colors[j]}`)
//   }
//   console.log("Models: ")
//   for ( let k = 0; k < models.length; k++) {
//     console.log(`- ${models[k]}`)
//   }
// }

// let products = ["Keyboard", "Mouse", 10, 20, "Pen", "Pad", "Monitor"];
// let colors = ["Red", "Green", "Black"];
// let models = [2020, 2021];

// for (let i = 0; i < products.length; i++) {
//   if (products[i] === "Pen") {
//     break;
//   }
//   console.log(products[i]);
// }

// to check if it's a string or not
//if (isNaN(products[i])) // typeof products[i] === "string"

// to check if it's a number or not
//if (Number.isInteger(products[i])) // typeof products[i] === "number"

// continue means skip everything in this loop 

// for (let i = 0; i < products.length; i++) {
//   if (typeof products[i] === "number") {
//     continue;
//   }
//   console.log(products[i]);
// }

// identifiers are used to name variables and functions
// and to provide labels for certain loops in JavaScript code 

// with identifier you can Break or Continue mainLoop from nestedLoop

// mainLoop: for (let i = 0; i < products.length; i++) {
//   console.log(products[i]);
//   nestedloop: for (let j = 0; j < colors.length; j++) {
//     console.log(`- ${colors[j]}`);
//     if (colors[j] === "Green" ) {
//       break mainLoop;
//     }
//   }
// }

// let products = ["Keyboard", "Mouse", "Pen", "Pad", "Monitor"];

// for (let i = 0; i < products.length; i++) {
//   console.log(products[i])
// }

// // another way to write loop
// let i =0;
// for (;;) {
//   console.log(products[i]);
//   i += 2;
//   if (i >= products.length) {
//     break;
//   }
// }

// here i added i >= products.length because i increased by 2 and will not i === products.length
// because length 5 and i  will be 2,4,6

// i ++ => i =  i + 1 => i+= 1
// i += 2

// let products = ["Keyboard", "Mouse", "Pen", "Pad", "Monitor", "iphone"];
// let colors = ["Red", "Green", "Blue"];
// let showCount = 5;

// document.write(`<h1>Show ${showCount} Products</h1>`)

// for (let i =0; i < showCount; i++) {
//   document.write(`<div>`)
//   document.write(`<h3>[${i + 1}]${products[i]}</h3>`)
//   for ( let j = 0; j < colors.length; j++) {
//     document.write(`<p>- ${colors[j]}</p>`)
//   }
//   document.write(`<p>- ${colors.join(" | ")}</p>`)
//   document.write(`</div>`)
// }

// let products = ["Keyboard", "Mouse", "Pen", "Pad", "Monitor", "iphone"];

// let i = 0;
// while  (i < products.length) {
//   console.log(products[i])
//   i++
// }

// let i = 0;
// while  (i < 10) {
//   console.log(i)
//   i++
//   if (i === 3) {
//     break;
//   }
// }

// Here will print 0 - 9  
// let i = 0;
// while (i < 10) {
//   console.log(i)
//   i++
// }

// --------------------------------Do-While loop----------------------------

// will print only 0 because do will print 0 then check the condition on while
// let i = 0;
// do {
//   console.log(i);
//   i++;
// } while (false)

// let i = 0;
// do {
//   console.log(i);
//   i++;
// } while (i < 10)


// ------Challenge------

// let myAdmins = ["Ahmed", "Osama", "Sayed", "Stop", "Samera"];
// let myEmployees = [
//   "Amgad",
//   "Samah",
//   "Ameer",
//   "Omar",
//   "Othman",
//   "Amany",
//   "Samia"
// ];

// let i = 0 ;
// for (;i < myAdmins.length;i++ ){
//   if (myAdmins[i] === "Stop") {
//     document.write(`<div>We Have ${i} Admins</div>`);
//     break;
//   }
// }

// console.log(i)
// for (let f = 0; f < i;f++) {
//   document.write(`<hr>`)
//   document.write(`<h3>The Admin For Team ${(f + 1)} Is ${myAdmins[f]} </h3>`)
//   document.write(`<h1>Team Members</h1>`)
//   let counter = 0;
//   for (let k = 0; k < myEmployees.length; k++) {
//     if (myAdmins[f][0] === myEmployees[k][0]) {
//       counter++;
//       document.write(`<h4>- ${counter} ${myEmployees[k]}</h4>`);
//     }
//   }
// }

// ------End Challenge------

// -------------------------------------function--------------------------------------------
// function sayHello(userName , age) {
//   if (age < 18) {
//     console.log(`App is Not Suitable For You`)
//   }else {
//     console.log(`Hello ${userName} Your Age is ${age}`);
//   }
// }
// sayHello("Soliman",33);

// function generateYears(start, end, exclude) {
//   for (let i = start; i <= end ; i++) {
//     if ( i === exclude) {
//       continue;
//     }
//     console.log(i);
//   }
// }

// generateYears(1982, 2022, 2000)

// function sayHello (userName) {
//   return `Hello ${userName}`
// }

// // console.log(sayHello("Soliman"))
// let result = sayHello("Soliman")
// console.log(result)

// after return you can not write any Code it will not run

// function calc(num1, num2) {
//   return num1 + num2;
//   console.log("ERROR")
// }
// calc(1, 2)

// let result = calc( 10 , 20 );

// console.log(result + 100);

// return here like break
// function generate(start, end){
//   for( let i = start; i <= end; i++) {
//     if ( i === 15) {
//       return `Error`
//       // break
//     }
//     console.log(i)
//   }
// }

// generate(10, 20)
// console.log(generate(10, 20))

// change default value of parameters
// you can write default value by two ways 
// 1st way write it directly after parameter like age = "Es6"
// 2nd way write if inside block of code like age = age || "Unknown"
// function sayHello(userName ="Es6", age = "Es6" ) {
//   // if ( age === undefined) {
//   //   age = "ERROR";
//   // }
//   // age = age || "Unknown"
//   return `Hello ${userName} Your Age is ${age}`;
// }

// console.log(sayHello());

// ...numbers called rest parameters ( its an Array and now you can add as many Arguments as you need you don't need to add same no. of parameters)
// rest parameter should be last parameter if you have more than one parameters
// function calc(...numbers) {
//   let result = 0;
//   for (let i = 0; i < numbers.length; i++) {
//     result += numbers[i]
//   }
//   return `Final Result is ${result}`
// }

// console.log(calc(10, 20,30))


// to skip argumet you can create varaible with undefined value to use it instead of arguments
// let _ = undefined;

// function showInfo(us = "Un", age = "Un", rt = 0, show = "Yes", ...sk) {
//   document.write(`<div>`);
//   document.write(`<h2>Welcome, ${us}</h2>`)
//   document.write(`<p>Age: ${age}</p>`)
//   document.write(`<p>Our Rate: $${rt}</p>`)
//   if (show === "Yes") {
//     if (sk.length > 0) {
//       document.write(`<p>Skills: ${sk.join(" | ")}</p>`)
//     }else {
//       document.write(`<p>Skills Not Found</p>`)
//     }
//   }else {
//     document.write(`<p>Skills Is Hidden</p>`)
//   }
//   document.write(`</div>`);
// }

// showInfo("Soliman", 33, 20,_,"JS", "HTML", "CSS");

// --------Challenge--------

// function showDetails (a, b, c) {
//   let Name;
//   let Age;
//   let Av;
//   typeof a === "string" ? Name = a : typeof a === "number" ? Age = a : a === true ? Av = "You Are Available For Hire" : a === false ? Av = "You Are Not Available For Hire" : a = null;
//   typeof b === "string" ? Name = b : typeof b === "number" ? Age = b : b === true ? Av = "You Are Available For Hire" : b === false ? Av = "You Are Not Available For Hire" : b = null;
//   typeof c === "string" ? Name = c : typeof c === "number" ? Age = c : c === true ? Av = "You Are Available For Hire" : c === false ? Av = "You Are Not Available For Hire" : c = null;
//   return `Hello ${Name}, Your Age Is ${Age}, ${Av}` ;
// }

// console.log(showDetails(40, "Ahmed", false))

// ---Another Answer-----
// function showDetails(...parameters) {
//   let one, two, three;
//   document.write(`<div>`);
//   for (let i = 0; i < parameters.length; i++) {
//     let s = typeof parameters[i];
//     switch (s) {
//       case "string":
//         one = parameters[i];
//         break;

//       case "boolean":
//         if (parameters[i] === true) {
//           three = "you are avilable for hire";
//         } else {
//           three = "you are not  avilable for hire";
//         }
//         break;

//       case "number":
//         two = parameters[i];
//         break;
//     }
//   }

//   document.write(
//     `<p> hello ${one} , yor age is ${two} , your status it ${three} </p>`
//   );

//   document.write(`</div>`);
// }

// showDetails(true, 25, "kenan");
// showDetails(25, "kenan", false);
// showDetails(true, "kenan", 25);
// showDetails("kenan", true, 25);

// --------End Challenge--------

// you can create function after console.log no problem because of hoisting
// But with Anonymous Function(Without name) ( console.log should be after it) 
// because we declare Anonymous Function with variable and you can access variable before intialization



// console.log(calc(1, 2))

// function calc (a, b) {
//   return a + b;
// }

// // Anonymous Function
// let Calculator = function (a, b) {
//   return a + b;
// }
// console.log(Calculator( 1 , 2));

// document.getElementById("show").onclick = function () {
//   console.log("show")
// }

// function sayHello () {
//   console.log("Hello, Osama")
// }

// here if we write sayHello() the function will run once you reach this line of code
// but we wrote sayHello to reference to this function and only trigger the function once you click 
// document.getElementById("show").onclick = sayHello;

// setTimeout(function () {
//   console.log("good");
// }, 2000);

// function sayMessage(fName, lName) {
//   let message = "Hello";
//   // Nested Function
//   function concatMsg () {
//     message = `${message} ${fName} ${lName}`
//   }
//   concatMsg();
//   return message;
// }

// console.log(sayMessage("Mohamed", "soliman"))


// function sayMessage(fName, lName) {
//   let message = "Hello";
//   // Nested Function
//   function concatMsg() {
//     function getFullName () {
//       return ` ${fName} ${lName}`
//     }
//     return `${message}  ${getFullName ()}`;
//   }
//   return concatMsg();
// }

// console.log(sayMessage("Mohamed", "solimnan"));

//-----------------------------------------Arrow Function---------------------------------
// you can remove () if you have only one parameters if more than one parameter or no parameters you need ()
// you need {} and return if you have more than one line of processing inside function

//----Limitaion of Arrow Function---- (later after finish JS course)
// * Does not have its own bindings to this or super, and should not be used as methods.
// * Does not have new.target keyword.
// * Not suitable for call, apply and bind methods, which generally rely on establishing a scope.
// * Can not be used as constructors.
// * Can not use yield, within its body.
// * Does not have arguments object
// * Can not return object because JS will be confused between {} of function and {} of object

// to solve last limitation add parenthesis
// const sayName = () => ({
//   name: "Jonh Doe",
//   age: 26,
// });
// console.log(sayName().name);


// let a =10;
// var b =20;
// var obj = {
//   c : 30
// }
// here this will refer to window object and var in global scope so will find this.b (window.b)
// but let is block scope so a in local scope not in global scope so will no find this.a
// function arrow(){
//   console.log(this.a)
//   console.log(this.b)
//   console.log(this.c)
// }
// arrow()
// arrow.call(obj)

// let arrow = () => console.log(this.c)
// arrow()
// arrow.call(obj)

// let print =() => 10; // let print = function () { return 10;};
// console.log(print())

// let print = function (num) {
//   return num;
// }
// let print = (num) => num; 
// let print = num => num; //you can remove () if you have only one parameters
// console.log(print(100))

// here we used {} and return with arrow function
// let a = 10;
// let b = 20;
// let curly = (a, b) => {
//   let c = 30;
//   return a + b + c
// } 
// console.log(curly(a,b))

// let print = function (num1, num2) {
//   return num1 + num2;
// }
// let print = (num1, num2) => num1 + num2;
// console.log(print(2, 5))

// -------------------------------Currying Function Technique :
// Currying is when you break down a function that takes multiple arguments
// into a series of functions that each take only one argument.

// function checker(zName) {
//     return function (status) {
//         return function (salary) {
//             return status === "Available" ? `${zName}, My Salary Is ${salary}` : `Iam Not Avaialble`;
//         };
//     };
// }

// let checker = (zName) => (status) => (salary) => status === "Available" ? `${zName}, My Salary Is ${salary}` : `Iam Not Avaialble`;

//   console.log(checker("Osama")("Available")(4000)); // My Salary Is 4000
//   console.log(checker("Ahmed")("Not Available")()); // Iam Not Avaialble

// -----------------------------Partial Function:
// is when a function has been given some, but not all, of its arguments

// let obj = {
//   theName : "Soliman"
// }

// function hello (place) {
//   console.log(`Hello ${this.theName} from ${place}`)
// }
// let hi = hello.bind(obj,"EGYPT")
// hi()

// we can add null instead of object to take (this) from
// function sum (x,y) {
//   console.log(x + y) 
// }
// // you can write sum.bind(null,5,10) or pass 2nd argument when you call the new function like bindSum(10)
// let bindSum = sum.bind(null,5)
// bindSum(10)


// ------------------------------Scope ( Global And Local Scope)-----------------------------

// var a = 1;
// let b = 2;

// // function will search first at local scope then if he did not find them will search outside
// function showText() {
//   var a = 10;
//   let b = 20;
//   console.log(`Function From Local ${a}`);
//   console.log(`Function From Local ${b}`);
// }

// // can't take local Variables from Function
// console.log(`From Global ${a}`);
// console.log(`From Global ${b}`);
// showText();


// var is not Block scope ( the value change globally )
// with statments or loops var will be global and you can access it from outside but function not (because var is function scope not block scope)
// let is Block Scope and function scope
// with statments or loops or function you can't access let or const
// var x = 10;
// let x = 10;

// function Scope
// function calc() {
//   var x = 50;
//   // let x = 50;
// }
// console.log(x)

// block scope
// let c =10;
// var d = 10;
// for ( i=0; i<3; i++){
//   var a = 10;
//   let b =20;
//   c = 30
//   d = 40
// }
// console.log(a)

// Lexical Scope nested child can take variable from parent but parent can't take from child
// function parent() {
//   let a = 10;
//   function child() {
//     console.log(a);
//     function grand() {
//       console.log(a);
//     }
//     grand();
//   }
//   child();
// }
// parent();

// --------Challenge---------
// to uppercase only first letter  s[0].toUpperCase() + s.slice(1);

// let Names = (...parameters) => `${(typeof parameters[0])[0].toUpperCase() + (typeof parameters[0]).slice(1) } [${parameters.join("],[")}] => Done !`;

// console.log(Names("osama", "Mohamed", "Ali", "Ibrahim"));

// let myNumbers = [ 20, 50, 10, 60];
// let calc = (one, two, ...nums) => one + two + Number(nums) ;

// let calc = function (one, two, ...nums) {
  // return one + two + Number(nums);
// }
// console.log(calc(10,myNumbers[+false] ,myNumbers[+true]));
// there is a problem in this solution because we can not sum more than one value so check My Challenge
// --------End Challenge----------

// ------My Challenge---------------

// let myNumbers = [ 20, 50, 10, 60];
// let calc = (one, two, ...nums) => { 
//   let sum = one + two;
//   for(i = 0; i < nums[0].length; i++){
//     sum += nums[0][i]
//   };
//   return sum;
// }

// console.log(calc(10, 20, myNumbers))

// console.log([...myNumbers])

// let myNumbers = [ 20, 50, 10, 60];
// let calc = (one, two, ...nums) => { 
//   let sum = one + two;
//   // newNums = Array.from(...nums)
//   // newNums = nums.toString().split(",").map(i=>Number(i))
//   newNums = Object.assign([], ...nums)
//   for(i = 0; i < newNums.length; i++){
//     sum += newNums[i]
//   };
//   return sum;
// }
// console.log(calc(10,20, myNumbers))

// to remove outer array
// console.log(...[[1,2,3,4]])
// to remove outer array and save it to variable
// newArray = Array.from(...[[1,2,3,4]])
// newArray = Object.assign([], ...[[1,2,3,4]])
// console.log(newArray)
// toString will give you the value even if it's inside nested loop
// console.log([[1,2,3,4]].toString())



// console.log([[1,2,3,4]].toString().split(",").map(i=>Number(i)))
// console.log([[1,2,3,4]].toString().split(",").map(Number))
// console.log(Array.from(Array.from("1234"), Number))


// ------End My Challenge---------------

//----------------------------------------Higher Order Functions----------------------------------

// Higher-Order Functions vs Currying Function Technique:

/* 
* Higher-Order Functions : which take another function as an argument or return a function

* Currying Function Technique: is when you break down a function that takes multiple arguments
into a series of functions that each take only one argument. 
All curry functions is higher order functions but curry accept only one argument for each function 
*/


// ---------------------------------------Callback Functions----------------------------

/*
In JavaScript, a callback function is a function that is passed into another function
as an argument. This function can then be invoked 
during the execution of that higher order function (that it is an argument of).
use cases of callback functions are setTimeout() , setInterval(), waiting for files and higher order function
However, there are some cases that code runs (or must run) after something else happens 
and also not sequentially. This is called asynchronous programming.
https://www.w3schools.com/js/js_asynchronous.asp
*/

// CallBackFunction in for loop and higher order function

// let arr = [0,1,2,3]
// for ( let i =0; i < arr.length; i++) {
//   (function callback(){
//     console.log(arr[i])
//   })()
// }

// arr.map((el)=> console.log(el))

// Higher Order Functions like Array Methods
// Map => return a new Array
// Filter => return a New Array ( only with element that have true condition from the callBackFunction)
// reduce => return only one value
// forEach => return nothing
// every => retrun nothing 
// sort => retrun a new Array
// findIndex => return only one Index
// find() => returns the value of the first element that passes a test.return undefined if not found
// some() => like find() but return true or false



// let myNums = [1, 2, 3, 4, 5, 6];

// let newArray = [];

// for (let i =0; i < myNums.length; i++) {
//   newArray.push(myNums[i] + myNums[i])
// }
// console.log(newArray)

// -------------map() Method
// Same Idea with Map ( Map Create New Array)
// Syntax map (callBackFunction(Element, Index, Array) {}, thisArg)
// -Element => The current element being processed in the array
// -Index => The index of the current element being processed in the array
// -Array => the Current Array

// let newMapArray = myNums.map(function (element, index, arr) {
//   return element + element;
// })

// Arrow Function with higher order Function
// let newMapArray = myNums.map((element) => element + element);

// Named Function with Higher order function
// function addition (element) {
//   return element + element;
// }
// let newMapArray = myNums.map(addition);

// console.log(newMapArray);

// ---------to change string to Array
// 1 - Array.from("string")
// 2 - "string".split("")
// 3 - [..."string"]

// ---------to change Array to String
// 1 - ["s", "t", "r", "i", "n", "g"].join("") without comma or .join() with comma
// 2 - ["s", "t", "r", "i", "n", "g"].toString() with comma , 
// 3- .reduce((acc, current) => `${acc}${current}`) without comma

// let swappingCases = "elZERo";

// let sw = swappingCases.split("").map((ele) => ele === ele.toUpperCase() ? ele.toLowerCase() : ele.toUpperCase() ).join("")
// console.log(sw)

// let invertedNumbers = [1, -10, -20, 15, 100, -30];
// let inmus = invertedNumbers.map((ele) => ele = -ele );
// console.log(inmus)

// let invertedNumbers = [1, -10, -20, 15, 100, -30];
// let inmus = invertedNumbers.map(function () {
//   return +this
// }, 90);
// console.log(inmus)

// let ignorenumbers = "Elz123er4o";

// isNaN("3") will return false beacause it will consider "3" as a number
// isNaN(parseInt("3")) will return false beacause parseInt("3") return 3 as number
// let ignum = ignorenumbers.split("").map((ele) => isNaN(ele) === true  ? ele : "").join("")
// let ignum = ignorenumbers.split("").map((ele) => isNaN(parseInt(ele)) ? ele : "").join("")

// ----------------filter() Method
// easy way to use filter | filter like map but return new Array with only element that have true value
// let ignum = ignorenumbers.split("").filter((ele) => isNaN(ele) ).join("")
// console.log(ignum)

// let friends = [ "Ahmed", "Sameh", "Sayed", "Asmaa", "Amgad", "Israa"];
// let filterFriends = friends.filter((ele) => ele[0] === "A" )
// let filterFriends = friends.filter((ele) => ele.startsWith("A") )
// console.log(filterFriends)

// let numbers = [11, 20, 2, 5, 17, 10];
// let filterNumbers = numbers.filter( (ele) => Number.isInteger(ele / 2))
// let filterNumbers = numbers.filter( (ele) => ele % 2 === 0)
// let filterNumbers = numbers.map ((ele) => Number.isInteger(ele / 2) ? ele : "")
// console.log(filterNumbers)

// let sentence = "I Love Foood code Too Playing Much"
// let filtercode = sentence.split(" ").filter((el) => el.length <= 4).join(" ")
// console.log(filtercode)

// let mix = "A13BS2ZX"

// let filterMix = mix.split("").filter((el) => Number.isInteger(+el)).join("")
// let filterMix = mix.split("").filter((el) => !isNaN(el)).join("")
// let doubleMix = filterMix.split("").map((el) => el*el).join("")
// console.log(doubleMix)

// -------------reduce() Method
// Reduce ((callBackFunction(Accumulator , Current Element, Current Index, Source Array)), intial Value)
// Acculator => the accumulated value previously returned in the last invocation
// Current Val => The Current element being processed in the array
// Index => The index of the current element being processed in the array.
// starts from index 0 if an initialValue is provided
// Otherwise, it starts from index 1
// Array => The Current Array
// Return only one Value

//without initial Value accumulator is 10 -- current is 20 -- index of current 1 
//with initial Value accumulator is 5 -- current is 10 -- index of current 0 
// let nums = [10, 20, 15, 30];
// let add = nums.reduce((acc,current,index,arr) => acc + current , 5)
// let add = nums.reduce((acc,current,index,arr) => {
//   console.log(`acc : ${acc}`)
//   console.log(`Current : ${current}`)
//   console.log(`index : ${index}`)
//   return acc + current
// }, 5)
// console.log(add)

// let theBiggest = ["Bla", "Propaganda", "other", "AAA", "Battery", "Test"];
// let big = theBiggest.filter((el) => el.length > 7 ).toString()
// let big = theBiggest.reduce((acc, current) => acc.length > current.length ? acc : current )
// let big = theBiggest.reduce((acc, current) => acc.length > current.length ? acc : current ,"aaaaaaaaaaaaaa")
// console.log(big)

// let removeChars = ["E", "@", "@", "L", "Z", "@", "@", "E", "R", "@", "O"]

// .reduce((acc, current) => `${acc}${current}`) same like .join("")

// let filterChars = removeChars.filter((el) => el !== "@" ).reduce((acc, current) => `${acc}${current}`)
// console.log(filterChars)

// ------------------forEach() Method
// ForEach ( does not return Anything [undefined]) (Break will not Break the Loop if you want to break use every())
// Syntax ForEach (callBackFunction(Element, Index, Array) {}, thisArg)
// -Element => The current element being processed in the array
// -Index => The index of the current element being processed in the array
// -Array => the Current Array

// let allLis = document.querySelectorAll("ul li");
// let allDivs = document.querySelectorAll(".content div")

// allLis.forEach((el) => el.onclick = function () {
//   // Remove Active from All Elements
//   allLis.forEach((el) => el.classList.remove("active"))
//   // Add Active to This Element
//   this.classList.add("active")
//   // Hide all Divs
//   allDivs.forEach((el) => el.style.display = "none")
// })


// ------------------every() Method
// you can not break forEach but you can break every() return false like break
// let arr = [1,2,3,4];
// // let foreach = arr.forEach((el) => console.log(el))
// let every = arr.every((el) => {
//   if( el > 3) {
//     return false
//   }else {
//     console.log(el)
//     // you should return true if not will exit the function
//     return true
//   }
// } )

// another way to break forEach ( using findIndex)
// let ignoreEl = arr.slice(0, arr.findIndex(el => el > 3))
// ignoreEl.forEach(el => console.log(el))

// another way to break forEach ( using Local variable)
/*but not real break it will continue looping but will not excute console.log(el) beacuse of anything after return will not work */
// let breakForeach = false;
// arr.forEach((el) => {
//   if (breakForeach) {
//     console.log("hello")
//     return
//   }
//   if(el > 2) {
//     breakForeach = true
//     return
//   }
//   console.log(el)
// })


// ----------------Sort() Method
// The Default sort order is ascending

// let nums = [9,8,7,6,5,4,3,2,1]
// The Default sort order is ascending
// let sortedNum = nums.sort()
// > 0 sort num2 before num1 | < 0 sort num1 before num2 | === 0 keep original order
// let sortedNum = nums.sort((num1,num2) => num1 > num2 ? 1 : -1)
// let sortedNum = nums.sort((num1,num2) => num1 - num2)

// console.log(sortedNum)

// -------------Find() Method
// let arr = [1,2,3,4]
// console.log(arr.find((el) => el > 3)) // return the element

// -------------Some() Method
// let arr = [1,2,3,4]
// console.log(arr.some((el) => el > 3)) // return true 
// console.log(arr.some((el) => el > 4)) // return false


// ------------diference between forEach and map
// const arr = ["A", "B", "C", "D", , "F"]
// let newArr1 = arr.map((ele,index) => ele.toLowerCase() ) // 4 will not show up
// let newArr2 = arr.forEach((ele,index) => ele.toLowerCase() ) // 4 will not show up
// console.log(newArr1) // return new Array
// console.log(newArr2) // undefined (forEach does not return anything)

// ---------------Filter vs some vs find vs findIndex----------------
/*
* Filter will return found element or array of found elements and will continue the loop till end of array

* Find will return found element only of first match not array of found elements 
not like Filter will return an array of all matches and will not continues the loop till the end

*FindIndex will return the index of first Match if not found return -1 like indexOf method

* Some will return true once found first match and will not continue the loop till the end
*/
// let names = ["Mohamed","Ahmed","Soliman","Hussein"]
// console.log(names.indexOf("Ahmed")) // 1
// let arrOfObjs = [
//   {id : 1 , name : "Mohamed"},
//   {id : 2 , name : "Ahmed"},
//   {id : 3 , name : "Soliman"},
//   {id : 4 , name : "Hussein"}
// ]
// //  will return -1 because this object is not the same object inside arrOfObjs (assigned be reference)
// let toBeFound = {id : 2 , name : "Ahmed"}
// console.log(arrOfObjs.indexOf(toBeFound)) 
// let obj = {
//   lastName : "Hussein"
// }

// // to solve this problem you can use filter or some or find or findIndex

// [1] Filter
// let count = 0;
// let filterFound = arrOfObjs.filter(ele => {
//   count++
//   if(toBeFound.id === ele.id){
//     return true
//   }else{
//     return false
//   }
// })
// console.log(filterFound,"After Looping", count,"Times") // 4 times

// [2] Some
// count = 0;
// let someFound = arrOfObjs.some((ele,index) =>{
//   count++;
//   if(toBeFound.id === ele.id){
//     console.log(arrOfObjs[index],'After Looping',count,'Times') // 2 times
//     return true
//   }else{
//     return false
//   }
// })
// console.log(arrOfObjs[count-1],'After Looping',count,'Times') // 2 times

// [3] Find
// count = 0;
// let findFound = arrOfObjs.find((ele) =>{
//   count++;
//   if(toBeFound.id === ele.id){
//     return true
//   }else{
//     return false
//   }
// })
// console.log(findFound,'After Looping',count,'Times') // 2 times

// [4] findIndex
// count = 0;
// let findIndexFound = arrOfObjs.findIndex((ele,index) =>{
//   count++;
//   if(toBeFound.id === ele.id){
//     return true
//   }else{
//     return false
//   }
// })
// console.log(arrOfObjs[findIndexFound],'After Looping',count,'Times') // 2 times

// ---note : you can use thisArg with filter ,find, some, findIndex
// let filterFound = arrOfObjs.filter(function(ele) {
//   if(this.lastName === ele.name){
//     return true
//   }else{
//     return false
//   }
// },obj)
// console.log(filterFound)

// ---------------------------------------------Deep to JS Engine-----------------------------

/* 
JavaScript is an interpreted language, not a compiled language.

A program such as C++ or Java needs to be compiled before it is run. 
The source code is passed through a program called a compiler, 
which translates it into bytecode that the machine understands and can execute. 
In contrast, JavaScript has no compilation step. 
Instead, an interpreter in the browser reads over the JavaScript code, 
interprets each line, and runs it.
Modern browsers use a technology known as Just-In-Time (JIT) compilation, 
which compiles JavaScript to executable bytecode just as it is about to run.
JavaScript engines have two places where they can store data: The memory heap and stack.
Compiled language — the source file typically will be “compiled” to machine code (or byte code) before being executed.
Interpreted language — the source code will be read and directly executed, line by line.
JavaScript is an interpreted language, but that’s not necessarily true.
For Example, the V8 engine, the engine that runs Google Chrome and NodeJS, compiles to native code internally:
V8 increases performance by compiling JavaScript to native machine code before executing it, versus executing bytecode or interpreting it.
Also, Rhino and TraceMonkey use compilation as part of their process
*/

// to understand memory heap and call stack 
// https://medium.com/@allansendagi/javascript-fundamentals-call-stack-and-memory-heap-401eb8713204

/* ------------JS Engine 
* JS : Call stack & Excution environment and Memory heap 
* Call Stack : is a last-in-first-out data structure used to store and keep track of running functions, or processes.
* Excution environment : the execution environment of a JavaScript script describes where the code runs 
* Excution Context : consists of lexical environment (memory component) and Code component
* lexical environment : environment record (variable environment) and reference to the outer environment 

* -------------JS Memory 
JavaScript engines have two places where they can store data: The memory heap and stack.

A stack is a data structure that JavaScript uses to store static data. Static data is data where the engine knows the size at compile time. 
In JavaScript, this includes primitive values (strings, numbers, booleans, undefined, and null) and references, which point to objects and functions.

Since the engine knows that the size won't change, it will allocate a fixed amount of memory for each value.

The process of allocating memory right before execution is known as static memory allocation.

Heap: Dynamic memory allocation
The heap is a different space for storing data where JavaScript stores objects and functions.
Unlike the stack, the engine doesn't allocate a fixed amount of memory for these objects. Instead, more space will be allocated as needed.
Allocating memory this way is also called dynamic memory allocation.

https://felixgerschau.com/javascript-memory-management/
*/

// to understand Excution environment 
// https://medium.com/@bdov_/javascript-typescript-execution-vs-lexical-vs-variable-environment-37ff3f264831

// to understand this read about Closures , Lexical Environment and Excecution Context (link below)
// https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda

/* Execution context has two Phaes : Creation Phase and Execution Phase

Creation Phase :
* Create the global object i.e., window in the web browser or global in Node.js.
* Create the this object and bind it to the global object.
* Setup a memory heap for storing variables and function references.
* Store the function declarations in the memory heap and variables within the global execution context with the initial values as undefined.
* First, store the variables x and y and function declaration function() in the global execution context.
* Second, initialize the variables x and y to undefined.

Execution Phase :
* executes the code line by line. 
* assigns the values to variables.
* executes the function calls (For each function call, the JavaScript engine creates a new function execution context)

*/

/* Function execution context
The function execution context is similar to the global execution context.
But instead of creating the global object, the JavaScript engine creates the arguments object
that is a reference to all the parameters of the function:

Creation Phase :
* Global Object : arguments
* this: Window
* (parameter) : undefined

Execution Phase :
* Global Object : arguments
* this: Window
* (parameter) : argument value 

*/

/* lexical environment: 
Every time the JavaScript engine creates an execution context to execute the function
or global code, it also creates a new lexical environment to store the variable defined 
in that function during the execution of that function. 

A Lexical Environment has two components:
* ( The environment record ) is the actual place where the variable and function declarations are stored.
* ( The reference to the outer environment ) means it has access
to its outer (parent) lexical environment.

looks like:
lexicalEnvironment = {
  environmentRecord: {
    <identifier> : <value>,
    <identifier> : <value>
  }
  outer: < Reference to the parent lexical environment>
}

When a function completes, its execution context is removed from the stack, 
but its lexical environment may or may not be removed from the memory depending on 
if that lexical environment is referenced by any other lexical environments
in their outer lexical environment property.
Please note that when a lexical environment is created, 
the JavaScript engine attaches the Lexical Environment to all of the function definitions
inside that lexical environment. So that later on if any of the inner functions are called,
the JavaScript engine can set the outer lexical environment
to the lexical environment attached to that function definition.

check examples at closure Functions

reference link( https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda)

*/

/* Call Stack
JavaScript engine uses a call stack to manage execution contexts:
the Global Execution Context and Function Execution Contexts.

The call stack works based on the LIFO principle i.e., last-in-first-out.
When you execute a script, the JavaScript engine creates a Global Execution Context and 
pushes it on top of the call stack.
Whenever a function is called, the JavaScript engine creates a function execution context
for the function, pushes it on top of the call stack, and starts executing the function.
If a function calls another function, the JavaScript engine creates a new function execution 
context for the function that is being called and pushes it on top of the call stack.
When the current function completes, the JavaScript engine pops it off the call stack 
and resumes the execution where it left off.
The script will stop when the call stack is empty.

* stack overflow
The call stack has a fixed size, depending on the implementation of the host environment, 
either the web browser or Node.js.
If the number of the execution contexts exceeds the size of the stack,
a stack overflow error will occur.
For example, when you execute a recursive function that has no exit condition, 
the JavaScript engine will issue a stack overflow error:

* Asynchronous JavaScript
JavaScript is the single-threaded programming language. 
This means that the JavaScript engine has only one call stack. Therefore,
it only can do one thing at a time.
When executing a script, the JavaScript engine executes code from top to bottom, 
line by line. In other words, it is synchronous.
Asynchronous means the JavaScript engine can execute other tasks while waiting for another task to complete.
For example, the JavaScript engine can:
* Request for a data from a remote server.
* Display a spinner
* When the data is available, display it on the webpage.
*/

/* JS Event Loop to Prevent Blocking Function
The JavaScript engine executes a script from the top of the file and works its way down.
It creates the execution contexts, pushes, and pops functions onto 
and off the call stack in the execution phase.
If a function takes a long time to execute,
you cannot interact with the web browser during the function’s execution because the page hangs.
A function that takes a long time to complete is called a blocking function.
Technically, a blocking function blocks all the interactions on the webpage, 
such as mouse click.
An example of a blocking function is a function that calls an API from a remote server.

To prevent a blocking function from blocking other activities, 
you typically put it in a callback function for execution later. For example:
When you call the setTimeout() function, make a fetch request,
or click a button, the web browser can do these activities concurrently and asynchronously.
The setTimeout(), fetch requests, and DOM events are parts of the Web APIs of the web browser.

see link to understand (https://www.javascripttutorial.net/javascript-event-loop/)
*/


/*----------------Event Loop------------------------
Once all the normal JS code is executed and the call stack gets empty, the event loop is then triggered.
The event loop then checks for any tasks in the task queue and if there are any, 
it pushes it to the call stack and it gets executed.
*/
/* ----------------------Web API------------------------ 
Web APIs are basically a large number of powerful functions and interfaces exposed to us by the browser.
* 		Network requests
* 		DOM manipulation
* 		Local storage
* 		Bluetooth
* 		Screen Capture
* 		Location
* 		setTimeout and Timer
* 		And even console.log is also part of console web API 

console.log is web API But there is no call back involved here i.e after the console log is offloaded to the browser, 
it directly gets logged to the browser console and doesn't come back to the JS engine. 
So, we can't observe the asynchronous nature.

The Web API calls are added to the Web API Container from the Call Stack. 
These Web API calls remain inside the Web API Container until an action is triggered. 
Then their callBack Functions will be added to callCack queue
*/

/* ------------Task queue vs  Render queue vs Microtask queue------------
All will go to call Stack once the Call Stack is empty
* Task queue (Callback Queue): Here the tasks are executed one at a time and new ones are added. 

* Render queue: Once the event loop comes to the render queue, 
  it will finish everything which was existing at the beginning, 
  and if something is added after the event loop starts here, 
  they are deferred to the next render cycle.
  Rendering never happens while the engine executes a task. 
  It doesn’t matter if the task takes a long time. Changes to the DOM are painted only after the task is complete.

* Microtask queue: This queue is executed until it is exhausted. 
  So, if you run an infinite recursion of promises, 
  you will block the main thread as shown above.

----------------------difference between Task Queue and MicroTask Queue
There is no rule that all the tasks in Task Queue should be finished before moving means JS engine will jump 
from Task queue to microTask queue and then jump back to task Queue 
but in microTask queue JS engine will remain in microTask queue till finish all tasks that's why microTask queue 
can block main thread incase of infinite recursion of promises
The callback queue is handled by the JavaScript engine after it has executed all tasks in the microtask queue

* Microtask queue is processed in a separate event loop. The Callback queue is processed in the same event loop.
Microtask queue is processed in a separate event loop which means that if the main thread is blocked, the microtask queue will still be processed.

One of the advantages of a callback queue over a microtask queue is that the callback queue is processed in the same event 
loop as the main thread. This means that if the main thread is blocked, the callback queue will not be processed.

* Microtask Queue is like the Callback Queue, but Microtask Queue has higher priority.
Promise will go to call stack before setTimeout becaue Promise in microtask Queue and setTimeout in task Queue

// SetTimeout is web Api and will be in task Queue
setTimeout(function(){
  console.log("From SetTimeOut")
},0)

// Promise will be in MicroTask Queue
let p1 = new Promise((resolve, reject)=> {
  resolve("from Promise")
})
p1.then((resolve) => console.log(resolve))

https://lightmap.dev/how-does-javascript-even-work-part-2#heading-render-queue
*/

/* JS Hoisting 
During the creation phase, the JavaScript engine moves the variable 
and function declarations to the top of your code.
This feature is known as hoisting in JavaScript.

* Variable Hoisting
// let keyword in creation phase only hoist but not initialized to undefined like var
// output undefined
// console.log(hoist)
// var hoist = 10;

// give Error annot access before initialization
// console.log(hoist) // here you are at stage called temporal deadzone (you are between hoisting and initializing)
// let hoist = 10;

// output undefined
// let hoist;
// console.log(hoist)
// hoist = 10;

* Function Hoisting
*regular function has 2 syntaxes : Function decleration and function Expression
*function Decleration :
output will be 30 becaues will hoist function and move it to the top
let x = 20,
  y = 10;

let result = add(x, y);
console.log(result);

function add(a, b) {
  return a + b;
}

*function Expression:
Error (add is not a function ) because JS Hoist (var add) and intialized it to undefined and undefined is not a function
let x = 20,
  y = 10;

let result = add(x, y);
console.log(result);

var add = function(a, b) {
  return a + b;
}

Error cannot access before initialization because JS engine hoist (let add) and doesn't initialzed let 
let x = 20,
  y = 10;

let result = add(x, y);
console.log(result);

let add = function(a, b) {
  return a + b;
}
Arrow function like Function Expression
arrow functions are syntactic sugar for defining function expressions.

*/

/* Scope are three types : Global Scope , Local Scope , Block Scope 

Global Scope : outside (in Global Excution Context)
Local Scope : in Function (in Function Excution Context)
Block Scope : not just inside a function, but around any curly brackets like if statements or loops.

* A lexical scope or static scope in JavaScript refers to the accessibility of the variables,
functions, and objects based on their physical location in the source code

* Scope Chain :
The way that JavaScript resolves a variable is by looking at it in its current scope,
if it cannot find the variable, it goes up to the outer scope, which is called the scope chain.


Scope refers to the part of a program where we can access a variable. 
JavaScript allows us to nest scopes, and variables declared in outer scopes are accessible 
from all inner ones. Variables can be globally-, local-, or block-scoped.
Using lexical scope( static scope ) we can determine the scope of the variable 
just by looking at the source code. Whereas in the case of dynamic scoping 
the scope can’t be determined until the code is executed. (JS has Static Scope not Dynamic Scope)

A new lexical environment is created for each lexical scope but only when the code in 
that scope is executed. The lexical environment also has a reference to its outer lexical environment

A new lexical environment is created only for let and const declarations, not var declarations.
var declarations are added to the current lexical environment (global or function lexical environment).

A closure is a function enclosed with references to the variables in its outer scope. 
Closures allow functions to maintain connections with outer variables, 
even outside the scope of the variables.
closures do not just freeze the values of variables from a function’s outer scope 
during creation. Instead, they maintain the references throughout the closure’s lifetime.

use strict will prevent Global Variable leaks (The global scope also doesn’t have the counter variable, so the JavaScript engine creates the counter variable in the global scope.)
'use strict'
counter =10;
console.log(counter)


*/


// references
/* https://www.javascripttutorial.net/javascript-execution-context/

https://www.javascripttutorial.net/javascript-call-stack/

https://www.javascripttutorial.net/javascript-event-loop/

https://www.javascripttutorial.net/javascript-hoisting/

https://www.javascripttutorial.net/javascript-variable-scope/ 
*/

/* JS is Single-Threaded
because JS is Single-Threaded (only one command/function executing at any given time )
setTimeout will not interrupt the function foo it will wait till finish then will run even after 
more than 1 milisecond

setTimeout(function(){
  console.log("Hello World");
},1);
function foo() {
  // NOTE: don't ever do crazy long-running loops like this
  for (var i=0; i<= 1000; i++) {
      console.log(i);
  }
}
foo();

*/

/* Values Vs References in JS

* Javascript has 7 data types that are passed by value: Boolean, null, undefined, String, Number, bigint, symbol.
We’ll call these primitive types.


* Javascript has 3 data types that are passed by reference: Array, Function, and Object.
These are all technically Objects, so we’ll refer to them collectively as Objects.

Variables that are assigned a non-primitive value are given a reference to that value.
That reference points to the object’s location in memory.
The variables don’t actually contain the value.
Objects are created at some location in your computer’s memory. 
When we write arr = [], we’ve created an array in memory.
What the variable arr receives is the address, the location, of that array.

* Assigning by value vs Assigning by reference :

Assign by Value (value type variable) :
here x = y but when we change value of y will not change value of x because each x and y has a different copy of it's value
let x = 10;
let y = x;
y = 20 ;
console.log(x,y)

Assign by reference (refernce type variable) :
here arr = copyArr but when you change arr value (pushing a value) wll change copyArr because
both has same address of same array
let arr = [1]
let copyArr = arr
arr.push(2)
console.log(arr)
console.log(copyArr)

Reassign a reference :
here obj was have address of { first : "1st"} but now obj has address of { second : "2nd"}
and { first : "1st"} has no references so will be ready for garbage collector
let obj = { first : "1st"}
obj = { second : "2nd"}
console.log(obj)

equality == and === with refernce type variable :
here return true because both arr and arr2 have same address of same array
let arr = ["Hi"]
let arr2 = arr
console.log(arr === arr2) //true

here return false because each one ( arr and arr2) has different address to two different arrays even if ["Hi"]["Hi"] look like tha same
let arr = ["Hi"]
let arr2 = ["Hi"]
console.log(arr === arr2) //false

if you want to check if both array like each other you have to change them to string ( primitive value)
and you can compare between 2 primitive values by === 

JSON.stringify turns a JavaScript object into JSON text and stores that JSON text in a string
JSON.parse turns a string of JSON text into a JavaScript object

let arr = ["Hi"]
let arr2 = ["Hi"]
let arrStr = JSON.stringify(arr)
let arrStr2 = JSON.stringify(arr2)
console.log(arrStr === arrStr2) //true

------------shallow Copy and Deep Copy---------------
// Deep Copy because array assigned by reference not value
let arr1 = [1,2,3,4]
let arr2 = arr1
arr2[0] = 5;
console.log(arr1) // [5,2,3,4]

// shallow Copy
let arr1 = [1,2,3,4]
let arr2 = Array.from(arr1)
arr2[0] = 5
console.log(arr1) // [1,2,3,4]

// Methods to Shallow Copy
[1] arr.slice(0)
[2] [].concat(arr)
[3] Spread Operator
[4] Object.create()
[5] Object.assign({}, obj)
[6] Array.from(arr)

// if object has a non-primitive value of property

let obj = {
  number : 55 ,
  string : "String",
  arr : [1,2,3,4],
  object : {one : "value"}
}
// in spite of Shallow but when a value of property is non-primitive values 
//(like array and Objects) will assigned also by reference
let newObj = {...obj}
newObj.arr[0] = 5
console.log(obj) // obj.arr  [5,2,3,4]
console.log(newObj) // newObj.arr  [5,2,3,4]

// to solve this Problem use JSON.parse(JSON.strignify())
let newObj2 = JSON.parse(JSON.stringify(obj))
newObj2.arr[0] = 5
console.log(obj) // obj.arr  [1,2,3,4]
console.log(newObj2) // newObj2.arr  [5,2,3,4]

// another Exp of shallow copy

// for exp. in object we used object.assign() to create a brand new object 
// not just creating another pointer to same object like using let obj1 = obj;
// but at this exp. when we use object.assign() we are creating a new object and take 
// a shallow copy of it's content which means the property names is an Array and with
// shallow copy we are creating just a pointer to this array that's why when we changed 
// the array obj.names.push("Hussein") also changed at obj1
// when we change what names property point to this is a different story we are changing 
// property names not changing teh exisiting array so property names will be changed only at obj
// not at shallow copy obj1

let obj = {
  names : ["Mohamed","Ahmed","Soliman"],
  skills : {
    frontEnd : "JS",
    backEnd : "PHP"
  }
}
let obj1 = Object.assign({},obj)
obj.names.push("Hussein")
console.log(obj)
console.log(obj1)
console.log(obj === obj1)
obj.name = [1,2,3,4]
console.log(obj)
console.log(obj1)

----------------Host Object vs Native Object-------------
Host Objects  :  are objects supplied by a certain environment. 
They are not always the same because each environment differs and 
contains host objects that accommodates execution of ECMAScript. 
Example, browser environment supplies objects such as window. 
While a node.js/server environment supplies objects such as NodeList.

Native Objects or Built-in Objects  :  are standard built-in objects provided by Javascript. 
Native objects is sometimes referred to as ‘Global Objects’ since they are objects 
Javascript has provided natively available for use.

------------JavaScript is a multi-paradigm-------------
JavaScript is a multi-paradigm language that allows you to freely mix and match
object-oriented, procedural, and functional paradigms.

** procedural : (Normal JS)
It could be called "procedural" because we have multiple steps we execute after each other.
Exp. 
const button = document.querySelector('button');
const doSomething = () => {
  // do something...
}
button.addEventListener('click', doSomething);

** object-oriented :
The idea behind object-oriented programming (OOP) is that you organize your code 
in classes/ objects (objects are based on classes).
Your data is stored in properties, your logic in methods. 
And properties and methods that work closely together live in the same class.
Exp. 
class InputArea {
  constructor() {
    this.button = document.querySelector('button');
    this.button.addEventListener('click', doSomething);
  }
  doSomething() {
    // do something
  }
}
new InputArea();

** functional programming :
The idea behind functional programming is that you organize your code into 
multiple functions where each function works on its own.
That last part is important: Functions should be stateless and pure, 
they also shouldn't cause side-effects (e.g. manipulate the DOM).
Exp.
function findElementOnPage(elementTag) {
  return document.querySelector(elementTag);
}
function doSomething() {
  // do something
}
function connectInput() {
  const btn = findElementOnPage('button');
  btn.addEventListener('click', doSomething);
}
connectInput();

--Functional Programming contains those logics :
* Pure Function
* Immutability
* Function Composition
* Recursion
* Higher Order Function With Ramda
* Curring with Ramda

----------pure function vs impure function
Pure Function must be : Referential transparency and Side-effect free

Referential transparency: The function always gives the same return value
for the same arguments. This means that the function cannot depend on any mutable state.
A referentially transparent function is one which only depends on its input.

Side-effect free: The function cannot cause any side effects. 
Side effects may include I/O (input/output)(e.g., writing to the console or a log file), 
modifying a mutable object, reassigning a variable, etc.

// Exp. for Referential transparency ( depend only on argument)
function sum (x) {
  return x + 1
}
console.log(sum(5))

// Exp. for referential opaqueness (something outside functon can change output like variable y)
let y = 2;
function sum2 (x) {
  return x + y
}
console.log(sum2(5))

// Exp. for side effect
let x = 10;
function sideEffect() {
  x = 20;
}
sideEffect()
console.log(x) // 20

pure function ( will not effect the outer variables) :
when you pass agument to parameter it will assign it by =
here arguments a = x and b = y and because there are value type variable will not change each others
let x = 10;
let y = 20;
function pure(a , b) {
  a = 2 * a
  b = 2 * b
  console.log(a + b)
}
pure(x,y)

impure function (will effect outer variables that's called side effect) :
here we assign obj with objArg and both now has same address of same object so any change of that 
object will changed no both obj and objArg

let obj = {
  theName : "Soliman",
  age : 33
}

function impure(objArg) {
  objArg.age = 34
  return objArg
}

console.log(impure(obj)) //age 34
console.log(obj) //age 34

* how to make impure function to pure function
here we create a new object with new address (we transfered obj to string then transfered again to object)
now obj and newObj each one has it's own address to different two objects when you change 
a properity of one will not affect the other

let obj = {
  theName : "Soliman",
  age : 33
}

function impure(objArg) {
  let newObj = JSON.parse(JSON.stringify(objArg))
  newObj.age = 34
  return newObj
}

console.log(impure(obj)) // age 34
console.log(obj) // age 33

** test ** 
function changeAgeAndReference(person) {
    person.age = 25;
    // when you reassign person to another object will not now has same address like peronObj1 
    // so will not change the value of personObj1
    person = {
        name: 'John',
        age: 50
    };
    
    return person;
}
var personObj1 = {
    name: 'Alex',
    age: 30
};
var personObj2 = changeAgeAndReference(personObj1);
console.log(personObj1); // Alex 25
console.log(personObj2); // John 50

* you can prevent side-effect by using const with variables and Object.freeze() with Objects
// Using Const instead of usind let or var
const x =10;
function pure () {
  x = 20
}
pure() // ERROR

// Object.freeze() with Objects
const obj = {
  x : 10
}
Object.freeze(obj)
function pure () {
  obj.x = 20;
}
pure()
console.log(obj.x)

** generally it's better to use immutator method instead of mutator methods
--Some Exp.:
* instead of array.push() use array.concat() or spread operator
* instead of array.pop() use array.slice(0,-1)
* instead of array.shift() use array.slice(1)
* instead of array.unshift() use [].concat(array)
* instead of array.sort(callBackFunction) use const newArray = R.sort(callBackFunction, array) (R is Ramda)
* instead of array.sort(callBackFunction) use const newArray = [...array].sort(callBackFunction)
* instead of array.reverse() use const newArray = R.reverse() (R is Ramda)
* instead of array.reverse() use const newArray = [...array].reverse()
* you can almost use spread operator and slice compination to transfere mutable method to immutable

*you can use also spread operator : 
// using newArr.splice(1,1) will change orignal array arr
let arr = [1,2,3,4]
newArr = arr
newArr.splice(1,1)
console.log(arr)
console.log(newArr)

// using spread operator and slice instead of splice
let arr = [1,2,3,4]
newArr = [...arr.slice(0,1),...arr.slice(2)]
console.log(arr)
console.log(newArr)

*you can also use Object.assign ( array also is object) :
let arr = [1,2,3,4]
let arr2 = Object.assign([],arr)
arr2.splice(0,1)
console.log(arr)
console.log(arr2)


----Ramda is a library of functions designed to make functional programming in JavaScript
easy and powerful without making it any less like JavaScript.
https://youtu.be/r_MZ0xCv1_A

** with Map and Set
// Map
let map = new Map([
  [1, "One"],
  [2, "Two"],
  [3, "Three"]
])

* instead of using map.set(4, "Four") use let map2 = new Map ([...map, [4, "Four"]]) 
* instead of using map.delete(1) use let map2 = new Map ([...map].filter(([key]) => key !== 1))
* instead of using map.clear() use let map2 = new Map()

// set
let set = new Set(["A", "B", "C"])

* instead of using set.add("D") use let set2 = new Set([...set, "D"])
* instead of using set.delete("B") use let set2 = new Set([...set].filter((key) => key !== "B"))
* instead of using set.clear() use let set2 = new Set()

// You can use also Immutable.js
Immutable. js is a library that supports an immutable data structure.
It means that once created data cannot be changed. 
It makes maintaining immutable data structures easier and more efficient. 
The tool supports data structure like: List, Map, Set and also structures that are not implemented in .


--------- mutable and immutable data type  (changeable and not chageable)

/* 
Mutable is a type of variable that can be changed. 
In JavaScript, only objects and arrays are mutable, not primitive values.

A mutable object is an object whose state can be modified after it is created.
Immutables are the objects whose state cannot be changed once the object is created.

Strings and Numbers (primitive values) are immutable

By default, objects are mutable. This means once they're created, 
you can add a new property to them, modify the value of an existing property, or delete a property.

When an object is immutable, you can't add a new property to it, modify it, 
or delete an existing property. There is no way even to extend it.

const is not immutable const prevent reassign 
*/
/*
// Exp. of mutable in JS
// because array assigned by reference not value so arr and arr2 have same address to same array
// once you make change to arr , arr2 also changes because they both point to same array
// let arr = [1,2]
// let arr2 = arr
// arr2.push(3)
// console.log(arr)
// console.log(arr2)
// console.log(arr === arr2)

// in Object also same Problem
// let obj = {theName : "Soliman"}
// let obj2 = obj
// obj2.theName = "Hussein"
// console.log(obj)
// console.log(obj2)
// console.log(obj === obj2)

// Exp. of immutable in JS
// using concat to create new Array with different address 
// use Array method that return a new Array like map and filter better than push , pop or sort
// let arr = [1,2]
// let arr2 = arr.concat(3)
// console.log(arr)
// console.log(arr2)
// console.log(arr === arr2)


// using Object.assign() to create new Object with different address
// let obj = {theName : "Soliman"}
// let obj2 = Object.assign({}, obj, {theName : "Hussein"})
// console.log(obj)
// console.log(obj2)
// console.log(obj === obj2)

// using Object.freeze (convert object to immutable)
let obj = {theName : "Soliman"}
let obj2 = obj
Object.freeze(obj)
obj2.theName = "hussein"
console.log(obj) // Soliman
console.log(obj2) // Soliman
console.log(obj === obj2)

// Using Object.seal() ( mix ) you can not add property but you can change it
let obj = {
  name : "Mohamed",
  last : "Soliman"
}
Object.seal(obj)
obj.middle = "Ahmed" // can not add property
console.log(obj)
obj.last = "Hussein"
console.log(obj) // can change property

// -------Function Composition-------
// higer order function
function h (x) {
  x = x + 1
  return function g () {
    x = x * x
    return function  f () { 
      return x.toString()
    }
  }
}
console.log(h(1)()())

// function composition
function h (x) {
  return x = x + 1
}
function g (x) {
  return x = x * x
}
function f(x) {
  return x.toString()
}
console.log(f(g(h(1))))

// using Ramda
function h (x) {
  return x = x + 1
}
function g (x) {
  return x = x * x
}
function f(x) {
  return x.toString()
}
let composite = R.compose(f,g,h)
console.log(composite(1))
*/
/* ------recursion ------ 
* function call itself
consists of 2 parts :
[1] Base Case ( stopping condition)
[2] recursive call to itself
for Exp. factorial 4 (4! = 4 * 3 * 2 * 1)

* we can use for loop : 
function factorial(x) {
  let y = 1
  for ( let i = 1; i <= x ; i ++) {
    y *= i
  }
  return y
}
console.log(factorial(4))

* we can use recursion
function rec(n) {
  // Base case
  if (n === 1) {
    return 1;
  }else{
    // recursive call to itself
    return n * rec(n-1)
  }
}
console.log(rec(4))
// will cause Error Maximun call Stack size Exceed Each call to recursiveFactorial causes a new frame to be put on the stack. 
console.log(rec(20000))

another exp. of simple loop
let count = 0;
function rec() {
  if(count < 10){
    console.log(count)
    count++
    rec()
  }
}

another exp. of countdown
function countDown(num){
  console.log("x".repeat(num))
  num = num - 1
  if (num > 0){
    countDown(num)
  }
}
countDown(10)

// using PTC ( proper tail calls optimization) to solve  error of Error Maximun call Stack (not supported by all browsers)
// after the product has been updated, the browser can throw out that stack frame
function rec(n , product = 1) {
  // Base case
  if (n === 1) {
    return product;
  }
  // recursive call to itself
  return rec(n-1, product * n)
}
console.log(rec(20000))

// reference (https://opensource.com/article/17/6/functional-javascript)
// reference (https://youtu.be/LteNqj4DFD8 )

*/

// First class Function
/*
functions in JS treated like other variables.
function can be assigned to any other variables 
or passed as an argument or can be returned by another function
JavaScript treat function as a first-class-citizens.
This means that functions are simply a value and are just another type of object.
*/
// exp who to pass function as argument 
// function greet (name) {
//   return `Hi, ${name}`
// }
// function greetFinal (greeting, welcome , theName) {
//   console.log(`${greeting(theName)} The Message is ${welcome}`)
// }
// greetFinal(greet,"You Are Welcome", "Soliman")

// exp. of Functional Programming
// const developers = [
//   {
//     name: "James",
//     yearsOfExperience: 2,
//     language: "HTML",
//   },
//   {
//     name: "Adam",
//     yearsOfExperience: 5,
//     language: "CSS",
//   },
//   {
//     name: "Will",
//     yearsOfExperience: 1,
//     language: "javascript",
//   },
//   {
//     name: "Sam",
//     yearsOfExperience: 7,
//     language: "Python",
//   },
// ];

// function listDevelopers() {
//   developers.forEach((developer) => {
//     const { name, yearsOfExperience, language } = developer;
//     console.log(
//       `${name} has ${yearsOfExperience} years of experience in ${language}`
//     );
//   });
// }
// listDevelopers()


// -----------Invoking Function ------------
// invoking function means call function
// we will use invoke, because a JavaScript function can be invoked without being called.
// The difference is semantic and subtle.
// When you call a function, you are directly telling it to run.
// When you invoke a function, you are letting something run it or call it indirectly like fn.call() or fn.apply() 
// or passing this function as argument to another function func1(func){func()}.

// there is 2 main functions Regular and Arrow

// Regular Function have 2 main Syntax:

// 1st Function Decleraion
// function hello() {
//   console.log("Hello")
// }
// hello()

// 2nd Function Expression
// let hello = function () {
//   console.log("Hello")
// }
// hello()

// Arrow Function 
// let hello = () => console.log("Hello")
// // hello()


// --------------------------------Arrow functions ---------------------------------------
/*
- reference (https://www.section.io/engineering-education/how-to-use-javascript-arrow-functions-and-this-keyword/)
- Using the arrow function, curly braces, parenthesis, function, and return keywords become optional.

const whoAmI = {
  name: 'Leslie Knope',
  regularFunction: function() {
    console.log(this.name)
  },
  arrowFunction: () => {
    console.log(this.name)
  },
}

whoAmI.regularFunction() // "Leslie Knope"
whoAmI.arrowFunction() // undefined
*/
// -------difference between regular and arrow function
/*
https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/

- The arrow function doesn't define its own execution context that's why doesn't have it's own this.
- The arrow function cannot be used as Constructor (this is inherited from the enclosing (lexical) scope)
- The arrow functions are this-less, arguments-less, new.target-less and super-less.
 */

// [1] this in an arrow function is inherited from the enclosing (lexical) scope.

// // ----arrow Function
// const myObject = {
//   myMethod() {
//     console.log(this); // logs myObject
//     const callback = () => {
//       console.log(this); // logs myObject
//     };
//     callback()
//   }
// };
// myObject.myMethod(); 

// // ----Regular Function
// const myObject2 = {
//   myMethod() {
//     console.log(this); // logs myObject
//     const callback = function (){
//       console.log(this); // logs window object
//     };
//     callback()
//   }
// };
// myObject2.myMethod(); 

// [2] arrow function cannot be used as Constructor

// // -----arrow Function
// const Car = (color) => {
//   this.color = color;
// };
// const redCar = new Car('red'); // TypeError: Car is not a constructor

// // ----- regular Function
// const Car2 = function (color){
//   this.color = color;
// };
// const redCar2 = new Car2('red'); // no Error

// [3] arrow function does not have arguments special keyword

// // ---arrow Function ( but you can use rest parameters to get array of arguments)
// let arr = (...args) => {
//   console.log(args)
// }
// arr(1,2)

// // -----regular Function

// let arr2 = function (a,b){
//   console.log(arguments)
// }
// arr2(1,2)

// [4] method inside object invoked as callback function (here arrow function is better)
/*
- in regular Function will output undefined because we use setTimeout which invoke method outside 
class instance and this keyword will be global or window 

- in Arrow Function will output Batman because arrow function get this lexically from class instance
No matter how or where being executed, this value inside of an arrow function 
always equals this value from the outer function. 
In other words, the arrow function resolves this lexically.
 */

// ----arrow Function
// class Hero {
//   constructor(heroName) {
//     this.heroName = heroName;
//   }
//   logName = () => {
//     console.log(this.heroName);
//   }
// }
// const batman = new Hero('Batman');
// setTimeout(batman.logName,1000) // batman

// ----regular Function

// class Hero2 {
//   constructor(heroName) {
//     this.heroName = heroName;
//   }
//   logName = function() {
//     console.log(this);
//   }
//   // logName = function() {
//   //   console.log(this.heroName);
//   // }.bind(this)
// }
// const batman2 = new Hero2('Batman');
// setTimeout(batman2.logName,1000) 
// // to solve this problem add bind here or inside consructor
// setTimeout(batman2.logName.bind(batman2),1000) 

// **** note : If a function has been used as a high order function (passed as an argument) 
// or passed to variable the scope of this gets lost.

// function Hero2(heroName) {
//   this.heroName = heroName;
// }
// Hero2.prototype.logName = function() {
//   console.log(this);
// }
// batman2 = new Hero2("Batman")
// let seperated2 = batman2.logName
// seperated2() // this here is window Object

// class Hero2 {
//   constructor(heroName) {
//     this.heroName = heroName;
//   }
//   logName = function() {
//     console.log(this);
//   }
// }
// const batman2 = new Hero2('Batman');
// let seperated2 = batman2.logName
// seperated2() // this here is undefined (all the code inside a class automatically executes in the strict mode and this in strict mode will be undefined not window object)

// [5] indirect invocation 
/*
Contrary to a regular function, the indirect invocation of an arrow function using 
myArrowFunc.call(thisVal) or myArrowFunc.apply(thisVal) doesn't change the value of 
this: the context value is always resolved lexically.
*/

// ----------this of arrow function inside ( object - constructor - class)
// // arrow function inside Object ( this in window)
// let obj = {
//   arrowFunc : _ => this
// }
// console.log(obj.arrowFunc())

// // arrow function inside constructor (this is instance of Obj)
// function Obj(){
//   this.arrowFunc = _ => this;
// }
// let instObj = new Obj()
// console.log(instObj.arrowFunc())

// // arrow function inside class (syntactical sugar of constructor that's why this is instance of Obj2  )
// class Obj2 {
//   constructor(){
//     this.arrowFunc = _ => this
//   }
// }
// let instObj2 = new Obj2()
// console.log(instObj2.arrowFunc())

// --------this of arrow function inside addEventListener inside class
// const button = document.createElement('button')
// button.textContent = 'Click me'
// document.body.append(button)

// class Display {
//   constructor() {
//     this.buttonText = 'New text'
    
//     // button.addEventListener('click', function(event) {
//     //   // regular function this will be button
//     //   event.target.textContent = this.buttonText
//     //   console.log(this) // button
//     // })

//     button.addEventListener('click', event => {
//       // we used arrow function because we want this to refer to class instance not to button
//       event.target.textContent = this.buttonText
//       console.log(this) // class instance
//     })

//   }
// }
// new Display()

//--------------------IIFE (immediately Invoked Function Expression)------------------

// (function f(a=3 ,b=2 ) {
//   console.log(a + b);
// })();

// Arrow IIFE
// ((a =2 ,b=3) => console.log(a+b))();


// IIFEs are very useful because they don’t pollute the global object,
// and they are a simple way to isolate variables declarations.

// (function() {
//   let a = 20;
//   console.log(a)
// })();

// let a = 10;
// console.log(a)

// ----------------closure 
// closure is the inner function that has access to its outer function scope
// even after the outer function has returned(because of Reference to the parent lexical environment). 
// This means a closure can remember and access variables and arguments of its outer 
// function even after the function returned

// function person() {
//   let name = 'Peter';
  
//   return function displayName() {
//     console.log(name);
//   };
// }
// let peter = person();
// // here Closure function ( displayName) remember variable name even after the function person returned
// peter(); // prints 'Peter'


//why to use Closure Function 
// 1st Example we invoke closure function (inner) only and will remember the variable counter
// and when we invoke the inner function again will not reset variable counter to 0 each time 
// because we invoke inner only without count function

// function count () {
//   let counter = 0;
//   return function inner () {
//     return counter++
//   }
// }
// let result = count()

// here no closure function and will reset variable counter to 0 each time we invoke the function
// function count2() {
//   let counter = 0;
//   return counter++
// }


// console.log(result()) // 0
// console.log(result()) // 1
// console.log(result()) // 2
// console.log(count2()) // 0
// console.log(count2()) // 0
// console.log(count2()) // 0

// use case of IIFE and Closures (link below)
// https://javascript.plainenglish.io/4-practical-use-cases-for-iifes-in-javascript-6481dcb0ba7d

// const user = (function() {
//   let name = "anonymous";
//   return {
//     getName:  _=> name,
//     setName: newName => name = newName
//   };
// })();
// console.log(user.getName()) // anonymous
// user.setName("Amy");
// console.log(user.getName()); // Amy

// withou IIFE
// let inv = user()
// console.log(inv.getName()) // anonymous
// inv.setName("Amy");
// console.log(inv.getName()); // Amy

// without IIFE
// const user = function() {
//   let fname = "anonymous";
//   return function (a) {
//     fname = a;
//     return fname
//   }
// };

// let result = user()
// console.log(result("soliman"))

// //  _ mean igonre parameter ( dont write Argument)
// let fun = _ => console.log("Hello,World")
// fun()


// ------------------------------This -------------------------
// This is all about where a function is invoked ( in window object or specific object)
// “this” is a regular argument provided at the time your function is invoked 
// Under the hood will be like this function.call(window object or specific object)
// In an object method, this refers to the object
// Alone, this refers to the global object (window) but in strict mode will be undefined
// In a function, this refers to the global object. (because if function does not belong to any Object will belong to global Object) (myFunction() === window.myFunction())
// In an Arrow functions this refer to global Object ( even if it's belong to specific Object) beacuse it do not have it's Excution context so doesn't have own this
// In a function, in strict mode, this is undefined.
// In an event, this refers to the element that received the event but in arrow function to window object.
// Methods like call(), apply(), and bind() can refer this to any object but in arrow function this can not be changed by call,bind or apply.
// for nested function ( inner function inside outer function inside object ) this refer to window object ( to solve this problem use arrow function or bind() or apply() or bind)

// in event (regular and arrow functions)


// refernece (https://gist.github.com/zcaceres/2a4ac91f9f42ec0ef9cd0d18e4e71262)
// [1] This inside Object :  refer to Person Object
// const person = {
//   firstName: "John",
//   lastName : "Doe",
//   id: 5555,
//   fullName : function() {
//     return this.firstName + " " + this.lastName;
//   }
//   };
// console.log(person.fullName())

// [2] This inside Event : refer to element that received the event but in arrow refer to window
// const button = document.createElement('button')
// button.textContent = 'Click me'
// document.body.append(button)

// button.addEventListener("click",(event)=> console.log(this)) // window
// button.addEventListener("click",function (event){console.log(this)}) // button

// [3] This inside nested function
// let obj = {
//   theName : "Soliman",
//   age : 33, 
//   fun : function getThis () {
//     console.log( ` This from outer function is ${this}`); // obj
//     function getThisInner() {
//       console.log(` This from inner function is ${this}`) // window
//     }
//     getThisInner()
//   }
// }

// obj.fun()

// using Arrow Function will force this to refer to object because Arrow function does not have
// binding to it's own this and inherit it from outer function
// let obj = {
//   theName : "Soliman",
//   age : 33, 
//   fun : function getThis () {
//     console.log( ` This from outer function is ${this}`); // obj
//     let arrow = _ => console.log(` This from inner function is ${this}`) // obj
//     arrow()
//   }
// }

// obj.fun()

// [4] This inside Arrow function inside constructor
/* 
*** My Explanation : 
new keyword will bind this to instance object and this now inside Constructor function
with new Excution context (new Scope) and arrow function inside Constructor Function
will resolve this Lexically 

*** internet Explanation : 
Why this inside Arrow function inside constructor refer to created Object?
Instance Objects are powerful because they are derived from a function, 
they provide private scope when they are created, and expressions can be executed on instantiation.
But A JavaScript object literal does not, by nature, provide private scope.
*/

// function User(fName,lName,age){
//   this.fName = fName;
//   this.lName = lName;
//   this.age = age;
//   this.country = "EGYPT"
//   this.fullName = _ => `Full Name: ${this.fName} ${this.lName}`
// }
// let inst = new User("Mohamed","Hussein",34)
// console.log(inst.fullName())

// [5] This inside IIFE
// let myObj = {
//   name : "Soliman",
//   func: (function parent(){
//     console.log(this) // window
//     let child = () => console.log(this.name) // this resolved lexically (window)
//     child()
//   })()
// }
// console.log(window.name)
// console.log(myObj.name)
// IIFE will excute automatically inside global Scope and will output empty String 
/* 
The reason you get "" rather than undefined is that you're using loose mode,
and so this refers to the global object, which is the window on browsers, 
and the window has a name property (the name of the current window) which is usually empty ("").
last exp. excute in this way :
let parent = (function (){
  let child = () => console.log(this.name)
  child()
})()
let myObj = {
  name : "Soliman",
  func : parent
}
console.log(window.name)
console.log(myObj.name)
*/

/* [6] This inside setTimeout and addEventListener
setTimeout is web api and will go to callback queue once call stack is empty will go to call stack 
and will be excuted in global context.

in first exp. 1st this refer to obj - 2nd this refer to window because setTimeout will be excuted 
in global context once call stack is empty

in second exp. 1st this refer to btn - 2nd this refer to window same reasone of first exp.

in third exp. 1st this refer to btn - 2nd this refer to btn also because arrow function
doesn't have own Excution Context and take this from lexical context and 
this of lexcial context is btn from addEventListener 
*/

// let obj = {
//   name : "Soliman",
//   func : function getThis(){
//     console.log(this)
//     setTimeout(function(){
//       console.log(this)
//     },1000)
//   }
// }
// obj.func() //output obj - window


// let btn = document.querySelector(".btn")
// let getThis = function (){
//   console.log(this) // window
//   setTimeout(function(){
//     console.log(this) // window
//   },1000)
// }

// let getThisArrow = function (){
//   console.log(this)
//   setTimeout(() => {
//     console.log(this)
//   },1000)
// }
// btn.addEventListener("click", getThis) // output btn - window
// btn.addEventListener("click", getThisArrow) // output btn  - btn


// [6] This with Explicit Binding: this refer to object passed in apply , call or bind (objFun.apply(obj))
// let obj = {
//   theName : "Soliman",
//   age : 33,
// }
// function objFun () {
//   console.log(`My Name is ${this.theName} and my age is ${this.age}`)
// }
// objFun.apply(obj)

// using apply() to bind this to inner function ( Explicit Binding)
// let obj = {
//   theName : "Soliman",
//   age : 33, 
//   fun : function getThis () {
//     console.log( ` This from outer function is ${this}`);
//     function getThisInner() {
//       console.log(` This from inner function is ${this}`)
//     }
//     getThisInner.apply(this)
//   }
// }

// obj.fun()
// using call() to bind this to inner function ( Explicit Binding)
// let obj = {
//   theName : "Soliman",
//   age : 33, 
//   fun : function getThis () {
//     console.log( ` This from outer function is ${this}`);
//     function getThisInner() {
//       console.log(` This from inner function is ${this}`)
//     }
//     getThisInner.call(this)
//   }
// }

// obj.fun()

// using bind() to bind this to inner function ( Explicit Binding)
// let obj = {
//   theName : "Soliman",
//   age : 33, 
//   fun : function getThis () {
//     console.log( ` This from outer function is ${this}`);
//     function getThisInner() {
//       console.log(` This from inner function is ${this}`)
//     }
//     let invokeBind = getThisInner.bind(this)
//     invokeBind()
//   }
// }
// obj.fun()

// [6] This with Implicit Binding : Implicit Binding (function inside object or use constructor to create new Object and this refer to new object)
// with implicit this will refer to object before dot ( obj.doStuff , obj.func)

// [a] inside function
// let obj = {
//   theName : "Soliman",
//   age : 33,
//   func : function () {
//     console.log(`My Name is ${this.theName} and my age is ${this.age}`)
//   }
// }
// obj.func()

// [b] inside constructor
// var MyObject = function (){
//   this.name = 'MyObjectName';
//   this.myProperty = 'property';
// };

// MyObject.prototype.doStuff = function (action) {
//   console.log(this.name + ' is ' + action + '!');
// }

// var obj = new MyObject();
// obj.doStuff('awesome');

// -------------------------------setTimeout--------------------------------
/*The specified amount of time (or the delay) is not the guaranteed time to execution,
but rather the minimum time to execution.
The callbacks you pass to these functions go to callback queue after delay and 
will go to main stack only when the stack on the main thread is empty.
As a consequence, code like setTimeout(fn, 0) will execute as soon as the stack is empty,
not immediately. If you execute code like setTimeout(fn, 0) 
but then immediately after run a loop that counts from 1 to 10 billion,
your callback will be executed after a few seconds. */

// -----setTimeout with bind
// because setTimeout excuted in seperate excution context so this will refer to window Object
// not refer to myArray as inside myArray.myMethod to solve this problem use bind
// myArray = ['zero', 'one', 'two'];
// myArray.myMethod = function (sProperty) {
//     console.log(arguments.length > 0 ? this[sProperty] : this);
// };
// myArray.myMethod(); // prints "zero,one,two"
// myArray.myMethod(1); // prints "one"
// setTimeout(myArray.myMethod, 1000); // prints "[object Window]" after 1 second
// setTimeout(myArray.myMethod, 1000, "1"); // prints "undefined" after 1 second
// setTimeout(myArray.myMethod.bind(myArray), 1000); // prints myArray
// setTimeout(myArray.myMethod.bind(myArray), 1000, "1"); // prints "one"

// ------------------Constructor ---------------

/* 
A constructor is a special function that creates and initializes an object instance of a class.
In JavaScript, a constructor gets called when an object is created using the new keyword.
The purpose of a constructor is to create a new object and set values for any existing object properties.
When the this keyword is used in a constructor, it refers to the newly created object

When a constructor gets invoked in JavaScript, the following sequence of operations take place:
* A new empty object gets created.
* The this keyword begins to refer to the new object and it becomes the current instance object.
* The new object is then returned as the return value of the constructor.

newObject = function () {
  this.theName = "soliman"
  console.log(this)
}
newObject() // window object because a constructor not called yet
let obj = new newObject // newObject instance because a constructor gets called when an object is created using the new keyword.
console.log(obj instanceof newObject) // true

Constructor with Parameters
A constructor can also have parameters:
function User (name, age) {
    this.name = name;
    this.age = age;
}
here arguments are passed to the constructor during object creation. 
This allows each object to have different property values.
var user1 = new User('Bob', 25);
var user2 = new User('Alice', 27);
console.log(user2.age)

Object Prototype
Properties and methods can be added to a constructor using a prototype:
*add properity

function User () {
  this.thename = "solimaaan";
}
User.prototype.age = 25
let newUser = new User
console.log(newUser.age)

*add function
function User () {
  this.thename = "solimaaan";
}
User.prototype.age = 25
User.prototype.func = function () {
  return(this.age)
}
let newUser = new User
console.log(newUser.func())
*/

// ---------------Strict Mode------
// Strict mode makes it easier to write "secure" JavaScript.
// Strict mode changes previously accepted "bad syntax" into real errors.
// As an example, in normal JavaScript, mistyping a variable name creates a new global variable.
// In strict mode, this will throw an error, making it impossible to accidentally create a global variable


// 1- Using a variable, without declaring it, is not allowed:

// (function f() {
//   "use strict";
//   x = 2;
// })();

// without strict mode you can access x outside the function (var , let & const are function scope)
// but here (without strict mode) js will search for variable x inside function if not found
// search in global scope not found then will add x to global object

// 2- Using an object, without declaring it, is not allowed:

// (function() {
//   "use strict";
//   x = {p1:10, p2:20};
//   console.log(x.p1)
// })();

// 3- Deleting a variable (or object) (or function) is not allowed.
// delete operator is used only to delete Object properites

// in both cases will not delete variable 
// (delete operator is used only to delete Object properites not variabels) 
// but with strict mode will throw an Error
// (function(){
//   "use strict";
//   let x = 10;
//   delete x;
//   console.log(x)
// })();

// in both cases undefined (will delete property)
// (function f(){
//   "use strict";
//   let x = {
//     a : 10,
//     b: 20
//   }
//   delete x.a;
//   console.log(x.a)
// })();


// 4- Duplicate Parameter name is not allowed:

// (function f(a ,a ,b ) {
//   "use strict";
//   console.log(a + b);
// })(2,3,3);

// 5- Octal numeric literals are not allowed:

// (function(){
//   "use strict";
//   let x = 010;
//   console.log(x)
// })()

// 6- Octal escape characters are not allowed:

// (function(){
//   "use strict";
//   let x = "\010";
//   console.log(x)
// })()

// 7-  Writing to a read-only property is not allowed: (Silent Error)
// (function f() {
//   "use strict";
//   let obj = {
//     y : 90
//   };
//   Object.defineProperty(obj, "y", {writable: false});
//   obj.y =100;
//   console.log(obj.y);
// })();

// 8- Writing to a get-only property is not allowed:

// (function() {
//   "use strict";
//   const obj = {get x() {return 0} };
//   obj.x = 3.14;
// })();

// 9-  Deleting an undeletable property is not allowed:

// (function() {
//   "use strict";
//   delete Object.prototype;
// })();

// 10- The word eval cannot be used as a variable:

// (function(){
//   "use strict";
//   let eval = 3.14;
// })();

// 11- The word arguments cannot be used as a variable:

// (function () {
//   "use strict";
//   let arguments = 3.14;
// })();

// 12- The with statement (deprecated) is not allowed:

// Allows properties of an object to be treated as local variables within a statement.
// "use strict";
// var obj = {a: 1,b: 2, c: 3};
// // more "tedious" to repeat "obj"
// obj.a = 2;
// obj.b = 3;
// obj.c = 4;
// // "easier" short-hand
// with (obj) {
//     a = 3;
//     b = 4;
//     c = 5;
// }
// console.log(obj.a)

// 13- For security reasons, eval() is not allowed to create variables in the scope from which it was called:

// (function() {
//   "use strict";
//   eval ("let x = 2");
//   alert (x);
// })()

// eval It is JavaScirpt's global function, which evaluates the specified string as JavaScript code and executes it.


// 14-  The this keyword in functions behaves differently in strict mode.
// The this keyword refers to the object that called the function.
// If the object is not specified, functions in strict mode will return undefined and functions in normal mode will return the global object (window):

// (function() {
// "use strict";
//   console.log(this)
// })();

// 15- Keywords reserved for future JavaScript versions can NOT be used as variable names in strict mode.
// These are:
// * implements
// * interface
// * let
// * package
// * private
// * protected
// * public
// * static
// * yield

// (function(){
//   "use strict";
//   let public = 1500;
// })();


// Eval 
// eval It is JavaScirpt's global function, 
// which evaluates the specified string as JavaScript code and executes it.
// If the argument is an expression, eval() evaluates the expression.
// If the argument is one or more JavaScript statements, eval() executes the statements.


// evaluating Expression
// let x = 10;
// let y = 20;
// let text = "x * y";
// let result = eval(text);
// console.log(result)


// Excute Statment
// var x =0;
// var str = "if( x === 0) {'sunday'} else {'Monday'}; "
// console.log(eval(str))

/* -----------------Expressions and Statments--------------------
In general, an expression is a snippet of code that evaluates to a value.
A statement is a snippet of code that performs an action.
Easy way to know is it expression or statment use console.log()
console.log(expression) //value 
console.log(statment) //Error 
-function arguments must be only expression

Expressions EXP. :

* Arithmetic Expressions 
10
10+3 

* String Expression
"Hello"
"Hello" + "World"

* Logical Expression ( evaluate to Boolean value)
10 > 9
10 < 20
a === 20 && b === 20

* Primary Expression ( stand alone)
"hello World"
23
true
sum ( varaible)
this

* Left hand side Expressions
i = 10; // i is expression
var obj = {} // obj is expression  _ var is not part of the expression.
obj.x = 10 // obj.x is expression
console.log(obj.x) 

* Assignment Expression :
a = 1 is assignment expression & b = ( a = 1) is also assignment expression but var is not part of the expression.
var b = ( a = 1)

* function 
-function can be expression or statment:
* function hello (){}  // Function Declaration ( statment)
* let fun = function () {}  or let fun = function hello() {} // Function Expression
- difference between function expression and statment is :
> function Expression excuted once you reach it's line of code and assign it's return value to variable
> function Declaration ( statment) you have to invoke it separatly like foo()
-that's why with IIFE you should write parenteses (function (){})() 
because JS engine dont know if it function Expression (can be with name or not) or function decleration 
alwayes expression is inside parenteses 

Statment EXP. :

* Decleration Statment
var x = 10; (declare variable )
function hello () {} ( function declaration)

* Expression Statment
you can not use statment in the place of Expression

var a = var b ( statment in the place of Expression) // Error
var a = ( b = 10) ( assignment Expression in place of Expression)

stand alone Expression can be used as Expression and Statment
sum;

* Conditional Statment
excute statments based on the value of Expression

if (expression) 
  statment1
else
  statment2

* Loops and Jumps Statments:
Jump statements are used to make the JavaScript interpreter jump to a specific location within the program.
Loop like while , do/while , for, for-in
Jump like Break , continue , return , throw

*/

// reference link (https://medium.com/launch-school/javascript-expressions-and-statements-4d32ac9c0e74)

// ------------------------------function composition----------------------
/* 

Function composition is the process of combining two or more functions 
to produce a new function. Composing functions together is like snapping together 
a series of pipes for our data to flow through.

const double = x => x * 2
const square = x => x * x
// Tradition 
var output1 = double(2);
var output2 = square(output1);
console.log(output2);
// composition
var output_final = square(double(2));
console.log(output_final);

*/
// -----------------Strong reference and weak reference----------------
/*
The key difference to note is that a strong reference prevents an object 
from garbage collection while a weak one will not.
By default, JavaScript uses strong references for all of its references 
and the only way to use weak references is to use either a WeakMap or a WeakSet.

** Strong Reference :
let myName = {theName: "Soliman"}
let arr = [myName]
myName = null 
console.log(myName) // null 
console.log(arr[0]) //{theName: "Soliman"} 
because of strong reference between arr and Object myName cant be garbage collected

** Weak Reference : 
let weak = new WeakMap()
let myName = {theName : "Soliman"}
weak.set(myName, "OK")
console.log(weak)
myName = null
console.log(weak) // should return weakMap(0) but garbage collecter not work immediatly
 */


// --------Challenge--------

// let myString = "1,2,3,EE,l,z,e,r,o,_,W,e,b,_,S,c,h,o,o,l,2,0,Z";
// let solution = myString.split(",").filter((el) => isNaN(el)).map((el,index) => el.length > index ? el[index] : el).join("").split("_").reduce((acc, current) => `${acc} ${current}`).slice("", -true)
// console.log(solution);

// --------End Challenge--------

// --------------Object------------------
// you can Create Object by constructor ( usefull for Creating multiple Objects )
// or Object literal ( usefull for creating Single Object)

// Each object created using a constructor is unique. 
// Properties can be added or removed from an object without affecting another one created 
// using the same constructor.

// an object is built using an object literal,
// any changes made to the variable that is assigned the object value 
// will change the original object. ( becuase of reference )

// you can create Object in 4 ways
/* 
* Constructor (built-in or user-defined)
* literal (normal)
* Object.create()
* Object.assign()
* ES6 Classes
*/

// [1] constructor 
// [a] built in Object constructor function
// let user = new Object({
//   age : 20,
// }) 
// user.age = 38
// user["country"] = "Egypt"
// console.log(user);
// // add later by dot notaion or bracket notation
// user.sayHello = function () {
//   return `Hello`
// }
// console.log(user.sayHello())
// [b] user defined constructor function 
// function UserName() {
//   this.lname = "soliman";
//   this.age = 33;
// }
// let user = new UserName();
// let user2 = new UserName();
// user2.age = 34;
// console.log(user.age) // 33
// console.log(user2.age) //34

// [2] literal
// let userName = {
//   lname : "soliman",
//   age : 33
// }
// let user = userName;
// let user2 = userName;
// user2.age = 34;
// console.log(user.age) //34
// console.log(user2.age) //34


// let myVar = "theAge";

// let user = {
//   // Properites
//   theName : "Osama",
//   theAge : 38,
//   "country-of" : "Egypt",
//   // Methods
//   sayHello: function (){
//     return `Hello`
//   }
// }

// console.log(user.sayHello()) //Dot notation
// console.log(user["country-of"]) //Bracet Notation
// console.log(user["theName"]) //Bracet Notation
// console.log(user.theAge)
// console.log(user[myVar])

// Nested Object

// let user = {
//   Name : "Osama",
//   lastName : "ahmed",
//   age : 38,
//   skills: ["HTML", "CSS", "JS"],
//   availabe : false,
//   addresses : {
//     KSA : "Jeddah",
//     egypt : {
//       one : "Cairo",
//       two : "Alex",
//     },
//   } ,
//   checkAv : function() {
//     if (this.availabe === true) {
//       return `Free`;
//     } else {
//       return `Not Free`;
//     }
//   },
//   fullName : function(){
//     return this.Name + " " +this.lastName
//   }
// };

// console.log(user.Name);
// console.log(user.age);
// console.log(user.skills.join(" | "));
// console.log(user.skills[2]);
// console.log(user.addresses.egypt.one);
// console.log(user["addresses"].egypt.one);
// console.log(user["addresses"]["egypt"]["one"]);
// console.log(user.checkAv());
// console.log(user.fullName());

// [3] Create Object with Object.create()
// The Object.create() method creates a new object, 
// using an existing object as the prototype of the newly created object.
// when you use Object.create() the new object does not have same reference to original object
// so changing any properity will not effet the original object

// let user = {
//   age: 40,
//   doubleAge: function () {
//     return this.age * 2;
//   },
// };

// console.log(user);
// console.log(user.age);
// console.log(user.doubleAge());

// let obj = Object.create({})
// console.log(obj)

// with Create Method you can use another Object as a Model (prototype) like creating new object from constractor
// let objUser = Object.create(user)
// objUser.age =  30;
// console.log(objUser);
// console.log(objUser.__proto__); // user
// console.log(objUser.age);
// console.log(objUser.doubleAge());

// [4] Create Object with Object.assign()
// like concat in array not adding prototype like Object.create()

// let obj1 = {
//   prop1: 1,
//   meth1: function () {
//     return this.prop1;
//   },
// };
// let obj2 = {
//   prop2: 2,
//   meth2: function () {
//     return this.prop2;
//   },
// };

// let targetObject = {
//   // when he find 2 properties with same name will take first one
//   prop1: 100,
//   prop3: 3,
// };

// let finalObject = Object.assign(targetObject, obj1, obj2);

// finalObject.prop1 = 200;

// console.log(finalObject);
// console.log(finalObject.__proto__); // Object

// // you can add {} empty object as target and yoou can add properties also like { prop4: 4 }
// let newObject = Object.assign({}, obj1, obj2, { prop4: 4 });

// console.log(newObject);

// [5] Create Object using ES6 Classes
// class Person {
//   constructor(fname, lname) {
//     this.firstName = fname;
//     this.lastName = lname;
//   }
// }

// const person = new Person('testFirstName', 'testLastName');

// console.log(person.firstName); // testFirstName
// console.log(person.lastName); // testLastName

/* to Create iterable Object from Object you have 3 methods
1- Object.keys(myObj) // retrun array of keys
2- Objetc.values(myObj) // return array of values
3- Object.entries(myObj) // return array of arrays each array contain [key, value]

iterable means has built in [symbol.iterator]
iterable means have indexing and length property
iterable also means you can use with it 
for of loop
forEach() | filter() | map() | reduce()
*/

// Home-Made iterable Object
// let range = {
//   from: 1,
//   to: 5
// };

// 1. call to for..of initially calls this
// range[Symbol.iterator] = function() {

//   // ...it returns the iterator object:
//   // 2. Onward, for..of works only with the iterator object below, asking it for next values
//   return {
//     current: this.from,
//     last: this.to,

//     // 3. next() is called on each iteration by the for..of loop
//     next() {
//       // 4. it should return the value as an object {done:.., value :...}
//       if (this.current <= this.last) {
//         return { done: false, value: this.current++ };
//       } else {
//         return { done: true };
//       }
//     }
//   };
// };

// // // now it works!
// for (let num of range) {
//   console.log(num); // 1, then 2, 3, 4, 5
// }

// Home-Made iterable Object (smaller) 

// let range = {
//   from: 1,
//   to: 5,

//   [Symbol.iterator]() {
//     this.current = this.from;
//     return this;
//   },

//   next() {
//     if (this.current <= this.to) {
//       return { done: false, value: this.current++ };
//     } else {
//       return { done: true };
//     }
//   }
// };

// for (let num of range) {
//   console.log(num); // 1, then 2, 3, 4, 5
// }


// -------Array like Object------------ 
/* [1] to transfer Object to Array like object ( keys should be like index 0,1,2 and write length)
let myObj = {
  0: "M",
  1: "A",
  2: "S",
  length: 3
}

let myString = "Soliman"
console.log(Array.from(myObj)) // ["M", "A", "S"]
console.log(Object.values(myObj)) // ["M", "A", "S", 3]

[2] Arguments is Array like Object
function arg (a,b) {
  console.log(arguments)
}
arg(1,2)

[3] HTMLCollection is Array like object
let li = document.getElementsByTagName("li")
console.log(li)

** How to convert array like object to array
[1] using spread operator and []
function arg (a,b) {
  console.log([...arguments])
}
arg(1,2)

[2]Using Array.from 
let li = Array.from(document.getElementsByTagName("li"))
console.log(li)

[3]Using slice()
let li = Array.prototype.slice.call(document.getElementsByTagName("li"))
console.log(li)
// [1,2,3,4].slice() will return [1,2,3,4] but how it works ?
slice will iterate over the array and the array is the value of this keyword 
and with array like object you can bind it to make it the value of this then slice will
iterate over it (array like object have index and length so slice will consider it as array)

we used Array.prototype.slice.call because array like object doesn't have slice method
*/

// -----------convert string Object to string using valueOf() or toString()----------
// let strObj = new String("Soliman")
// console.log(strObj)
// console.log(strObj.valueOf())
// console.log(strObj.toString())

//------------------------------------iterators and Generators-----------------

// -------------iterator ([Symbol.iterator])

/* 
iterable means Object has built in [symbol.iterator]
you can change not iterable object to iterable object by adding [symbol.iterator] or change it to array:

* Adding [Symbol.iterator] to Object

let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  console.log(num); // 1, then 2, 3, 4, 5
}

((((my Way ))))
myObj = {
  one : "M",
  two : "A",
  three : "C",
  [Symbol.iterator]() {
    this.current = Object.keys(this).indexOf(Object.keys(this)[0])
    this.current = 0
    return this;
  },
  next() {
    let lenght = Object.keys(this).length
    if ( this.current < (lenght - 2)) {
      return { done: false, value: this[Object.keys(this)[this.current++]] };
    } else {
      return { done: true };
    }
  }
}
for(x of myObj){
  console.log(x)
}

* Hint if you want to use next() on built-in [symbol.iterator] Objects like array:
The entries() method returns a new Array iterator object 
that allows you to iterate through the key/value pairs in the array. 
The Array iterator object has a built-in method called next() that can be used to get the next value.
you can not find str.entries() and if you use Object.entries(str) will return array of [index , value] arrays 

let arr = ["Mohamed", "Ahmed", "Soliman"]
let ite = arr.entries()
// let ite = arr.keys()
// let ite = arr.values()
console.log(ite.next())
console.log(ite.next())
console.log(ite.next())
console.log(ite.next())

* to change array or string to iterator you can use str[Symbol.iterator]() :
let str = "Soliman"
let ite = str[Symbol.iterator]();
console.log(ite.next())
let arr = [1,2,3,4]
let ite = arr[Symbol.iterator]();
console.log(ite.next())


* Changing Object to Array by :
* Object.keys - Object.entries - Object.values
* Array.From ( after adding index and length to Object)

myObj = {
  0 : "M",
  1 : "A",
  2 : "C"
}
let arrObj = Object.values(myObj)
console.log(arrObj)

myObj = {
  0 : "M",
  1 : "A",
  2 : "C",
  length : 3
}
let arrObj = Array.from(myObj)
console.log(arrObj)
*/

// --------Symbol.iterator how it works--------------
/* The Symbol.iterator is a function that returns a next() function.

The Symbol.iterator method is called automatically by for..of.

The spread operator and for...of statements call the iterable protocol of an object. Some objects, like Array, String, Set and Map have built in iterable protocols. That means that they have the Symbol.iterator method.

1. When for..of starts, it calls that method once (or errors if not found). The method must return an iterator – an object with the method next.
2. Onward, for..of works only with that returned object.
3. When for..of wants the next value, it calls next() on that object.
4. The result of next() must have the form {done: Boolean, value: any}, where done=true means that the iteration is finished, otherwise value is the next value.
*/

// -------------------------Generator (also at ES6)----------------------------------
/* difference between generator and normal function

* Normal Function once you invoke it you can not pause it ... it will finish then other codes will run after it

* Generator you can pause it and other codes will run then you can resume it from the point you paused it
ES6 generator functions are "cooperative" in their concurrency behavior. 
Inside the generator function body, you use yield keyword to pause the function 
from inside itself. Nothing can pause a generator from the outside; 
it pauses itself when it comes across a yield.
However, once a generator has yield-paused itself, 
it cannot resume on its own. An external control must be used to restart the generator.
With normal functions, you get parameters at the beginning and a return value at the end. 
With generator functions, you send messages out with each yield, 
and you send messages back in with each restart.

* they return a special type of iterator, called a Generator 
* generator is iterable

* step by step how generator works :
1st next() yield 1 will pause the generator and return 1 then 2nd next() will resume from yield 2 then pause and return 2
function *Yield() {
  yield 1;
  console.log("After Yield one")
  yield 2;
  yield 3;
  yield 4;
  yield 5;
}
let genY = Yield()
console.log(genY.next())
console.log(genY.next().value) // to give you only the value
console.log(genY.next().done) // to give you false or true
console.log(genY.next())
console.log(genY.next())
console.log(genY.next())

//will loop over every thing not only yield so txt from console.log() will be printed out also
for (let x of Yield() ){
  console.log(x)
} // 1, After Yield one , 2 ,3 ,4

* other complicated Exp. : 
function *foo(x) {
    var y = 2 * (yield (x + 1));
    var z = yield (y / 3);
    return (x + y + z);
}
var it = foo( 5 );
console.log( it.next() );       // { value:6, done:false }
console.log( it.next( 12 ) );   // { value:8, done:false }
console.log( it.next( 13 ) );   // { value:42, done:true }

The yield (x + 1) is what sends out value 6. The second next(12) call sends 12 
to that waiting yield (x + 1) expression, so y is set to 12 * 2, value 24. 
Then the subsequent yield (y / 3) (yield (24 / 3)) is what sends out the value 8. 
The third next(13) call sends 13 to that waiting yield (y / 3) expression, making z set to 13.
Finally, return (x + y + z) is return (5 + 24 + 13), or 42 being returned out as the last value.

* invoke normal function inside generator:
function foo(x) {
  console.log(x)
}

function *bar() {
  yield;
  foo (yield);
}
let gen = bar()
console.log(gen.next())
console.log(gen.next())
// here we pass argument to yield and will be argument to foo() function
console.log(gen.next(7))

* using for..of with generator:
As long as done is false, it automatically extracts the value property and assigns 
it to your iteration variable (v in our case). Once done is true, the loop iteration stops 
(and does nothing with any final value returned, if any).
function *foo() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
    return 6;
    //yield 6;
}
for (var v of foo()) {
    console.log( v );
} // 1 2 3 4 5
will not print 6 because last next() of return will be like
{ value:6, done:true } not done:false like using yield


** Generator can suspend for loop 
for (let i = 0; i < 3; i++ ) {
  console.log(i)
}


suspend for loop
function* loopGenerator () {
  for (let i = 0; i < 3; i++ ) {
    yield (i)
    // return (i)
  }
}

let startGenerator = loopGenerator();
console.log(startGenerator.next())
console.log(startGenerator.next())
console.log(startGenerator.next())
console.log(startGenerator.next())

** Generator can use infinite loop 
make infinite loop but will not freeze you pc because it's suspended and only works once you ask by .next()

function* generateId() {
  let id = 1;
  while(true) {
    yield id
    id++
  }
}

let genId = generateId()
console.log(genId.next())
console.log(genId.next())
console.log(genId.next())
console.log(genId.next())
console.log(genId.next())

* when you declare a new variable you get new object and will not affect the 1st generator
let genId2 = generateId();
console.log(genId2.next())//1
console.log(genId2.next())//2
console.log(genId2.next())//3
// will not affect the 1st generator
console.log(genId.next()) //6
console.log(genId2.next())//4
console.log(genId2.next())//5

// you can pass argument to next() and this will be yield inside generator
function* generateId() {
  let id = 1;
  while(true) {
    const increment = yield id
    console.log("hi")
    // null == undefined => true | null === undefined => false
    if (increment != null) {
      id += increment
    } else {
      id++
    }
  }
}

let genId = generateId();

// Will not work on first next() beacuse yield is not exist yet
// you have to trigger generator by next() then yield will be available
// At this point you have an yield at your disposal and you can push your value via genId.next()
console.log(genId.next()) // {value: 1, done: false} // you can't add argument here
console.log(genId.next(5)) // {value: 6, done: false}
console.log(genId.next()) // {value: 7, done: false}
console.log(genId.next()) // {value: 8, done: false}
// // if you want to exist the generator just write return
console.log(genId.return(10)) // {value: 10, done: false}
// // throw() to give error
console.log(genId.throw("ERROR 404"))

**generator with Array 

function* arrayGenerator (array) {
  for ( i = 0 ; i < array.length; i++) {
    yield array[i]
  }
}

let arrGen = arrayGenerator([1,2,3]);

console.log(arrGen.next())
console.log(arrGen.next())
console.log(arrGen.next())
console.log(arrGen.next())
*/

// ----------------------------return vs yield---------------------------
/*
It’s a bit like return, but not. Return simply returns the value after the function call,
and it will not allow you to do anything else after the return statement.

if you use return with generator it will stop generator after 1st return

Yield with asterisk can delegate it’s work to another generator. 
This way you can chain as many generators as you want. (look exp. below)

function* func1() {
  yield 42;
}

function* func2() {
  yield* func1();
}

const iterator = func2();

console.log(iterator.next().value);
// expected output: 42
*/

// -------------------------------for... of loop----------------------------
/* For...of loop works only on :
[1] Built-in (symbol.iterator) like Array , String , Map , Set , ...
[2] Array Like Objects like Arguments , NodeList , HTMLCollection , ...
[3] User defined Object ( that we add [symbol.iterator] and next() manually)
*/

//--------------------------------for...in loop---------------------------
/* The for...in iterates over all enumerable properties of an object. 
It doesn’t iterate over a collection such as Array, Map or Set.
Unlike the for...in loop, the for...of iterates a collection, 
rather than an object. In fact, the for...of iterates over elements 
of any collection that has the [Symbol.iterator] property.
*/

// --------------for...of loop vs for...in loop and iterable vs enumerable-----------
/*
if enumerable: false this property will not show in for...in loop
if enumerable: true this property will show in for...in loop

let obj = {firstName : "Mohamed", lastName : "Hussein"}
obj.age = 33
Object.defineProperty(obj , "middleName" , { value : "Ahmed", enumerable: false})
for(x in obj) {
  console.log(x)
}

let arr = [1,2,3,4]
arr[4] = 5 // will show on for...of because property name no. like index
arr.five = 6 // will not show on for...of because property name is not a no. like index
Object.defineProperty(arr , 5 , { value : 7 , enumerable: true}) // will show in for..of if property name is no. / will show in for..in because enumerable: true

for (x in arr) {
  console.log(x) // 0,1,2,3,4,5,five (indexes (keys))
}
for (x of arr) {
  console.log(x) // 1,2,3,4,5,7 not 6  (values)
}

------------------------------for...in loop vs hasOwnProperty --------------------
The hasOwnProperty() method returns true if the specified property is a direct property of the object — 
even if the value is null or undefined. The method returns false if the property is inherited, 
or has not been declared at all. Unlike the in operator, 
this method does not check for the specified property in the object's prototype chain.
*/

// ----------------------------Object Property Descriptor----------------------


/* 
Descriptor Groups : 
* DATA
* value -- get() => Accessor Property
* writable -- set() => Accessor Property
* configurable 
* enumerable

let obj = {
  firstName : "Mohamed",
  age : 33
}
Object.defineProperty(obj , "lastName", {
  value : "Hussein",
  writable : true, 
  configurable : true,
  enumerable : true
})
obj.lastName = "Soliman"
console.log(obj.lastName) // Hussein if writable is false | Soliman if writable is true

using get and set
let obj = {
  firstName : "Mohamed",
  age : 33
}
Object.defineProperty(obj , "lastName", {
  // this here refers to window object
  // get : () => this.lastName,
  // set : (val) => {
  //   console.log(this) // window
  //   return this.lastName = val + " from setter method" // so we are adding here lastName variable to window object
  // },
  // this here refers to obj
  get : function () {
    return this.lastName = value
  },
  set : function (val) {
    console.log(this) // obj
    return value = val + "!"
  },
  configurable : true, 
  enumerable : true
})
obj.lastName = "Hussein"
console.log(obj)
console.log(window.lastName)

// Default values will be different if property already exist in object or not
* if adding new property by using defineProperty method writable , configurable and enumerable will be false
* if changing old property by using defineProperty method writable , configurable and enumerable will be true
* if adding or changing property using do notaion writable , configurable and enumerable will be true

var obj = {a : 1, b : 3};

obj.b = 2;
// is equivalent to:
// Object.defineProperty(obj, 'b', {
//   value: 2,
//   writable: true,
//   configurable: true,
//   enumerable: true
// });

// On the other hand,
// Object.defineProperty(obj, 'b', { value: 2 });
// is equivalent to:
// Object.defineProperty(obj, 'b', {
//   value: 2,
//   writable: false,
//   configurable: false,
//   enumerable: false
// });

// console.log(Object.getOwnPropertyNames(obj)) //return array of properties names
// console.log(Object.getOwnPropertyDescriptor(obj,"age")) // return info for property
// console.log(Object.getOwnPropertyDescriptors(obj)) // return info for all property
// console.log(Object.keys(obj)) // return list of enumerable properties
// console.log(Object.values(obj)) // return list of enumerable properties
// console.log(obj.propertyIsEnumerable("lastName")) // return Boolean value
// console.log(obj.hasOwnProperty("lastName")) // return Boolean value


Objects can be 
1. Extensible - new properties can be added 
2. Frozen - props cannot be changed in any way 
3. Sealed - props can't be deleted or configured but are still writable 

Object PROPERTIES can be 
1. Writable - change the value 
2. Enumerable - seen through a for...in loop 
3. Configurable - change the property descriptors  or delete

Object.isExtensible(obj) 
Object.isFrozen(obj) 
Object.isSealed(obj) 
Object.preventExtensions(obj) 
Object.freeze(obj) 
Object.seal(obj)

let obj  = {
  prop1 : "test"
}
let objProto = {}
Object.seal(obj)
Object.freeze(obj)
Object.preventExtensions(obj)


                          seal()            freeze()              preventExtensions()
* Add new prop              no                no                        no
* Edit prop value           yes               no                        yes
* Delete a prop             no                no                        yes
* Change descriptors        no                no                        yes
* Reassign __proto__        no                no                        no

// Object.freeze => shallow nested array is mutable 
let arr = [1,2,3,[4,5]]
Object.freeze(arr)
arr[0] = 9;
arr[3][1] = 7
console.log(arr) // [1,2,3,[4,7]]
*/


// -------Data property vs Accessor Property-------------
/*

In JavaScript, accessor properties are methods that get or set the value of an object. 
For that, we use these two keywords:
* get - to define a getter method to get the property value
* set - to define a setter method to set the property value

let obj = {
  // Data property
  firstName : "Mohamed",
  // Accessor Property(getter)
  get getName () {
    return this.firstName
  },
  // Accessor Property(getter) must have exactly one parameter
  set changeName (newName) {
    this.firstName = newName
  }
}
obj.changeName = "Soliman"
console.log(obj.getName)
*/


// ----------------------------DOM ( Document Object Model)---------------------

/*
The Document Object Model (DOM) connects web pages to scripts or programming 
languages by representing the structure of a document—such as the HTML 
representing a web page—in memory. Usually it refers to JavaScript, 
even though modeling HTML, SVG, or XML documents as objects are not part of 
the core JavaScript language.
The DOM represents a document with a logical tree. 
Each branch of the tree ends in a node, and each node contains objects. 
DOM methods allow programmatic access to the tree. With them, you can change 
the document's structure, style, or content.

"The W3C Document Object Model (DOM) is a platform and language-neutral 
interface that allows programs and scripts to dynamically access and update 
the content, structure, and style of a document."

The W3C DOM standard is separated into 3 different parts:
* Core DOM - standard model for all document types
* XML DOM - standard model for XML documents
* HTML DOM - standard model for HTML documents

The HTML DOM is a standard for how to get, change, add, or delete HTML elements.

* The HTML elements as objects
* The properties of all HTML elements
* The methods to access all HTML elements
* The events for all HTML elements

In the DOM, all HTML elements are defined as objects.

The programming interface is the properties and methods of each object.

A property is a value that you can get or set (like changing the content of an HTML element).
A method is an action you can do (like add or deleting an HTML element).
*/

/* 
---------Node Types-----------
let nodeTypes = {
  1 : "Element",
  2 : "Attribute"
  3 : "Text",
  8 : "Comment",
  9 : "Document",
  10 : "DocType",
  11 : "Document Fragment"
}
when you use nodeType will return a no. 
let df = new DocumentFragment()
let txt = document.createTextNode("a text node")
df.appendChild(txt)
console.log(df.nodeType) // 11
console.log(txt.nodeType) // 3

* node.nodeValue => return value of node
* node.parentNode => return parent of child node
* node.nodeType => return no. of node Type see nodesTypes above
* node.ownerDocument => return the root element as Object ( in HTML html is always the owner)
* node.nodeName => if node is element return tag name
                  if node is attribute return attribute name

let span = document.querySelector("span")
let txt = document.createTextNode("a text node") 
console.log(txt.nodeValue) //use nodeValue for text node
console.log(span.innerHTML) //use innerHTML for element
*/

/* 
-------Difference between HTMLCollection and NodeList----------

HTMLCollection : 
* only Elements Nodes
* live ( means any change the HTMLcollection will be updated )
Exp :
[1] document.getElementsByClassName()
[2] document.getElementsByTagName()

NodeList :
* any type of Nodes => elements , text , comment ,....
* static (not live) (means nodeList will not update when changes happend) except childNodes & document.getElementsByName()
// exp. for childNodes
let div = document.querySelector("div")
let childnodes = div.childNodes
console.log(childnodes)
let span = document.createElement("span")
div.appendChild(span)
console.log(childnodes)

// nodeList has property length and method item(index)
// both are the same
document.body.childNodes.item(0)
document.body.childNodes[0]

let nodeDivs = document.querySelectorAll("div")
let htmlDivs = document.getElementsByTagName("div")
nodeDivs[0].remove()
console.log(nodeDivs) // nodeList // 4 divs because nodeList is not live
console.log(htmlDivs) // HTMLCollection // 3 divs because HTMLcolletion is live

let div = document.querySelector("div")
console.log(div.children) // return HTMLCollection (Elements only)
console.log(div.childNodes) // return NodeList ( all types of nodes )

- NodeList is not an array, it is possible to
iterate over it with
forEach( ) . It has its own forEach() method."

- HTMLCollection is array-like but you cannot iterate over its
elements using forEach()
if you need to use forEach() on HTMLCollection you can use call and add HTMLCollection as thisArg :
[].forEach.call(HTMLCollection, function(element){
  console.log(element)
})

exp.
let htmlDivs = document.getElementsByTagName("div");
Array.prototype.forEach.call(htmlDivs, function(element){
  console.log(element)
}) // you can use [] instead of Array.prototype
*/

// let df = new DocumentFragment()
// let txt = document.createTextNode("a text node")
// df.appendChild(txt)
// document.body.appendChild(df)
// console.log(txt.ownerDocument)

// -------------solve Live collection Problem ---------------

/* 
* when you assign length to variable (htmlLiveLength) 
you are assigning a number (primitive value (immutable)) so after changing HTMLCollection
will not affect that variable 

* el4Html in this variabel you try to access el4 but not yet exist so retrun undefined 
and assign undefined (primitive value(immutable)) so after changing HTMLCollection
will not affect that variable

* but when you assign HTMLCollection to variable (htmlLive) you are assign host Object (by reference) 
not primitive value so after changing HTMLCollection will change that variable 

*/
// let live = document.getElementById("live")
// let el1 = document.createElement("div")
// let el2 = document.createElement("div")
// let el3 = document.createElement("div")
// let el4 = document.createElement("div")

// let htmlLive = document.getElementsByTagName("div")
// let htmlLiveLength = document.getElementsByTagName("div").length
// let el4Html = document.getElementsByTagName("div")[3]
// console.log(htmlLive) // HTMLCollection[]
// console.log(htmlLiveLength) // 0
// console.log(htmlLive.length) // 0
// console.log(el4Html) // undefined
// console.log(htmlLive[3]) // undefined
// live.append(el1,el2,el3,el4)
// console.log(htmlLive) // HTMLCollection(4)
// console.log(htmlLiveLength) // 0
// console.log(htmlLive.length) // 4
// console.log(el4Html) // undefined
// console.log(htmlLive[3]) // div

/* to solve live problem you have to convert HTMLCollection to Array by three ways:
[1] Array.from()
let htmlLive = Array.from(document.getElementsByTagName("div"))

[2] spread Opertator
let htmlLive = [...document.getElementsByTagName("div")]

[3] slice
let htmlLive = [].slice.call(document.getElementsByTagName("div"))
*/

/* --------------NamedNodeMap----------------
A NamedNodeMap is an array-like unordered collection of an element's attributes.
In other words: a NamedNodeMap is a list of Attr objects.
NamedNodeMap is live.

A NamedNodeMap has a length property that returns the number of nodes.
The nodes can be accessed by name or index numbers. The index starts at 0.

NamedNodeMap Properties and Methods

* getNamedItem() => Returns an attribute node (by name) from a NamedNodeMap
* Item() => Returns an attribute node (by index) from a NamedNodeMap
* Length => Returns the number of attributes in a NamedNodeMap
* removeNamedItem() => Removes an attribute (node)
* setNamedItem() => Sets an attribute (node) by name

let span = document.querySelector("span")
console.log(span.attributes.getNamedItem("class"))
console.log(span.attributes.item(0))
span.attributes.removeNamedItem("class")
console.log(span)
// setNamedItem way
let node = document.createAttribute("class")
node.value = "hi"
span.attributes.setNamedItem(node)
console.log(span)
// setAttribute way
span.setAttribute("class", "hi")
console.log(span)

let span = document.querySelector("span")
let nodeMap = span.attributes
let nodeList = document.querySelectorAll("div")
let htmlCol = document.getElementsByTagName("div")
console.log(nodeMap)
console.log(nodeList)
console.log(htmlCol)
span.setAttribute("class", "hi")
let div3 = document.createElement("div")
document.body.appendChild(div3)
console.log(nodeMap) // live
console.log(nodeList) // static
console.log(htmlCol) // live
*/

/*  -----------DOMTokenList------------
A Collection of values of attribute and it's not Live
represent a set of space-separated tokens returned by Element.classList or HTMLLinkElement.relList

[1] properites :
*length *value
[2] Methods :
* DOMTokenList.item()
* DOMTokenList.contains()
* DOMTokenList.add()
* DOMTokenList.remove()
* DOMTokenList.replace()
* DOMTokenList.supports()
* DOMTokenList.toggle()
* DOMTokenList.froEach()
* DOMTokenList.keys()
* DOMTokenList.values()

let div = document.querySelector("div")
let divClasses = div.classList
let divAttr = div.attributes
console.log(divClasses) // DOMTokenList => return array of value of the class
console.log(divAttr) // NamedNodeMap => return array of  attributes ( class, id, ....)
console.log(divAttr.getNamedItem("class")) // return value of specific attribute (class)

*/
// -------------------------------DOM selection--------------------------
// let myIdElement = document.getElementById("my-div"); // by ID
// let myTagElement = document.getElementsByTagName("p") // by Tag
// let myClassElement = document.getElementsByClassName("my-span")// by class-name
// // querySelector select only first element if more than one elements has the same class
// // let myQueryElement = document.querySelector(".special")
// // let myQueryElement = document.querySelector(".special")
// let myQueryElement = document.querySelector("#my-div")
// let myQueryAllElement = document.querySelectorAll(".my-span")

// console.log(myIdElement)
// console.log(myTagElement[1])
// console.log(myClassElement[1])
// console.log(myQueryElement)
// console.log(myQueryAllElement[0])

// myTagElement[1].innerHTML = "test" // to change content
// myTagElement[1].TextContent = "test" // to change content


// console.log(document.title);
// console.log(document.body);
// console.log(document.forms[0].one.value);
// console.log(document.links[1].href);

// let myElement = document.querySelector(".js");
// console.log(myElement.innerHTML); // return as written in HTML File
// console.log(myElement.textContent); // return as Shown at Webpage

// myElement.innerHTML = " Text From <span>Main.js</span> File";
// myElement.textContent = " Text From <span>Main.js</span> File";

// those are shortcut for setAttribute
// document.images[0].src = "https//google.com"
// document.images[0].alt = "Alternat"
// document.images[0].title = "Picture"
// document.images[0].id = "pic"
// document.images[0].className = "img"

// document.links[0].href = "https//facebook.com"

// let myLink = document.querySelector(".link")

// console.log(myLink.getAttribute("href"))
// console.log(myLink.getAttribute("class"))

// myLink.setAttribute("href", "https://twitter.com")
// myLink.setAttribute("title", "twitter") // if attribute not exist will create it automatically

/* ------------------Method to Check Attribute
- Element.atrributes
-Element.hasAttibute
-Element.hasAttributes ( here you don't write anything between () this only to check if this element has any type of attributes or not)
-Element.removeAttribute */

// console.log(document.getElementsByTagName("p")[0].attributes)

// let myP = document.getElementsByTagName("p")[0];

// if (myP.hasAttribute("data-src")) {
//   console.log("found")
// } else {
//   console.log("Not Found")
// }

// if (myP.hasAttribute("data-src")) {
//   if (myP.getAttribute("data-src") === "") {
//     myP.removeAttribute("data-src")
//   } else {
//     myP.setAttribute("data-src", "New Value")
//   }
// } else {
//   console.log("Not Found")
// }

// if (myP.hasAttributes()) {
//   console.log("Has Attributes")
// }

// if you use querySelectorAll or getElementsByClassName it will return Array and you have to iterate them to change all elements

// let myPs = document.querySelectorAll("p");

// (function() {
//   for ( let i =0; i < myPs.length; i++) {
//     myPs[i].innerHTML = `Hello ${i}`
//   }
// })();

// let myEl = document.querySelector(".para1")
// myEl.setAttribute("title" , "test50")

// console.log(myEl.title)

/* ----------------Create Element 
-createElement
-createComment
-createTextNode
-createAttribute
-appendChild */

// let myElement = document.createElement("div")
// let myAttribute = document.createAttribute("data-custom")
// let myText = document.createTextNode("Product One")
// let myComment = document.createComment(" This Is Div")
// myElement.className = "Product";

// myElement.setAttributeNode(myAttribute)
// myElement.setAttribute("data-test", "testing")
// // if you want to change value of custom attribute you can use setAttribute or dataset
// // but you can't change it directly like normal attributes
// // myElement.data-custom = "hello" // Error
// // myElement.setAttribute("data-custom", "hello")
// myElement.dataset.custom = "helloooo"
// // if you want to access custom attribute you can do it only getAttribute
// console.log(myElement.getAttribute("data-custom"))


// console.log(myElement)

// // Append Comment to Element
// myElement.appendChild(myComment)

// // Append Text To Element
// myElement.appendChild(myText)

// // Append Element to Body
// document.body.appendChild(myElement)


// let myMainElement = document.createElement("div");
// let myHeading = document.createElement("h2");
// let myParagraph = document.createElement("p");

// let myHeadingText = document.createTextNode("Product Title");
// let myParagraphText = document.createTextNode("Product Description");

// // Add Heading Text
// myHeading.appendChild(myHeadingText)
// // Add Heading to Main Element
// myMainElement.appendChild(myHeading)

// // Add Paragraph Text
// myParagraph.appendChild(myParagraphText)
// // Add Paragraph to Main Element
// myMainElement.appendChild(myParagraph)

// // you can add more than one element at same time but by using Append
// // myMainElement.append(myHeading, myParagraph)

// // Add Class to Main Element
// myMainElement.className = "Product";

// document.body.appendChild(myMainElement);

// ------Small Challeng 100 times -----

// for (let i = 1; i <= 100; i++) {
//   let myMainElement = document.createElement("div");
//   let myHeading = document.createElement("h2");
//   let myParagraph = document.createElement("p");
//   myMainElement.className = "product";
//   let myHeadingText = document.createTextNode(`Product Title ${i}`);
//   let myParagraphText = document.createTextNode(`Product ${i} Description`);
//   myHeading.appendChild(myHeadingText);
//   myParagraph.appendChild(myParagraphText);
//   myMainElement.append(myHeading, myParagraph);
//   document.body.appendChild(myMainElement)
// }

// You Can use innerHTML or TextContent instead of creating TextNode then append them but TextNode and Append is better
// myHeading.innerHTML = `Product ${i} Title`
// myParagraph.innerHTML = `Product ${i} Description`
// myHeading.textContent = `Product ${i} Title`
// myParagraph.textContent = `Product ${i} Description`

// let myDiv = document.createElement("div");
// let myP = document.createElement("p");
// let mySpan = document.createElement("span");

// let myDivText = document.createTextNode("Hello Div");
// let my2ndText = document.createTextNode("Hello");
// let myComment = document.createComment("comment")

// let myPText = document.createTextNode("Hello P");
// myP.appendChild(myPText);

// let mySpanText = document.createTextNode("Hello Span");
// mySpan.appendChild(mySpanText)

// myDiv.append(myDivText, myP, mySpan, myComment, my2ndText)

// document.body.appendChild(myDiv)

// -----------------------firstChild & lastChild--------------------------------
// let myElement = document.querySelector("div");

// console.log(myElement);
// // give you only Elements
// console.log(myElement.children); // HTMLCollection
// //give you (Element , comment ,text, spaces) // spaces considerd as text 
// console.log(myElement.childNodes); // Nodelist
// console.log(myElement.childNodes[0]);
// // give you first child (Element , comment ,text, spaces)
// console.log(myElement.firstChild);
// console.log(myElement.lastChild);
// // give you only elements
// console.log(myElement.firstElementChild);
// console.log(myElement.lastElementChild);

// ----------------------------------Events----------------------------
/*
onclick
oncontextmenu (Right Click) 
onmouseenter (Hover)
onmouseleave (hover and leave)

onload
onscroll
onresize

onfocus
onblur ( opposite to Focus)
onsubmit
*/

// let myBtn = document.getElementById("btn")

// myBtn.onclick = function (){
//   console.log('click')
// }

// you can select element by it's atrribute
// let userInput = document.querySelector("[name='username']")
// let ageInput = document.querySelector("[name='age']")

// // the parameter here refer to onsubmit event itself not element (form[0])
// // this refer to element (form[0]) that recieve the event(submit)
// document.forms[0].onsubmit = function (e) {
//   let userValid = false;
//   let ageValid = false;

//   if (userInput.value !== "" && userInput.value.length <= 10) {
//     userValid = true;
//   }
//   if (ageInput.value !== "" && !isNaN(ageInput.value) ) {
//     ageValid = true;
//   }

//   if (userValid === false || ageValid === false) {
//     e.preventDefault();
//     console.log("fill th fields")
//   }
// };

// document.links[0].onclick = function (event) {
//   console.log(event)
//   console.log(this)
//   event.preventDefault();
// }


// ----------------------------Event Simulation

// let one = document.querySelector(".one");
// let two = document.querySelector(".two");

// window.onload = function() {
//   two.focus();
// }

// one.onblur = function () {
//   document.links[0].click();
// }

// --------------------ClassList
// let element = document.getElementById("my-div");
// console.log(element.classList);
// console.log(typeof element.classList)
// console.log(element.classList.contains("one"))
// console.log(element.classList.contains("soliman"))
// console.log(element.classList.item(3))

// element.onclick = function () {
//   element.classList.add("add-one", "add-two")
//   element.classList.remove("one", "two")
//   // toggle will search if exist will remove it if not exist will add it
//   element.classList.toggle("soliman")
// }

// ----------CSS
// let element = document.getElementById("my-div")

// // considerd as in-line Style
// element.style.color ="white"
// // like CSS but without - and use CamelCase
// element.style.backgroundColor = "blue"
// element.style.fontWeight = "bold"

// // here write like CSS
// element.style.cssText = "font-weight:bold; color:green; background-color:white; opacity:0.9;"

// element.style.removeProperty("color")
// // here write name and value and you can add important flag
// element.style.setProperty("font-size", "40px" ,"important" )

// // to Change the CSS File
// document.styleSheets[0].rules[0].style.removeProperty("font-style");
// document.styleSheets[0].rules[0].style.setProperty("background-color", "red", "important")

// ---------- Difference between innerText , innerHTML , textContent ------- 

// // The innerText property returns just the text, without spacing and inner element tags. 
// // innerText will not return the text of elements that are hidden with CSS (textContent will). 
// (function getInnerText() {
//     console.log(document.getElementById("demo").innerText)
//   })();
  
  // The innerHTML property returns the text, including all spacing and inner element tags.
  // (function getHTML() {
  //   console.log(document.getElementById("demo").innerHTML)
  // })();
  
  // The textContent property returns the text with spacing, but without inner element tags.
  // (function getTextContent() {
  //   console.log(document.getElementById("demo").textContent)
  // })();

  // ----- diference between innerHTML and outerHTML see photo on iphone

// ------------------------DOM [Deal With Elements]
/* 
  before
  after
  append
  prepend
  remove */

// let element = document.getElementById("my-div");

// let createdP = document.createElement("p");

// // Add outside element and Accept Node or String
// element.before("Hello Before From JS");
// // will be directly after the element not at the end
// element.after("Hello After From JS");
// element.after(createdP);

// // will add at the beginnig (inside element)
// element.prepend("Hello prepend From Js ")

// // will add at the end (inside element)
// element.append(" Hello append From Js")

// element.remove()

// let span = document.querySelector(".two");
// console.log(span.nextSibling) // comment
// console.log(span.nextElementSibling) // span three
// console.log(span.previousSibling) // comment
// console.log(span.previousElementSibling) // span one
// console.log(span.parentElement) // div

// span.onclick = function() {
//   // span.parentElement.remove();
//   span.parentElement.style.opacity = 0;
// }

// ---------cloneNode
// to take a copy of elements and it's attributes
// false (default Value) take atrributes but not take the content of Element
// true will copy the content also
// let myP = p.cloneNode(true)
// let myDiv = document.querySelector("div")

// // you have to change id because id unique and can't be twice
// // myP.id = "clone"
// myP.id = `${myP.id}-clone`

// myDiv.appendChild(myP)

// let myP = document.querySelector(".myp");

// myP.onclick = function () {
//   console.log("Message From OnClick")
// }

// function one() {
//   console.log("Message From OnClick 1")
// }
// function two() {
//   console.log("Message From OnClick 2")
// }

// myP.addEventListener("click", function() {
//   console.log("Message From OnClick Event")
// })

// // with addEventListener you can add more than one event and the 2nd event will not ovrride the 1st one both will work
// // same names of events but without (on) click instead of onclick
// // give you error if you write something Wrong

// myP.addEventListener("click", one)
// myP.addEventListener("click", two)

// function cloneMe() {
//   let clone = myP.cloneNode(true);
//   clone.className ="clone"
//   myP.after(clone);
//   let cloned = document.querySelector(".clone")
//   console.log(cloned)
//   // clone.addEventListener("click", again )
// }

// function again() {
//   console.log("I Am Cloned")
// }

// myP.addEventListener("click", cloneMe )

// //  we can not access clone because it is inside a function
// clone.addEventListener("click", again )

// big advantage of addEventListener that you can select element not exist yet
// document.addEventListener("click", function(e) {
//   if (e.target.className === "clone") {
//     console.log("I Am Cloned")
//   }
// })


// -------------Keyboard Event-----------------
// // to get unicode of pressed key
// // depend on which browser one of these property will work (ev.char || ev.charCode || ev.which)
// let input = document.getElementById("inputKey")
// // will trigger event only when you focus at input and press any Key
// input.addEventListener("keydown", function(ev){
//   let char = ev.char || ev.charCode || ev.which
//   let pressedKey = String.fromCharCode(char)
//   console.log(ev.currentTarget.tagName) // input
//   console.log(pressedKey)
// })
// // will trigger event when you press any key 
// document.body.addEventListener("keydown", function(ev){
//   let char = ev.char || ev.charCode || ev.which
//   let pressedKey = String.fromCharCode(char)
//   console.log(ev.currentTarget.tagName) //body
//   console.log(pressedKey)
// })

/* 
--------------Document Fragment-------------------
let div= document.getElementById("df")
console.log(div)
let games = [ "Horizon", "WarZone", "God of War", "The Last Of Us"]

// without Document Fragment will loop on array and add element to HTML file 4 times
games.forEach( game => {
  let li = document.createElement("li")
  li.textContent = game
  div.appendChild(li)
}) 

// using Document fragment to loop and add to fragment then add it once to HTML file
let df = new DocumentFragment()
games.forEach( game => {
  let li = document.createElement("li")
  li.textContent = game
  df.appendChild(li)
}) 
ul.appendChild(df)

*/
/* -------namespaces------------
if you have 2 js files you can not declare variables with same name
but the solution with namespaces

//here we used same variable name div and colorDiv 

let firstJS = {
  colorDiv : function(e) {
    e.currentTarget.style.color = "blue"
  },
  eventFunc : function(){
    let div = document.querySelector("#first")
    div.addEventListener("click", this.colorDiv)
  }
}
firstJS.eventFunc()

let secondJS = {
  colorDiv : function(e) {
    e.currentTarget.style.color = "red"
  },
  eventFunc : function(){
    let div = document.querySelector("#second")
    div.addEventListener("click", this.colorDiv)
  }
}
secondJS.eventFunc()

*/

// ------------------------------- BOM --------------------------
/* 
The window object is supported by all browsers. It represents the browser's window.
All global JavaScript objects, functions, and variables automatically become members of the window object.
Global variables are properties of the window object.
Global functions are methods of the window object.

Even the document object (of the HTML DOM) is a property of the window object:
window.document.getElementById("header");
document.getElementById("header");
*/
// if you are at global scope there is no difference between :
// window.alert("Hi1");
// this.alert("Hi2");
// alert("Hi3")

// alert will stop everything till you press ok
// alert("Test");
// console.log("Test")

// let confirmMsg = confirm("Are You Sure?");
// console.log(confirmMsg) // boolean Value

// if (confirmMsg === true) {
//   console.log("Item Deleted")
// }else {
//   console.log("Item Not Deleted")
// }

// accept 2 parameters message and default message
// let promtMsg = prompt("Suitable Day?", "Please write something!");
// console.log(promtMsg)

// Set timeout Method

// accept 2 values ( Function , time in mili seconds)
// setTimeout(function(){
//   console.log("Msg")
// }, 3000)

// setTimeout( sayMsg, 3000 );

// function sayMsg() {
//   console.log("I am Message")
// }

// you should write argument as 3rd argument in timeout Method not inside funtion like sayMsg("osama")
// setTimeout( sayMsg, 3000, "osama", 38);

// function sayMsg(user, age) {
//   console.log(`I am Message for ${user} his age is ${age}`)
// }

// counter or handler is a number like ID for setTimeout Method
// let counter = setTimeout( sayMsg, 3000);
// let handler = setTimeout (sayHello, 2000);

// console.log(counter);
// console.log(handler);

// function sayHello ()  {
//   console.log("Hello")
// }

// function sayMsg() {
//   console.log(`I am Message`)
// }

// let btn = document.querySelector("button")

// clearTimeout() clears a timer set -- parameter (id returned from setTimeout (counter , handler (any varaible name)))
// btn.onclick = function() {
//   clearTimeout(handler);
//   // clearTimeout(counter);
// }

// setInterval like setTimeout but interval repeat function every (time) but Timeout trigger function after (time)

// setInterval (function(){
//   console.log("Msg")
// },1000);

// setInterval (sayMsg,1000);
// function sayMsg() {
//   console.log("I am Message")
// }

// --------------clearInterval
// let div = document.querySelector("div");
// function countdown() {
//     div.innerHTML -= 1; // because let sum = "5" - 1 = 4
//     console.log(div.innerHTML)
//     if (div.innerHTML === "0") {
//         clearInterval(counter);
//       }
//     }
// let counter = setInterval(countdown, 1000);
    
// console.log(location);
// console.log(location.href);
// href does not delete History
// location.href = "https://google.com";
// to go section 2 with id #sec02
// location.href = "/#sec02";
// location.href = "https://developer.mozilla.org/en-US/docs/Web/JavaScript#reference";

// console.log(location.host);
// console.log(location.hostname);
// console.log(location.protocol);
// console.log(location.hash)
// change only hostname and leave rest of URL after / unchanged
// location.hostname ="google.com"
// location.protocol = "https"

// window.location.reload()
// // when you write url inside replace will delete the current page from History and go to new url
// window.location.replace("https://google.com")
// // assign will not delete the current page from History
// window.location.assign("https://google.com")

// will close only windows openend by JS
// window.close()
//

// setTimeout (function(){
//   // URL , Window Name, (_blank || _self),
//   // _blank (default value) to open the new window in a new tab _self to open the new window at same tab
//   window.open("https://google.com","blank","width=400,height=400,left=200,top=100")
// }, 1000)

// console.log(history.length)
// history.back()
// history.forward()
// history.go(0)  //reload
// history.go(-1)  //history.back()
// history.go(1)  //history.forward()

// stop() // to stop loading of webpage
// print() // to print the webpage
// let myNewWindow = window.open("https://google.com", "_self", "width=500,height=500")
// myNewWindow.focus()
// myNewWindow.close()

// accept X , Y
// window.scrollTo(5000, 5000);
// window.scrollBy(5000, 5000) //scroll from your current position

// chrome is so fast scrollTo() fires before chrome's default scroll you should give him delay
// setTimeout(() => {
//   window.scrollTo(5000, 5000);
// },2000)

// window.scrollTo({
//   left: 5000,
//   top: 5000,
//   behavior: "smooth"
// })

// scrollX = pageXOffset //pageXoffset for old browsers
// scrollY = pageYOffset //pageYoffset for old browsers

// let btn = document.querySelector("button")

// window.onscroll = function () {
//   if (window.scrollY >= 600) {
//     btn.style.display = "block"
//   }else {
//     btn.style.display = "none"
//   }
// }

// btn.onclick = function() {
//   window.scrollTo({
//   left: 0,
//   top: 0,
//   behavior: "smooth"
// })
// }

/* 
----------------------------Bubbling & Capturing -------------------------
element.addEventListener(event type , function , useCapture(true || false) )

[1] default value of useCapture is false
(that's means it is in Bubbling phase (event propagate from innermost child to parent (bubble up)))
// if you click on span here will print "hi from span " then "hi from div" 
// because useCapture value is default (false) and it is in bubbling phase from innermost child to parent

let div = document.querySelector("div")
let span = document.querySelector("span")
div.addEventListener("click", function(){console.log(div.firstChild)})
span.addEventListener("click", function(){console.log(span.firstChild)})

[2] true value of useCapture 
(that's means it is in Capturing phase (event propagate from parent to innermost child) (bubble down))
// here will print "hi from div " then "hi from span" 
// because useCapture value is true and it is in Capturing phase from parent to innermost child 

let div = document.querySelector("div")
let span = document.querySelector("span")
div.addEventListener("click", function(){console.log("hi div")},true)
span.addEventListener("click", function(){console.log("hi span")})
*/

/* difference between stopPropagation() and stopImmediatePropagation()
((will be usefull if you have child element inside parent element and both have events))
[1] stopPropagation() will stop event to bubble up from child to parent
here will prevent div.addEventListener("click", color) when you click on span

let div = document.querySelector("div")
let span = document.querySelector("span")
function color(ev) {
  ev.stopPropagation()
  let target = ev.currentTarget;
  target.style.color = "red"
}
span.addEventListener("click", color)
div.addEventListener("click", color)

[2]stopImmediatePropagation() will stop event to bubble up and prevent 2nd event at same element
here will prevent div.addEventListener("click", color) and also span.addEventListener("click", function(){console.log("hi")})
let div = document.querySelector("div")
let span = document.querySelector("span")
function color(ev) {
  ev.stopImmediatePropagation()
  let target = ev.currentTarget;
  target.style.color = "red"
}

function fontSize(ev){
  let target = ev.currentTarget;
  target.style.fontSize = "30px"
}

span.addEventListener("click", color)
span.addEventListener("click", fontSize)
div.addEventListener("click", color)

// note : if you use target instead of current target you will not need stopPropagation()
// but you need stopImmediatePropagation at both cases target or currentTarget to stop 2nd event at same element
*/

// --------target vs current target-----------
/*
because of bubbling up when we click on span it will fire 2 addEventListener for span and then 
will bubble up to div => target will always what you click on it but current target is THIS
in span.addEventListener this and current target will be span and 
in div.addEventListener this and current target will be div
*/
// let div = document.querySelector("div")
// let span = document.querySelector("span")

// span.addEventListener("click",function(ev){
//   console.log("Target is "+ ev.target.tagName)
//   console.log("Current Target is "+ ev.currentTarget.tagName)
//   console.log("THIS is "+ ev.currentTarget.tagName)
// })
// div.addEventListener("click",function(ev){
//   console.log("Target is "+ ev.target.tagName)
//   console.log("Current Target is "+ ev.currentTarget.tagName)
//   console.log("THIS is "+ ev.currentTarget.tagName)
// })

// * target is the element that triggered the event (e.g., the user clicked on)
// * currentTarget is the element that the event listener is attached to. ( like this)

// const div = document.querySelector(".container");
// div.addEventListener("click", (e) => {
//   console.log("target", e.target);
//   console.log("currentTarget", e.currentTarget);
//   console.log("currentTarget", this); // window because of arrow function
// });

// this = e.currentTarget  |  no this in arrow function
// const div = document.querySelector(".container");
// div.addEventListener("click", function (e) {
//   console.log("target", e.target);
//   console.log("currentTarget", e.currentTarget);
//   console.log("currentTarget", this);
// });

/* 
// -----------------Exp. of difference between target and currentTarget-------------
// let partyStarted = function(){
//   //add event listeners to element(s) on the page  
//   document.querySelector('.list-view').addEventListener('click', onClick2);
//   //target will be ul
  
//   let lis = document.querySelectorAll('.list-item');
//   lis.forEach(li => {
//       // li.addEventListener('click', onClick);
//       //target will be li
//   })
//   let spans = document.querySelectorAll('.list-item span');
// }

// let onClick2 = function(ev){
//   alert(ev.target.tagName);
//   let li = ev.target;
//   if( ev.target.tagName == 'SPAN'){
//       li = ev.target.parentElement;
//   }
//   let id = li.getAttribute('data-id');
//   let nm = li.getAttribute('data-name');
//   let h2 = document.querySelector('h2');
//   h2.textContent = id + ': ' + nm;
// }

// let onClick = function(ev){
//   //ev is the click event... but who called it?
//   alert('target ' + ev.target + ' and currentTarget ' + ev.currentTarget);
//   // ev.stopPropagation() // to stop ev to triggered on UL if you click on LI or SPAN

//   let id = ev.currentTarget.getAttribute('data-id');
//   let nm = ev.currentTarget.getAttribute('data-name');
//   let h2 = document.querySelector('h2');
//   h2.textContent = id + ': ' + nm;
// }

// document.addEventListener('DOMContentLoaded', partyStarted);

-----------Event delegation 
refers to the process of using event propagation (bubbling) 
It allows us to attach a single event listener for elements that exist now or will be exist in the future.
*/
// let ul = document.querySelector("ul")

// function responding(ev){
//   console.log(`${ev.target.tagName} is responding....`)
// }
// ul.addEventListener("click",responding)

// for(let i =1; i < 4; i++){
//   let li = document.createElement("li")
//   li.textContent = `Li no. ${i}`
//   ul.appendChild(li)
// }

/* difference between change and input and blur and focus
[1] input will excute function on each character you enter to input field
[2] change will only excute function when you blur after updating or inserting value to input field
and if you focus again and blur without changing the input value will not excute the function
will only excute function when you change the value
[3] blur will excute function when you focus in then focus out
[4] focus will excute function when you focus in
*/

/* difference between focus/blur and focusin/focusout
[1] focus/blur does not support bubbling
[2] focusin/focusout support bubbling

if you have input inside div parent 
let div = document.querySelector("div")
let input = document.querySelector(".input")
// focus will not work but focusin will work
div.addEventListener("focusin", function(ev){
  console.log(ev.target)
})
// if you want focus to work you can use useCapture (true)
div.addEventListener("focusin", function(ev){
  console.log(ev.target)
},true)

// note : here document is parent of input
document.addEventListener("focus" , function(e) {
  console.log(e.target)
})
*/


/* JS PopUp Boxes
[1] alert("this is alert")

[2] confirm("Are you Sure")
If the user clicks "OK", the box returns true. 
If the user clicks "Cancel", the box returns false.

[3] prompt("Enter your Password","Default value")
If the user clicks "OK" the box returns the input value. 
If the user clicks "Cancel" the box returns null.
*/

/*---------------to trigger callback function of event only one time
to trigger callback function of event only one time you can remove the 
EventListener once the callback function triggered
ev.target.removeEventListener(ev.type, arguments.callee);
arguments.callee can be used to refer to the currently executing function inside the 
function body of that function.
or you can add name to the callback function and use it

let div = document.querySelector("div")

div.addEventListener("click",function callBackFunc(ev){
  console.log("Clicked")
  ev.target.removeEventListener(ev.type, arguments.callee);
  // ev.target.removeEventListener(ev.type, callBackFunc);
  // console.log(arguments.callee)
  // console.log(callBackFunc)
})
*/



/* -----------LocalStorage and SessionStorage------------
* setItem
* getItem
* removeItem
* key
* clear
* JSON.stringify – the JSON.stringify method converts any object or acceptable value into a string JSON
* JSON.parse – the JSON.parse method converts a string into its corresponding object or value as described by the string

--If we try to store a JavaScript object to localStorage without 
first converting it to a string, we will get an [object, object] 
response, as shown in the image.
--If we try to retrieve the object from localStorage without 
first parsing it, we would get back a string as a response. 
(see localStorage Challenge to understand)

* difference between cookies and localStorage and sessionStorage (see pic)

*/
// set
// window.localStorage.setItem("color", "red")
// window.localStorage.fontWeight = "bold"
// window.localStorage["fontSize"] = "20px";

// get
// window.localStorage.getItem("color")
// console.log(window.localStorage.getItem("color"))
// console.log(window.localStorage.color)
// console.log(window.localStorage["color"])

// // Get Key
// console.log(window.localStorage.key(0))

// // remove
// window.localStorage.removeItem("color")

// // clear (Remove All)
// window.localStorage.clear();

// // set Color In Page
// document.body.style.backgroundColor =  window.localStorage.getItem("color")

// console.log(window.localStorage)
// console.log(typeof window.localStorage)

// localStorage not saved in private Tab
// localStorage does not have exp. time but session storage removed once you close the window
// sessionStorage will remain if you duplicate the Tab
// window.localStorage.setItem("color", "red")
// window.sessionStorage.setItem("color", "blue")

// document.querySelector(".name").onblur = function(){
//   window.sessionStorage.setItem("inputName", this.value)
// }
// window.localStorage.clear()

/* -------------------Start Local Storage Color Application Practice-------------- */

// let lis = document.querySelectorAll("ul li");
// let exp = document.querySelector(".experiment");

// if (window.localStorage.getItem("color")) {
//   // If There Is Color In Local Storage
//   // [1] Add Color To Div
//   exp.style.backgroundColor = window.localStorage.getItem("color");
//   // [2] Remove Active Class From All Lis
//   lis.forEach((li) => {
//     li.classList.remove("active");
//   });
//   // [3] Add Active Class To Current Color
//   document.querySelector(`[data-color="${window.localStorage.getItem("color")}"]`).classList.add("active");
// }

// lis.forEach((li) => {
//   li.addEventListener("click", (e) => {
//     // console.log(e.currentTarget.dataset.color);
//     // Remove Active Class From all Lis
//     lis.forEach((li) => {
//       li.classList.remove("active");
//     });
//     // Add Active Class To Current Element
//     e.currentTarget.classList.add("active");
//     // Add Current Color To Local Storage
//     window.localStorage.setItem("color", e.currentTarget.dataset.color);
//     // Change Div Background Color
//     exp.style.backgroundColor = e.currentTarget.dataset.color;
//   });
// });

// another answer without localStorage 
// let container = document.querySelector(".experiment")

// document.addEventListener("click", function(e){
//   // container.style.backgroundColor = e.target.attributes.getNamedItem("data-color").value
//   container.style.backgroundColor = e.target.dataset.color
// })


//-----------------Destructuring Array from ElZero (availabe aslo at ES6)----------------------
// let a = 1;
// let b = 2;
// let c = 3;
// let d = 4;

// let myFriends = ["Ahmed", "Sayed", "Ali", "Maysa"];
// Destruction Array should not be same no. -- you can write [a, b, c] = myFriends
// [a, b, c, d] = myFriends;
// console.log(a)

// [a = "A", b, c, d, e = "Osama"] = myFriends;
// console.log(a); // a = Ahmed because it have value in array 
// console.log(e) // e = Osama because it does not have value in array so take default value "Osama"
// // if you want to skip value in array leave space
// let [x, y, , z] = myFriends;
// console.log(z)

// let myFriends = ["Ahmed", "Sayed", "Ali", ["Shady", "Amr", ["Mohamed", "Gamal"]]];
// console.log(myFriends[3][2][1]);

// let [ , , , [ a, , [ , b]]] = myFriends;

// console.log(a);
// console.log(b);

// because string assigned by value not reference
// let book = "Video";
// let video = "Book";
// // Save Book Value In Stash
// let stash = book;
// // change book value
// book = video;
// // change video value
// video = stash;

// console.log(video, book)

// or you can use Destructuring Array to swap variables
// [book, video] = [video, book];
// console.log(video, book);

// you can use spread operator to get rest of elements in Array 
// const [x,...rest] = myFriends
// console.log(rest)

// you can use Destructuring Array with function return multiple values
// function stat(a, b) {
//   return [
//       a + b,
//       (a + b) / 2,
//       a - b
//   ]
// }
// let [sum, average, difference] = stat(20, 10);
// console.log(sum, average, difference); // 30, 15, 10

// we can use Destructuring Array to get index of array with entries() method
// let arr = [ "One","Two","Three","Four"]
// let arrIn = arr.entries()
// console.log(arrIn.next())
// console.log(arrIn.next())
// console.log(arrIn.next())
// console.log(arrIn.next())
// console.log(arrIn.next())
// for([index, value] of arrIn ) {
//   console.log(index , value)
// }

//------------------Destructuring Object From Elzero--------------------

// const user = {
//   theName : "Osama",
//   theAge : 39 ,
//   theTitle : "Developer",
//   theCountry : "Egypt",
//   theColor: "Black",
//   skills : {
//     html: 70,
//     css: 80,
//   }
// };


// let theName = user.theName ;
// let theAge = user.theAge;
// let theTitle = user.theTitle;
// let theCountry = "USA";

// if you update Value you should write () no need of () in Destructuring Array
// ({theName, theAge, theTitle, theCountry} = user); 
// if you create variable you don't need ()
// let {theName, theAge, theTitle, theCountry} = user;
// no need for skiping here you can write 3 variable = object has 4 properites but vairable should be same name of properity
// let{theName, theAge, theCountry} = user;
// console.log(theCountry)

// if you want to change the name of variable you should keep same name of property then : a like theName : a
// const { theName : a, theAge : b, theCountry} = user;
// console.log(a, b)

// if you give variable a value and the Object has same properity with default value | value from main Object will override
// const { theName : a, theAge : b, theCountry, theColor = "Red"} = user;
// console.log(theColor); // Black
// const { theName : a, theAge : b, theCountry, theColor : co = "Red", skills : { html : h, css : c}} = user;
// console.log(co);
// console.log(`My HTML Skills Progress Is ${h}`);
// console.log(`My Css Skills Progress Is ${c}`);

// you can target nested Object
// const { html : skillOne, css : skillTwo } = user.skills;

// console.log(`My HTML Skills Progress Is ${skillOne}`);
// console.log(`My Css Skills Progress Is ${skillTwo}`);

// function showDetails(obj) {
//   console.log(`Your Name Is ${obj.theName}`)
//   console.log(`Your Age Is ${obj.theAge}`)
//   console.log(`Your Css Skills Is ${obj.skills.css}`)
//   console.log(`Your Css Skills Is ${c}`)
// }
// function showDetails({theName : n, theAge : a, skills: {css : c}} = user) {
//   console.log(`Your Name Is ${n}`)
//   console.log(`Your Age Is ${a}`)
//   console.log(`Your Css Skills Is ${c}`)
// }

// showDetails(user);

// const user = {
//   theName: "OSama",
//   theAge: 39,
//   skills: ["HTML", "Css", "JavaScript"],
//   addresses: {
//     egypt: "Cairo",
//     ksa: "Riyadh",
//   },
// };


// const {theName : n, theAge : a , skills: [one, two, three], addresses: {egypt : e}} = user;

// console.log(`Your Name is : ${n}`)
// console.log(`Your Age is : ${a}`)
// console.log(`Your Skills is : ${one} , ${two} , ${three}`)
// console.log(`Your Adress is : ${e} `)

//  ------- Challenge -----------

// let chosen = 1; 

// let myFriends = [
//   {title: "Osama" , age :39, available: true, skills: ["HTML", "CSS"]  },
//   {title: "Ahmed" , age :25, available: false, skills: ["Python", "Django"]  },
//   {title: "Sayed" , age :33, available: true, skills: ["PHP", "Laravel"]  },
// ];

// for (let i = 0; i < myFriends.length; i++) {
//   if (myFriends[i].available) {
//     myFriends[i].available = "Availabe"
//   }else {
//     myFriends[i].available = "Not Availabe"
//   }
// }

// if ( chosen === 1) {
//   const {title, age, available, skills : [,last] } = myFriends[chosen - 1];
//   console.log(title)  
//   console.log(age)  
//   console.log(available)  
//   console.log(last)  
// }
// if ( chosen === 2) {
//   const {title, age, available, skills : [,last] } = myFriends[chosen - 1 ];
//   console.log(title)  
//   console.log(age)  
//   console.log(available)  
//   console.log(last)  
// }
// if ( chosen === 3) {
//   const {title, age, available, skills : [,last] } = myFriends[chosen - 1];
//   console.log(title)  
//   console.log(age)  
//   console.log(available)  
//   console.log(last)  
// }

// ----Another Answer ----

// (function getDevData({title, age, available, skills: [one, two]} = myFriends[chosen - 1]) {

//   console.log(title);
//   console.log(age);
//   console.log(available ? 'available' : 'not available');
//   console.log(two);

// })()


// ---------Set Data and Data Type (avaialbe also at ES6)--------
// set Methods ( add() , delete(), has(), clear(), forEach(), values(), keys(), entires() )
// let myData = [1, 1, 1, 2, 3, "A"];
// let myData = "Soliman";
// store only unique data so will store 1 only one time and will store as Object
// let myUniqueData = new Set(myData)
// let myUniqueData = new Set().add(1).add(1).add(1).add(2).add(3)
// let myUniqueData = new Set()
// myUniqueData.add(1).add(1).add(1);
// myUniqueData.add(2).add(3).add("A");
// myUniqueData.delete(2)
// myUniqueData.clear()
// console.log(myUniqueData.entries())
// console.log(myData);
// console.log(myUniqueData)
// // Set has properity like length called size
// console.log(myUniqueData.size)
// for ( x of myUniqueData) {
//   console.log(x) // 1 2 3 A
// }
// for ( x of myUniqueData.entries()) {
//   console.log(x) // [1, 1] [2, 2] [3, 3] [A, A]
// }
// for ( x of myUniqueData.keys()) {
//   console.log(x) // 1 2 3 4 A
// }
// for ( x of myUniqueData.values()) {
//   console.log(x) // 1 2 3 4 A
// }

// console.log(myUniqueData.has("A")) //will search if found give true if not false
// console.log(myUniqueData.has("a".toUpperCase())) //will search if found give true if not false

// to convert Set to Array use spread operator or Array.from
// let str = "soliman"
// let setStr = new Set(str)
// let arrSetStr = [...setStr]
// let arrSetStrKeys = [...setStr.keys()]
// console.log(arrSetStr)
// console.log(arrSetStrKeys)

// let myArray = [1,1,1,2,3,4];
// let mySet = new Set(myArray)
// console.log(mySet)
// console.log(Array.from(mySet))


// new Set will accept only iterable but can store any type of values even undefined of NaN
// equality in set different NaN !== NaN but in set equal
// let array = [NaN, undefined, NaN, undefined]
// let setArr = new Set(array)
// console.log(setArr)

//-------------Difference between Set and Weak Set-----------------

// set accept any type of data (even NAN or undefined) ( must be inside iteralbe like array or string)
// set.values() and set.keys() both return an Iterator with [value] all the values in a Set
// Set.entries() returns an iterator with the [value,value] pairs from a Set
// weak set accept only collection of unique Objects ( objects inside array)
// WeakSet does not have keys() , values(), entries(), clear(), forEach()
// WeakSet methods ( add() , delete(), has())
// set has size property
// weak set has no size property
// if no other references to an object stored in the Weakset exist, those Objects can be garbage collected
// Set is iterable 
// weakSet is not iterable (because does not has size property) so can not use for...of loop on it
// Set does not has keys so you can not use mySet[1] like array myArr[1]

// ------------------keys and values in Object----------------- 
// let obj = { 
//   3 : "a",
//   5 : "b",
//   2 : "c",
// }

// let objKeys = Object.keys(obj)
// let objValues = Object.values(obj)
// // will sort keys ascending
// console.log(objKeys)
// // will sort value according to it's keys // output ["c", "a", "b"]
// console.log(objValues)

// let mySet = new Set([1, 1, 1, 2, 3, "A", "A"]);
// console.log(mySet.size) //4

// let iterator = mySet.values(); // you can write keys or values same thing
// console.log(iterator)
// will give you value and done:false till reach UNDEFINED (finish all values and can not find anything) value the done true
// console.log(iterator.next()) 
// console.log(iterator.next()) 
// console.log(iterator.next())
// console.log(iterator.next()) 
// console.log(iterator.next())

// mySet.forEach((e) => console.log(e) )


// let myWeakSet = new WeakSet([{A: 1, B: 2},{A: 1, B: 2}]);
// console.log(myWeakSet)
// let iterator = myWeakSet.values(); // Error no values in WeakSet
// console.log(iterator.next()) // Error

// equality in weakSet 
// let a = {a: "s"}
// let b = a
// console.log( a === b) //true because assigned by reference
// let c = {a: "s"}
// let d = {a: "s"}
// console.log( c === d) //false different references
// let array = [a,b]
// let array2 = [c,d]
// let weak = new WeakSet(array)
// let weak2 = new WeakSet(array2)
// console.log(weak) //one object because a = b (weak set accept only collection of unique Objects)
// console.log(weak2) // two objects

/* 

-------------difference between Map and Set---------------
A Set is a collection dataset that needs to be composed of unique values, 
where a Map is when you have pairs of associated data when we map the keys to the value. 
Map and Set both have similar methods; these include .has(), .get(), .delete(), and .size().
The difference is that a Map comes with a key/value pair, two dimensions.
keys() and values() give you in set same result [value] but in Map different [key] or [value]
We can convert an array to set as well as a 2D array to map:

let array=[1,2,3,4]
const set1 = new Set (array);

let map=[['one', 1], ['two', 2], ['three', 3],
['four',4]]
const map1= new Map (map) ;

*/

// ----------------Map Data Type vs Object--------------------
// Map Accept (iterable with Key/Value)

/* Map => Does not Contain Key By default
  Object => Has Default Keys

  Map => Key can be Anything [Function, Object, Any Primitive Data Types]
  Object => String or Symbol (will converted into string see exp. below)

  Map => Ordered By Insertion
  Object => Not 100% Till Now

  Map => Get Items By Size
  Object => Need to Do Manually ( Object.keys(myObject).length)

  Map => Can Be Directly iterated
  Object => Not Directly and Need TO use Object.keys() and so on

  Map => Better Performance When Add or Remove Data
  Object => Low Performance Comparing To Map
  */

  /*
  A Map is ordered and iterable, whereas a objects is not ordered and not iterable
  We can put any type of data as a Map key, whereas objects can only have a string, or symbol as a key.
  A Map inherits from Map.prototype. 
  This offers all sorts of utility functions and properties which makes working with Map objects a lot easier
  */

// later Q after OOP
// let myObj = {};
// // to create Object with no default keys
// A javascript object inherits from Object by default, 
// unless you explicitly create it with null as its prototype, like: Object.create(null).
// let myEmptyObject = Object.create(null)

// -----some Exp. to know the difference between Map and Normal Object :

// let myMap = new Map();
// let myNewObject = {
//   10 : "Number",
//   "10" : "String",
// }
// with number you can not write (myNewObject.10) should be like this myNewObject[10]
// "10" will override 10 because object will accpet only string or symbol so will convert 10 to "10"
// console.log(myNewObject[10])

// let myNewMap = new Map()
// myNewMap.set(10, "Number");
// myNewMap.set("10", "String");
// console.log(myNewMap.get(10))
// console.log(myNewMap.get("10"))
// console.log(myNewMap)

// Map has Size but Object don't to get length of Object use keys() that put keys of object in Array then use length on that Array
// var size = Object.keys(myObj).length;

// we can not use object as keys in normal Objects
// let a = { name : "Soliman"}
// let b = { name : "Hussein"}
// let people = {}
// people[a] = "Developer" // with object will consider key a as [ object object]
// people[b] = "JavaScipt" // with object will consider key b as [ object object] so will override
// console.log(people[a]) // JavaScipt
// console.log(people[b]) // JavaScipt

// here map accept object as a key
// let map = new Map()
// map.set(a, "Developer")
// map.set(b, "JavaScipt")
// console.log(map.get(a)) // Developer
// console.log(map.get(b)) // JavaScript




//  Map Methods (set(), get() , delete(), has(), clear(), forEach(), values(), keys(), entires())

// let myMap = new Map([
//   [10, "Number"],
//   ["Name", "String"],
//   [false, "Boolean"]
// ]);

// myMap.set(10, "Number");
// myMap.set("Name", "String");

// console.log(myMap.get(10))
// console.log(myMap.get("Name"))
// console.log(myMap.get(false))

// console.log(myMap.delete("Name"))
// myMap.clear();
// console.log(myMap);

// console.log(myMap.has(false))

// to add object to map use Object.entries()
// let myInfo = {
//   username: "Osama",
//   role: "Admin",
//   country: "Egypt",
// };

// let myInfoMap = new Map(Object.entries(myInfo))
// console.log(myInfoMap)

// -----------Map Vs Weak Map---------------

// Map => keys can be Anything
// Weak Map => key can be Object Only
// Map is iterable
// WeakMap is not iterable (because does not has size property)
// Map has size properity
// WeakMap Does not have size
// WeakMap Methods (set(), get() , delete(), has() ) only
// if no other references to an object stored in the WeakMap (as key) exist,
//  those Objects can be garbage collected


// let mapUser = {theName: "Elzero"}
// let myMap = new Map();
// myMap.set(mapUser, "Object Value")
// mapUser = null;
// // here mapUSer has no references but it will not removed by garbage collector
// console.log(myMap)
// console.log(mapUser)

// let weaKMapUser = {theName: "Elzero"}
// let myWeakMap = new WeakMap();
// myWeakMap.set(weaKMapUser, "Object Value")
// weaKMapUser = null;
// // here weaKMapUser has no references and will be removed by garbage collector
// console.log(myWeakMap)

// let arr = ["Osama","Ahmed"]
// // let ite = arr.keys()
// let ite = arr.values()
// console.log(ite)
// console.log(ite.next())
// console.log(ite.next())
// console.log(ite.next())
// // make Object iterable
// let obj = { Osama : "dev" , Age : 39}
// let arrObj = Object.keys(obj)
// let arrObj = Object.entries(obj)
// let iteObj = arrObj.values()
// console.log(iteObj)
// console.log(iteObj.next())
// console.log(iteObj.next())
// console.log(iteObj.next())

// -----------------Array.From 
// accept (Iterable, MapFunc, This)

// // Iterable
// console.log(Array.from("Osama"))
// // not Iterable
// console.log(Array.from(12345))
// // iterable
// console.log(Array.from("12345"))
// // function
// console.log(Array.from("12345", function(n) {
//   return +n + +n
// } ));
// // Arrow Function
// console.log(Array.from("12345",(n) =>  +n + +n ));
// let myArray = [1,1,1,2,3,4];
// let mySet = new Set(myArray)
// console.log(mySet)
// console.log(Array.from(mySet))
// // Spread Operator (future)
// console.log([...new Set(myArray)])

// function testArgs () {
//   return arguments;
// }

// console.log(testArgs("Osama", "Ahmed"))

// function af () {
//   return Array.from(arguments);
// }

// console.log(af("Osama", "Ahmed"))

//-----------------Array.copywithin 
// Array.copywithin(Target, Start => Optional, End => Optional)
// target = where to copy // start of the copied part // End of the copied part 
// but will not increase Array length
// Copy Part of an Array to Another Location in the Same Array

// let myArray = [10, 20, 30, 40, 50, "A", "B"];

// myArray.copyWithin(3);
// myArray.copyWithin(4, 6);
// myArray.copyWithin(4, -1);
// myArray.copyWithin(1, -2 );
// myArray.copyWithin(1, -2 , -1);

// console.log(myArray);

// -----------Array.some
// Array.some(callbackFunc(Element, Index, Array), This Argument)
// Array.some check every element of array if exist return true


// let nums = [1, 2, 3, 4, 5, 6, 7]

// let myNumber = 5;

// let check = nums.map(function(e) {
//   return e > 5;
// })

// Array.some check every element of array if exist return true
// if we use Array.map will return [false, false, false, false, false, true, true]
// console.log(check)

// if we transfere array to set we can use has properity but will return true only if array has 5 
// not to check every element and check if there is elements larger than 5
// let numsSet = new Set(nums)
// console.log(numsSet.has(5))

// filter will give new Array not return true or false like Array.some
// let numsFilter = nums.filter((e) => e > 5)
// console.log(numsFilter)


// let check = nums.some(function(e) {
//   console.log(this)
//   return e > this;
// }, myNumber)

// console.log(check)

// function checkValues (arr, val) {
//   return arr.some(function (e) {
//     return e === val; 
//   })
// }

// console.log(checkValues(nums, 6))

// let range = {
//   min : 10,
//   max : 20,
// }


// let checkRange = nums.some(function(e) {
//   return e >= this.min && e <= this.max 
  
// }, range)

// console.log(checkRange)

// ---------------------Array.ervery 
// unlike some 
// Every means every element must be the condition you write but some will return true only if one element 


// const locations = {
//   20: "Place 1",
//   30: "place 2",
//   10: "Place 3",
//   40: "Place 4",
// };

// let mainLocation = 15;

// let locationsArray = Object.keys(locations)


// let locationsArrayNumbers = locationsArray.map((n) => +n) 

// let check = locationsArray.every(function(e) {
//   console.log("hi")
//   return e > this;
// }, mainLocation)

// console.log(check)



// ------------------spread operator form Elzero (availabe also at ES6)

// // Spread String
// console.log("Osama")
// console.log(..."Osama")
// console.log([..."Osama"])

// use cases of Spread Operator
// [1] Concatenate Arrays

// let myArray1 = [1, 2, 3];
// let myArray2 = [4, 5, 6];
// console.log([...myArray1, ...myArray2])
// console.log(myArray1.concat(myArray2))

// [2] Copy Array

// let copiedArray = [...myArray1]
// console.log(copiedArray)

// [3] Push inside Array

// let allFriends = ["Osama", "Ahmed", "Sayed"];
// let thisYearFriends = ["Sameh", "Mahmoud"];

// allFriends.push(thisYearFriends) // will push thisYearFriends as Array inside Array
// allFriends.push(...thisYearFriends) // will spread and merge
// console.log(allFriends);

// [4] Math Object

// let myNums = [10, 20, -100, 100, 1000, 500];
// console.log(Math.max(myNums)) // NaN
// console.log(Math.max(...myNums)) 

// [5] Spread With Objects => Merge Objects

// let objOne = {
//   a:1,
//   b:2,
// }
// let objTwo = {
//   c:3,
//   d:4,
// }

// console.log({...objOne, ...objTwo})


// ---------------Challenge---------------

// let n1 = [10, 30, 10, 20];
// let n2 = [30, 20, 10];

// console.log(Number([[n2.pop(), n1.pop()].length , Math.min(...n1)].toString().split(",").join("")));
// console.log([...n1, ...n2].length * Math.max(...n2));
// console.log(n1.reduce((el1 , el2) => el1 + el2) * n2.length)

// ----------------------------Regular expressions--------------------------
/* 
Regular expressions are patterns used to match character combinations in strings. 
In JavaScript, regular expressions are also objects. 
These patterns are used with the exec() and test() methods of RegExp, 
and with the match(), matchAll(), replace(), replaceAll(), search(), and split() methods of String.

** Creating a regular expression: 
[1] regular expression literal : 
const re = /ab+c/;
[2] constructor function of the RegExp object, as follows:
const re = new RegExp('ab+c');

** Methods of RegExp  :
- exec() : Executes a search for a match in a string. It returns an array of 
information or null on a mismatch.
- test() : Tests for a match in a string. It returns true or false.
- complie() : (Re-)compiles a regular expression during execution of a script.
- toString() : Returns a string representing the specified object. Overrides the Object.prototype.toString() method.
[@@....] === [Symbol....]
- [@@match]() : Performs match to given string and returns match result.
- [@@matchAll]() : Returns all matches of the regular expression against a string.
- [@@replace]() : Replaces matches in given string with new substring.
- [@@search]() : Searches the match in given string and returns the index the pattern found in the string.
- [@@split]() : Splits given string into an array by separating the string into substrings.


** Method of String used with RegExp :
- match() : Returns an array containing all of the matches, including capturing groups, or null if no match is found.
- matchAll() : Returns an iterator containing all of the matches, including capturing groups.
- search() : Tests for a match in a string. It returns the index of the match, or -1 if the search fails.
- replace() : Executes a search for a match in a string, and replaces the matched substring with a replacement substring.
- replaceAll() : Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring.
- split() : Uses a regular expression or a fixed string to break a string into an array of substrings.

** they give you same result => 

-Method of RegExp : 
reg[Symbol.match](txt) 
is the same 
-Method of String used with RegExp:
txt.match(reg)

** Instance properties : 
RegExp.prototype.flags : A string that contains the flags of the RegExp object.
RegExp.prototype.dotAll : Whether . matches newlines or not.
RegExp.prototype.global : Whether to test the regular expression against all possible matches in a string, or only against the first.
RegExp.prototype.hasIndices : Whether the regular expression result exposes the start and end indices of captured substrings.
RegExp.prototype.ignoreCase : Whether to ignore case while attempting a match in a string.
RegExp.prototype.multiline : Whether or not to search in strings across multiple lines.
RegExp.prototype.source : The text of the pattern.
RegExp.prototype.sticky : Whether or not the search is sticky.
RegExp.prototype.unicode : Whether or not Unicode features are enabled.
RegExp: lastIndex : The index at which to start the next match.

Modifiers Flags :
i => case insensitive ( if you write it it will search for both capital and small)
g => global search (if you did not add g will retrun Array of information with first element match)
m => mutlilines.
d =>  The "d" flag indicates that the result of a regular expression match should contain the start and end indices of the substrings of each capture group.
s =>  Allow . to match new line character. 
u => "unicode"; treat a pattern as a sequence of unicode code points.
y => Perform a "sticky" search that matches starting at the current position in the target string.(https://javascript.info/regexp-sticky)

Character classes:
// . => matches any Character , except newLine and another line terminators (with s flag . will match new line charachter)
// \w => matches word characters. [a-z, A-Z, 0-9 And Underscore]
// \W => matches non Word Characters
// \d => matches digits from 0 to 9
// \D => matches non-digits characters
// \s => matches Whitespaces
// \S => matches non Whitespaces charachter
// there is more in link below

Quantifiers :
// n+ => One Or More
// n* => Zero or More
// n? => Zero or One
// n{x} => Number of
// n{x,y} => Range
// n{x, } => At Least x
// there is more in link below

Assertions : 
// \b => matches at the beginning or end of a word
// \B => matches Not at the beginning / end of a word
// $ => End With Something
// ^ => Start With something
// ?= => followed By something (lookahead)
// ?! => Not followed By Something (negative lookahead)
// ?<! => Lookbehind 
// ?>! => negative Lookbehind
// there is more in link below

Group: 
() => to capture group
(?<groupName>) => to write your own group name
(?:) => to not capturing this group

Intro to Regular Expression:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions

Main Document for Regular Expression: 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp

Regular expression syntax cheatsheet:
(Character classes - Assertions - Group and Ranges - Quantifiers - Unicode property escapes) 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet

Regular Expressions Groups and Ranges: 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges

Stick flag read this to understand index and lastIndex :
https://javascript.info/regexp-sticky

Quick Review  Based on YouTube Video(https://youtu.be/rhzKDrUiJVk)
useful Web-Site to test Regular Expression (https://regexr.com)

The difference between ?= and ?! is that the former requires the given expression to match 
and the latter requires it to not match. For example a(?=b) will match the "a" in "ab", 
but not the "a" in "ac". Whereas a(?!b) will match the "a" in "ac", but not the "a" in "ab".
The difference between ?: and ?= is that ?= excludes the expression from the entire match 
while ?: just doesn't create a capturing group. So for example a(?:b) will match the "ab" in 
"abc", while a(?=b) will only match the "a" in "abc". a(b) would match the "ab" in "abc" and 
create a capture containing the "b".
*/
// ---------------match() vs exec()----------------
/* 
[1] exec() :
* is a Method of RegExp
* return Array of Information
* with g flag returns each match and its position iteratively

[2] match() :
* is a Method of String
* return normal Array
* with g flag returns all matches at once, but without their position.

both without using g flag return Array of information with first match

*/

// regular expression literal
// const myRe = /d(b+)d/g;
// or constructor function of the RegExp object
// const myRe = new RegExp('d(b+)d', 'g'); // or const myRe = new RegExp(/d(b+)d/, 'g'); 
// const execArray = myRe.exec('cdbbdbsbz'); // Method of RegExp
// const matchArray = ('cdbbdbsbz').match(myRe); // Method of String used with RegExp
// console.log(execArray) // Array of information
// console.log(matchArray) // Normal Array 

// // if you use regular expression directly without assigning it to variable you cannot acccess
// // properties of Array of information because every occurrence is a new regular expression 
// let myArray = myRe.exec('cdbbdbsbz');
// console.log(`The value of lastIndex is ${myRe.lastIndex}`); // 5
// console.log(`The value of index is ${myArray.index}`); // 1
// let myRe2 = /bsbz/g
// let myArray2 = myRe2.exec('cdbbdbsbz');
// // 0 because we are checking for lastIndex of regExp object and not yet excuted so lastIndex still 0
// console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`);  // 0 
// console.log(`The value of lastIndex is ${myRe2.lastIndex}`); // 9
// console.log(`The value of index is ${myArray2.index}`); // 5

// //----------Using regular expression on multiple lines
// let s = 'Please yes\nmake my day!'
// let m1 = s.match(/yes.*day/); // Returns null becaue . does not match line terminator
// let m1 = s.match(/yes.*day/s); // we added s flag now . will match new line charachter
// let m2 = s.match(/yes[^]*day/g); // we can not use \n because \ will change effect of *
// console.log(m1)// Returns null
// console.log(m2)// Returns ["yes\nmake my day"]

// // ---Using the global search flag with exec()
// // RegExp.prototype.exec() method with the g flag returns each match and its position iteratively.
// const str = 'fee fi fo fum';
// const re = /\w+\s/g;
// console.log(re.exec(str)); // ["fee ", index: 0, input: "fee fi fo fum"]
// console.log(`The value of lastIndex is ${re.lastIndex}`); // 4
// console.log(re.exec(str)); // ["fi ", index: 4, input: "fee fi fo fum"]
// console.log(`The value of lastIndex is ${re.lastIndex}`); // 7
// console.log(re.exec(str)); // ["fo ", index: 7, input: "fee fi fo fum"]
// console.log(`The value of lastIndex is ${re.lastIndex}`); // 10
// console.log(re.exec(str)); // null
// // In contrast,match() method returns all matches at once, but without their position.
// console.log(str.match(re)); // ["fee ", "fi ", "fo "]

// // -----------Exp. using Group and sticky flag 
// let personList = `First_Name: John, Last_Name: Doe
// First_Name: Jane, Last_Name: Smith`;
// // to write group name you can use ?<Group Name> without group name the default names will be $1 $2
// let regexpNames =  /First_Name: (?<firstname>\w+), Last_Name: (?<lastname>\w+)/y;
// // with sticky flag you can use lastIndex to determine the starting index of searching 
// regexpNames.lastIndex = 33 // Jane Smith without will be John Doe
// let match = regexpNames.exec(personList)
// console.log(match.groups.firstname,match.groups.lastname )
// console.log(match)

// --------Using regular expression to split lines with different line endings/ends of line/line breaks
// let text = 'Some text\nAnd some more\r\nAnd yet\rThis is the end'
// let lines = text.split(/\r\n|\r|\n/) // /\r\n|\r|\n/ this format compatible with all browsers
// console.log(lines) // logs [ 'Some text', 'And some more', 'And yet', 'This is the end' ]

// // --------Using a regular expression to change data position
// In the replacement text, the script uses $1 and $2 to indicate the results of the 
// corresponding matching parentheses in the regular expression pattern.
// let re = /(\w+)\s(\w+)/
// let str = 'John Smith'
// let newstr = str.replace(re, '$2 $1')
// console.log(newstr) // Smith John

// //-----difference between global flag and sticky flag
// re = /\d/y;
// // will stop because of space between 3 and 4 lastIndex will stop at 3 
// // and exec function needs lastIndex 4 to continue
// while (r = re.exec("123 456")) console.log(r, "AND re.lastIndex", re.lastIndex); 
// let re2 = /\d/g;
// // will continue till 6 because will search globally because of g flag not waiting lastIndex like sticky flag
// while (r2 = re2.exec("123 456")) console.log(r2, "AND re2.lastIndex", re2.lastIndex);

// -------Lookbehind & Lookahead
// // Lookbehind
// let str1 ="we love soliman"
// let reg1 = /(?<=soli)\w+/g
// console.log(str1.match(reg1)) // man
// // negative Lookbehind
// let str2 ="we love soliman"
// let reg2 = /(?<!we\s)\w{4,}/g 
// console.log(str2.match(reg2)) // soliman
// // Lookahead
// let str3 ="we love2 soliman"
// let reg3 = /\w+(?=2)/g
// console.log(str3.match(reg3)) // love
// // negative Lookahead
// let str4 ="we love soliman"
// let reg4 = /\w{4,}(?!\s)/g // soliman
// console.log(str4.match(reg4))

// // ------back reference
// // \1 to refere to last captured group inside same regular expression
// // \k<groupName> to refere to last captured named group inside same regular expression
// let str = "Mohamed Ahmed Ahmed Soliman"
// let reg = /(\w+)\s\1/g
// let reg = /(?<myName>\w+)\s\k<myName>/g 
// console.log(str.match(reg)) // Ahmed Ahmed

// -------------ElZero RegExp
// let myString = "elzero web school"
// let regularExpression = /elzero/i;
// console.log(myString.match(regularExpression))

// let tld = "Com Net Org Info Code Io"
// let tldRe = /(org|info|io)/ig
// console.log(tld.match(tldRe))

// let nums = "12345678910";
// // Range
// let numsRe = /[0-9]/;
// console.log(nums.match(numsRe))

// let notNums = "12345678910";
// // will return all except no. in this Range
// let notNumsRe = /[^0-2]/g;
// console.log(notNums.match(notNumsRe))


// let specialtNums = "1!2@3#4$5%678910";
// let specialtNumsRe = /[^0-9]/g;
// console.log(specialtNums.match(specialtNumsRe))


// let Practice = "Os1 Os10os Os2 Os8 Os8Os";
// let PracticeRe = /Os[0-9]Os/ig;
// console.log(Practice.match(PracticeRe))


// let myString = "AaBbcdefG123!234%^&*"
// let atozSmall = /[a-z]/g;
// let NotatozSmall = /[^a-z]/g;
// let atozCapital = /[A-Z]/g;
// let NotatozCapital = /[^A-Z]/g;
// let aAndcAnde = /[ace]/g
// let NotaAndcAnde = /[^ace]/g
// let capitalAndSmall = /[a-z]/ig
// let capitalAndSmall2 = /[a-zA-Z]/g
// let notCapitalAndSmall = /[^a-zA-Z]/g
// let specials = /[^a-zA-Z0-9]/g
// let specials2 = /[^a-z^A-Z0-9]/g

// console.log(myString.match(notCapitalAndSmall ));

// let email = "O@@@g...com O@g.com O@g.net A@Y.com O-g.com o@s.org 1@1.com";
// let dot = /./g;
// let w = /\w/g;
// let W = /\W/g;
// i added \ (to Escape charachter)before . because . match any charachters but if i add \. will match . only (not mentioned in elzero course)
// let validEmail = /\w@\w\.(com|net)/g;
// console.log(email.match(validEmail))

// let names = "Sayed 1Spam 2Spam 3Spam Spam4 Spam5 Osama Ahmed Aspamo";

// let re = /Spam/ig;
// let re = /\BSpam/ig;
// let re = /Spam\b/ig;
// let re = /(\bspam|spam\b)/ig;
// console.log(names.match(re))

// // Test Method
// pattern.test(input) //retrun true or false

// console.log(re.test(names))
// console.log(/(\bspam|spam\b)/ig.test("Osama"))
// console.log(/(\bspam|spam\b)/ig.test("1Spam"))

// let mails = "o@nn.sa osama@gmail.com elzero@gmail.net osama@mail.ru";
// let mailRe = /\w@\w\w\.sa/ig
// let mailRe = /\w+@\w+\.(com|net)/ig
// let mailRe = /\w+@\w+.\w+/ig
// console.log(mails.match(mailRe))

// let nums = " 0110 010 150 05120 0560 350 00"
// let numsRe = /0\d+0/ig;
// let numsRe = /0\d*0/ig;
// let numsRe = /0\d?0/ig;
// console.log(nums.match(numsRe))

// let urls ="https://google.com http://www.website.net web.com"
// let urlsRe = /https/ig;
// let urlsRe = /https?:\/\/(www.)?\w+\.\w+/ig;
// let urlsRe = /(https?:\/\/)?(www.)?\w+\.\w+/ig;
// console.log(urls.match(urlsRe))

// let serials = "S100S S3000S S50000S S950000S ";

// console.log(serials.match(/S\d{3}S/ig))
// console.log(serials.match(/ S\d{4,5}S/ig))
// console.log(serials.match(/S\d{4,}S/ig))

// let myString = "We Love Programming"
// let names = "@1OsamaZ 2AhmedZ 3Mohammed 4MoustafaZ 5GamalZ"

// console.log(/ing$/ig.test(myString))
// console.log(myString.match(/\w+ing$/ig))
// difference between ^ (not) and ^ (start with something) | not should be inside []
// console.log(/^We/ig.test(myString))
// console.log(myString.match(/[^We]/ig))
// console.log(/lz$/ig.test(names))
// // \s means whitespace
// will return false because @1OsamaZ does not start with words but if @ at 2nd value @2AhmedZ will return true because it found 1OsamaZ without @
// console.log(/^\w/ig.test(names))
// // here will output element + Z
// console.log(names.match(/\d\w{5}Z/ig))
// here will output element without Z 
// console.log(names.match(/\d\w{5}(?=Z)/ig))
// console.log(names.match(/\d\w{8}(?!Z)/ig))
// difference between $ and \b 
// console.log(myString.match(/\w+$/ig)) // [Programming] will match last word only
// console.log(myString.match(/\w+e\b/ig)) // will match ever word end with e not last word in string

/* -------multiline mode--------
The multiline mode is enabled by the flag m.
It only affects the behavior of ^ and $.
In the multiline mode they match not only at the beginning and the end of the string, 
but also at start/end of line.
That’s because by default a caret ^ only matches at the beginning of the text, 
and in the multiline mode – at the start of each line.

let str = `1st place: Winnie
2nd place: Piglet
3rd place: Eeyore`;
console.log( str.match(/^\d/gm) ); // 1, 2, 3

let str = `1st place: Winnie 2nd place: Piglet 3rd place: Eeyore`;
console.log( str.match(/^\d/gm) ); // 1
*/

/* ---- diference between \n and $

let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;
console.log( str.match(/\d$/gm) ); // 1,2,3

let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;
console.log( str.match(/\d\n/g) ); // 1\n,2\n

there are 2 matches instead of 3.
That’s because there’s no newline after 3 (there’s text end though, so it matches $).
Another difference: now every match includes a newline character \n. Unlike the anchors ^ $, 
that only test the condition (start/end of a line), \n is a character, so it becomes a part of the result.
So, a \n in the pattern is used when we need newline characters in the result, 
while anchors are used to find something at the beginning/end of a line.
*/

// Replace and ReplaceAll
// let txt = "We Love Programming And @ And @ IS Amazing"
// will replace the first @ only
// console.log(txt.replace("@", "JavaScript"))
// console.log(txt.replaceAll("@", "JavaScript"))
// let txtRe = /\b\w{3}(?=\s)/ig; // to replace with and
// let txtRe = /@/ig; // to replace with @
// console.log(txt.replaceAll(txtRe, "JavaScript"))
// console.log(txt.replaceAll(/@/ig, "JavaScript"))

//  Form Validation
/* 
The onsubmit event handler announces its decision by the value the code returns. 
If a return value of true is received, then the current form submission is allowed to continue.
If the return value is false, then the current form submission is stopped in its tracks.
*/
// document.getElementById("register").onsubmit = function () {
//   let phoneInput = document.getElementById("phone").value;
//   let phoneRe = /\(\d{4}\)\s\d{3}-\d{4}/;
//   let validationResult = phoneRe.test(phoneInput);
//   if (validationResult === false) {
//     return false
//   }
//   return true
// }


// -----------Challenge--------

// let url1 = "elzero.org"
// let url2 = "http://elzero.org"
// let url3 = "https://elzero.org"
// let url4 = "https://www.elzero.org"
// let url5 = "https://www.elzero.org:8080/atricles.php?id=100&cat=topics"
// let url6 = "elzeroorg"


// let re = /(https?)?:?(\/\/)?(www.)?\w+\.\w+(:\d+\/\w+\.\w+\?\D+\d+\D+)?/ig;
// let re = /(https?:\/\/)?(www.)?\w+\.\w+(:\d+\/\w+.\w+\?\w+=\d+&\w+=\w+)?/ig;

// console.log(url1.match(re))
// console.log(url2.match(re))
// console.log(url3.match(re))
// console.log(url4.match(re))
// console.log(url5.match(re))
// console.log(url6.match(re))
// console.log(re.test(url6))


// -------------------Object Oriented Programming---------

/* 
The idea behind object-oriented programming (OOP) is that you organize your code 
in classes/ objects (objects are based on classes).
Your data is stored in properties, your logic in methods. 
And properties and methods that work closely together live in the same class.
*/

// -------Procedual vs OOP--------
/* 
[1] procedual  :
* program divided into Function and Variables
* Overloading is not possible (function overloading => the concept where multiple functions with the same names can have different implementations)
* Hiding Data not Possible
* Data is separated

[2] OOP :
* Program divided into Objects and Methods
* Overloading is possible (not supported in JS ... supported in other languages)
* Hiding data possible
* data is in one Location
*/

// ---------------------ES6 ECMA Script 6 (2015)----------------------

// Variables ( var , let , const )
/* 
[1] var :
-function Scope only
-can be redeclared
-in creation phase initialized to undefined
-Create Properties in the window object ( Scope Drama)
-can  be reassigned
-can  be declared without initialization

[2] let :
-function scope and block scope
-can not be redeclared
-in creation phase only hoist but not initialized to undefined
-does not Create Properties in the window object
-can  be reassigned
-can  be declared without initialization

[3] const : 
-function scope and block scope
-can not be redeclared
-in creation phase only hoist but not initialized to undefined
-does not Create Properties in the window object
-can not be reassigned
-can not be declared without initialization
*/

// here we redclare var
// function varTest() {
//   var x = 1;
//   if(true){
//     var x = 2;
//     console.log(x)
//   }
//   console.log(x)
//   return "done"
// }
//   varTest()

// here let is block scope so x form function is not the same x inside if condition
// function letTest() {
//   let x = 1;
//   if(true){
//     let x = 2;
//     console.log(x)
//   }
//   console.log(x)
//   return "done"
// }
// letTest()

// var redeclare
// var x = 1
// var x = 2
// console.log(x)

// let can not be redclared
// let x = 1
// let x = 2
// console.log(x)

// var or let  can reassigned
// let x = 1
// var x = 1
// const x = 1
// x =2 

// * Variable Hoisting
// let keyword in creation phase only hoist but not initialized to undefined like var
// output undefined
// console.log(hoist)
// var hoist = 10;

// give Error annot access before initialization
// console.log(hoist)
// let hoist = 10;

// output undefined
// let hoist;
// console.log(hoist)
// hoist = 10;

// variable scope darama
// var Mohamed = 1
// let ahmed = 2
// console.log(window.Mohamed)
// console.log(window.ahmed)

// const can not be declared without initialization
// let x; // undefined
// var y; //undefined
// const z; //Error

// you can not reassign const but you can create array and then push or object and make changes to object
// const arr = []
// arr.push("CSS", "HTML", "JS")
// console.log(arr)

// const obj = { 
//   theName : "Mohamed"
// }
// // you can use object.freeze() to stop changes on Object
// // Object.freeze(obj)
// obj.theName = "Soliman"
// obj.age = 33
// console.log(obj)


// -------Arrow Function----------

// function test(){
//   return 2
// }
// let test = function() {
//   return 2
// }
// console.log(test())

// if you have only one statment you can remove {} and return
// if you do not have parameters you can remove () and write _
// if you have one parameter you can remove () and write the one parameter 
// let arrowFunction = () => 2;
// let arrowFunction = _ => 2;
// let arrowFunction = x => 2 * x;
// let arrowFunction = (x , y) => x * y;
// console.log(arrowFunction())
// console.log(arrowFunction(3))

// ---This

// let obj = {
//   person : function () {
//     this.age = 0
//     setInterval(function(){
//       this.age ++
//       console.log(this.age)
//     },1000)
//   }
// }

// obj.person() // NaN

// same exp. but instead of creating object by literal we create it by new constructor
// function person () {
//   // this refer to person object ( that we created by new constructor)
//   this.age = 0
//   console.log(this)
//   setInterval(function(){
//     // this here is refer to window object
//     this.age ++
//     console.log(this)
//   },1000)
// }
// let user = new person(); // NaN

// arrow function will solve this problem
// function person () {
//   // this refer to person object ( that we created by new constructor)
//   this.age = 0
//   setInterval(_ => {
//     // this here is takong value of this of parent function which refers to parent object
//     this.age ++
//     console.log(this.age)
//   },1000)
// }
// let user = new person(); // NaN

// -----------Template Literals  `` ----------

// let lastName = "elzero"
// let gender = "Male"
// let oldWay = "Hello \n it is me Osama"
// let oldWay = "Hello \n" + "it is me " + (gender === "Male" ? "Mr" : "Mrs") + " Osama " + lastName
// console.log(oldWay)

// let newWay = `hello
// it is me ${gender === "Male" ? "Mr" : "Mrs"} Osama ${lastName}`
// console.log(newWay)

// let userName = "Osama",
// age = 36;
// const myHtmlMarkup = `
// <div class="card">
//   <h2 class="name">${userName}</h2>
//   <span class="age">${age}</span>
// </div>
// `
// document.body.innerHTML = myHtmlMarkup

// --------spread operator  => ...Iterable

// let arrayOne = [1,2,3]
// let arrayTwo = [4,5]

// let sum1 = arrayOne.concat(arrayTwo)
// let sum2 = [...arrayOne,...arrayTwo]
// console.log(sum2)

// function sum(x,y,z) {
//   console.log( x + y + z)
// } 
// sum(1, 2, 3)
// sum(...arrayOne)

// let arrayOne = [1,2,3]
// let arrayTwo = arrayOne
// // because assigned by reference
// arrayTwo.push(4)
// console.log(arrayOne) //[1,2,3,4]
// console.log(arrayTwo) //[1,2,3,4]

// with legacy code
// let arrayOne = [1,2,3]
// let arrayTwo = [].concat(arrayOne)
// arrayTwo.push(4)
// console.log(arrayOne) //[1,2,3]
// console.log(arrayTwo) //[1,2,3,4]

// With spread operator
// let arrayOne = [1,2,3]
// let arrayTwo = [...arrayOne]
// arrayTwo.push(4)
// console.log(arrayOne) //[1,2,3]
// console.log(arrayTwo) //[1,2,3,4]

// let arr = [1,2,3,4,-20,100,200]
// console.log(Math.min(...arr))

// how to use spread operator with objects

// [1] merge objects
// let addOn  = {
//   job : "developer"
// }
// let obj = {
//   theName : "Soliman",
//   age : 33,
//   ...addOn
// }
// console.log(obj)

// [2] clone object
// let obj = {
//   theName : "Soliman",
//   age : 33
// }
// let clonedObj = {...obj}
// console.log(clonedObj)
// // but clone is shallow
// clonedObj.age = 34 
// console.log(obj) // age : 33
// console.log(clonedObj) // age : 34

// spread operator vs object.assign()
// [1] object.assign invokes getter and setter methods but spread operator not ( just copy object without getter and setter methods)
// class Circle {
//   constructor(radius) {
//       this.radius = radius;
//   }
//   set diameter(value) {
//       this.radius = value / 2;
//       console.log('SET ', value);
//   }
//   get diameter() {
//     console.log("get")
//       return this.radius * 2;
//   }
// }

// let circle = new Circle(100);

// // let cloneCircle1 = Object.assign(circle);
// let cloneCircle1 = Object.assign(circle ,{
//   diameter : 400
// }); // trigger setter method
// console.log(cloneCircle1.diameter) // trigger getter method
// console.log(cloneCircle1 === circle) //true

// let cloneCircle2 = {
//   ...circle
// };
// console.log(cloneCircle2.diameter) // can not trigger getter method
// console.log(cloneCircle2 === circle) //false

// [2] you can not use Object.assign() to assign a new value to read-only proprty
// but with spread operator you can because you create new object with different reference

// const blueSquare = {
//   length : 100,
//   color : "blue"
// }
// Object.defineProperty(blueSquare , "color" , {
//   value : 'blue',
//   enumerable : true,
//   writable : false

// })

// const redSquare = Object.assign(blueSquare, {
//   color : "red"
// }) // error can not assign to read only object

// but with spread operator
// const redSquare = {
//   ...blueSquare
// }
// redSquare.color = "red"
// console.log(redSquare)

// -------default parameters------

// old way
// function showMyInfo(userName, role, theme) {
//   // userName = userName === undefined ? 'Default User' : userName
//   // or truthy falsy pattern
//   userName = userName || "Default User"
//   return `Hello ${userName} you role is ${role} , webSite theme is ${theme}`
// }
// console.log(showMyInfo())
// // you can skip argument by using variable with undefined value
// let _ = undefined
// console.log(showMyInfo(_,"Adimn", "Blue"))

// newWay
// function showMyInfo(userName = "default User", role = "default role ", theme = "default theme"){
//   return `Hello ${userName} you role is ${role} , webSite theme is ${theme}`
// }
// console.log(showMyInfo())
// let _ = undefined
// console.log(showMyInfo(_,"Admin", "Blue"))

// -----------rest parameters---------

// function sum( x, y){
//   return x + y
// }
// console.log(sum(2,5,6)) // will not give you error but will ignore 6

// using rest parameters
// function sum(...rest){
//   return rest.reduce((x,y) => x + y)
// }
// console.log(sum(2,5,6,7,8,9,10)) 

// rest parameters must be at the end can not be (...myParams, a,b,c)
// function showInfo(a,b,c,...myParams){{
//   console.log("Param a" , a)
//   console.log("Param b" , b)
//   console.log("Param c" , c)
//   console.log("Param myParams" , myParams) // return as array
// }}
// showInfo(1,2,3,4,5,6)

// -----------new String Method---------
// [1] startsWith  => string.startsWith(Search string, position = 0)
// [2] endsWith => string.endsWith(Search string, position = string.length)
// [3] includes => string.includes(serach string, position = 0)
// [4] repeat => string.repeat(count)

// let x = "Elzero Web School"
// console.log(x.startsWith("Elzero"))
// console.log(x.startsWith("Web", 7))
// console.log(x.endsWith("School"))
// console.log(x.endsWith("School", x.length))
// console.log(x.endsWith("Web", 10))
// console.log(x.includes("Web"))
// console.log(x.includes("Web", 7)) //true
// console.log(x.includes("Web", 10)) //false
// console.log(x.repeat(3))

// ---------------Destructuring---------
// [1] Object  [2] Array [3]parameters

// ----------Destructuring of Object----------
// let user = {
//   name : "Osmaa",
//   gender : "Male",
//   age : 36,
//   city : "Cairo",
//   website : "Elzero",
//   langs : {
//     html : "70%",
//     css : "80%",
//     JS : "5%"
//   }
// };
// Destructuring in old way
// let n = user.name,
//     g = user.gender,
//     a = user.age
// console.log(n,g,a)

// Destructuring in new way
// const {name , gender , age } = user
// console.log(name , gender , age)

// using alias
// const {name : n, gender : g, age : a, theme : t = "default"} = user
// console.log(n,g,a,t)

// if you have variables with same name you can not redeclare them but you can reassign them but use ()
// let name = "default";
// let gender = "default";
// let age = "default";
// ({name , gender, age} = user);
// console.log(name , gender , age)

// you can use default value but if its in object the property of object will override default value
// const {name , gender , age, theme = "blue" } = user;
// console.log(name , gender , age, theme)

// nested object
// let {name , age , langs : {html , css}} = user;
// console.log(name , age , html , css)
// let {html , css, JS} = user.langs;
// console.log(html,css,JS)

// ----------Destructuring of Array----------

// const food = ["burger", "pizza" , "Chicken" , "steak"]
// const [one , two , three] = food;
// console.log(one, two , three)

// if you have variables with same name you can not redeclare them but you can reassign them without using ()
// let one = "default";
// let two = "default";
// let three = "default";
// [one , two , three] = food;
// console.log(one, two , three)

// you can use default value but if its in object the property of object will override default value
// const [one , two , three, four = "default"] = food;
// console.log(one, two , three , four)

// Skipping (we dont have skipping in object because object dont have index and we must write
// varaiable with same name of object properites or using alias so variables must be not ordered)
// const [one, , two, three] = food;
// console.log(one,two,three)

// nested Array
// const food = ["burger", "pizza" , "Chicken" , "steak" , [ "Apple" , "Banana" , "Mango", ["orange" , "ananas"]]]
// const [ one , two , three , four ,[ fr1 , fr2 , fr3, [fr4 , fr5]]] = food;
// console.log(fr1,fr2,fr3,fr4,fr5)
// using rest operator
// const [ one , ...otherFood] = food;
// console.log(otherFood)


// --------Swaping using Destructuring------------
// let book = "video",
//     video = "book";
// console.log(book,video);
// old way using 3rd variable 
// let stash = book;
// book = video;
// video = stash;
// console.log(book,video)
// new Way using Destructuring
// [book, video] = [video , book];
// console.log(book,video)

// -----------Destructuring mixed content------------

// const user = {
//   userName : "Osama",
//   city : "Cairo",
//   skills : {
//     html : "80%",
//     css : "85%", 
//     JS : [ "Vuejs" , "Angularjs", "reactjs"] 
//   }
// }

// const {userName , city , skills : {html , css , JS : [one, two , three]} } = user ;
// console.log(one, two , three)

// const user = {
//   userName : "Osama",
//   city : "Cairo",
//   skills : {
//     html : "80%",
//     css : "85%", 
//     JS : { 
//       one : "Vuejs",
//       two : "Angularjs",
//       three : "reactjs"
//     } 
//   }
// }
// const {userName , city , skills : {html , css , JS : {one, two , three}} } = user ;
// console.log(one, two , three)

// -----------Destructuring parameters------------

// const user = {
//   userName : "Osama",
//   city : "Cairo",
//   skills : {
//     html : "80%",
//     css : "85%", 
//     JS : [ "Vuejs" , "Angularjs", "reactjs"] 
//   }
// }
// old way without Destructuring
// function showMyInfo(obj){
//   console.log(obj.skills.JS[0], obj.skills.JS[1] , obj.skills.JS[2])
// }
// showMyInfo(user)
// new Way with Destructuring
// function showMyInfo( {userName , city , skills : {html , css , JS : [one, two , three]} }){
//   console.log(one, two ,three)
// }
// showMyInfo(user)

// --------Object Destructuring form Internet------
/*
const hero = {
  name: 'Batman',
  realName: 'Bruce Wayne',
  address : {
    city : 'Gothem'
  }
};

const name     = hero.name;
const realName = hero.realName;
// is equivalent to:
const { name, realName } = hero;

//  you can use default value if this properity not availabe in main Object
const { enemy = "Joker"} = hero

// you can use Aliases ( change key name)
const { realName: secretName} = hero
console.log(secretName) // Bruce Wayne

// you can use Destructuring also with nested object
const {address : { city }} = hero
const {address : { city : x }} = hero
console.log(x)

// you can use variable with string(same value of key)
const prop = "realName"
const {[prop]: alias} = hero // is equivalent to: hero[prop] ( look at Computed Object Property Name at ES6 course)
console.log(alias)

// you can use spread operator to get rest of properites in object 
const {name,...rest} = hero
console.log(rest)

** use cases :

[1] you can use it with for of loop :
const ratings = [
    {user: 'John',score: 3},
    {user: 'Jane',score: 4},
    {user: 'David',score: 5},
    {user: 'Peter',score: 2},
];
let sum = 0;
for (const {score} of ratings) {
    sum += score;
}
console.log(`Total scores: ${sum}`); // 14 

[2] function parameters : 
const heroes = [
  { name: 'Batman' },
  { name: 'Joker' }
];
const names = heroes.map(function({ name }) {return name;});
names; // => ['Batman', 'Joker']

// Hint in previous we use map function and for ... of loop both will assign {name} = hero;
but in normal function if you want to use destructuring {name} you have to assign 
here in parameter we wrote {name} and as argument we wrote heroes[1] and parameter and agument
is under hood (paramter = argument => {name} = heroes[1]
  const heroes = [
  { name: 'Batman' },
  { name: 'Joker' }
];
function des({name}) {
  return name;
}
console.log(des(heroes[1]))
*/ 
// const heroes = [
//   { name: 'Batman' },
//   { name: 'Joker' }
// ];
// function des() {
//   return name;
// }
// console.log(des(heroes[1]))



// ------------Enhanced Object Literals---------
// [1] Property Value Shorthand
// [2] Method Shorthand
// [3] Computed Object Property Name

// const userName = "Osama",
//       website = "Elzero.org"
      
// const user = {
//   userName : userName,
//   website : website
// }
// console.log(user)

// Property value Shorthand =>  if property of object has same name of varaible
// you can remove the : and value from object
// const user = {
//   userName ,
//   website
// }
// console.log(user)
// old way
// const user = {
//   myMethod : function(param1){
//     return param1
//   }
// }
// console.log(user.myMethod("Soliman"))

// Method Shortcut => ( remove function and : )
// const user = {
//   myMethod (param1){
//     return param1
//   }
// }
// console.log(user.myMethod("Soliman"))

// Old way
// // Normal Variable
// const myVar = "key";
// // creat new Object
// const myObj = {
//   myProperty : "myValue"
// }
// // add dynamic property and assign a value
// myObj[myVar] = "Value"
// console.log(myObj)

// Computed Object Property Name =>  [myVar] : "Value" inside object instead of myObj[myVar] = "Value" outside object
// Normal Variable
// const myVar = "key";
// // creat new Object
// const myObj = {
//   myProperty : "myValue",
//   [myVar] : "Value"
// }
// // add dynamic property and assign a value
// console.log(myObj)

// ---------------Set------------------
/* 
new Set(iterable)
set does not has keys
to convert array to set use new Set(array)
to convert set to array use spread operator [...mySet] or Array.from(set)
*/
// let mySet = new Set([1,2,3,3])
// let myArr = [1,2,3,3]
// console.log(mySet)
// console.log(myArr)
// // Set does not has keys so you can not use mySet[1] like array myArr[1]
// console.log(myArr[1])
// console.log(mySet[1]) //undefined

/* 
Set Methods
add(value)
delete(value)
mySet.has(value)
mySet.size
mySet.clear()
*/

// // let mySet = new Set()
// let mySet = new Set("Soiman")
// // mySet.add(1).add(2).add(3)
// // when you add "soliman" will add it as one element
// // but when you write it inside set like new Set("Soliman") will add each charachter as new element
// mySet.add("Soliman")
// mySet.delete("S")
// console.log(mySet.has("m"))
// console.log(mySet.size)
// console.log(mySet)
// mySet.clear()
// console.log(mySet)

// ------------Map-----------
/* 
Map has Keys ( accept anthing as key) but object accept only string or symbol (object always convert key to string) but Map not
*/
// Object
// let user = {}
// user["userName"] = "Osama"
// user.passWord = 123
// console.log(user)
// console.log(user.userName)
// console.log(user["passWord"])

// Map
// let user = new Map()
// // user.set("userName", "OSama").set("passWord", 123)
// // Map accept anything number , string , boolean , object , NaN , function
// user.set("10", "OSama").set(10, 123).set(false , "Boolean").set({a:1 ,b:2}, "Object")
// .set(NaN, "not a number").set(function func(x){return x}, "Function")
// console.log(user)

// instead of using set you can add them as array inside Arrays while creating new Map
// let user = new Map([
//   ["userName", "OSama"],
//   ["passWord", 123]
// ])
// console.log(user)


/* 
Map Methods
set(key , value)
get(key) => there is no get() at Set because Set has no keys
delete(key)
myMap.has(key)
myMap.size
myMap.clear()
*/

// ----------------Symbol------------
/* 
it's a primitive data Type (assigned by value) (does not have Method)
* Symbol is a new Primitive value (ES6)
* Every Value return from Symbol(desciption) is unique
* Used as identifier for object properties but it will not be shown in iteration or JSON.stringify 
* You can say it’s a container of unique value
* Symbol() is incomplete constructor (no need of new keyword)

let a = 123
let b = 123
a === b

let a = Symbol(123)
let b = Symbol(123)
a !== b
*/

// const mySymbol = Symbol()
// console.log(typeof mySymbol)

// const mySymbolOne = Symbol("Testing")
// const mySymbolTwo = Symbol("Testing")
// console.log(mySymbolOne === mySymbolTwo) //false

// myNewSymbol = Symbol();
// const myObj = {
//   userName : "Osama",
//   webSite : "Elzero.org",
//   [myNewSymbol] : "This is Hidden from Iteration"
// }
// Symbol will not be shown in iteration
// for...of loop
// for (let val of Object.values(myObj)) {
//   console.log(val)
// } 
// // for...in loop
// for (let prop in myObj){
//   console.log(myObj[prop])
// }

// console.log(Object.keys(myObj)) // Symbol will not be shown
// console.log(Object.getOwnPropertyNames(myObj)) // Symbol will not be shown
// console.log(JSON.stringify(myObj)) // Symbol will not be shown
// console.log(Object.getOwnPropertySymbols(myObj)) // to show only Symbol
// console.log(myObj) // everyThing will be shown
// console.log(myObj[myNewSymbol])

// for Method
/* 
Search in The global symbol registry for a symbol with the given key if found return it; 
otherwise, a new symbol is created and returned

when you use for method it will search for any Symbol that has a key "Test" inside it 
if found will assign it to the varaible if not will create it and assign it to variable
so in mySymbolthree will search for key "Test" not found so will create and assign to variable
in mySymbolFour will search and find a Symbol key "Test" so will assign it to new variable
Symbol("Testing") => Testing here is a description 
Symbol.for("Test") => Test here is a key 
that's why when we write Symbol.keyFor(Symbol("Testing")) we get undefined because Testing is a description not key
*/
/* 
The global symbol registry is just a convenient global repository for symbol instances
that works regardless of scope or compilation unit.

const sym1 = Symbol.for('some-key'); // Symbol is created in global registry

// Elsewhere in project:
const sym2 = Symbol.for('some-key'); // Symbol is retrieved from global registry

// They are the same symbol:
console.log(sym1 === sym2); // true

// You can even access the key property:
console.log(Symbol.keyFor(sym1)); // some-key
*/

// const mySymbolOne = Symbol("Testing")
// const mySymbolTwo = Symbol("Testing")
// console.log(mySymbolOne === mySymbolTwo) //false
// const mySymbolthree = Symbol.for("Test")
// const mySymbolFour = Symbol.for("Test")
// console.log(mySymbolthree === mySymbolFour) //true

// // KeyFor Method
// console.log(Symbol.keyFor(mySymbolOne)) // undefined
// console.log(Symbol.keyFor(mySymbolFour))

// // toString() to convert Symbol value to string
// console.log(mySymbolFour)
// console.log(mySymbolFour.toString())

// // description to get value of Symbol
// console.log(mySymbolFour.description)


// ---------------ForEach in Set and Map--------------------

// const arr = ["A", "B", "C", "D", , "F"]

// for (let i = 0 ; i < arr.length; i++) {
//   console.log(`${i} - ${arr[i]}`) // 4 - undefined
// }
// console.log(`${"#".repeat(10)}`)

// let callbacksFunction = 0;
// // forEach will skip undefined and will not excute call back function on empty element
// arr.forEach((ele , index) => {
//   callbacksFunction++
//   console.log(`${index} - ${ele}`)
// }) // 4 will not show up
// console.log(callbacksFunction) //5 this is a prove that will not excute callback function on empty element
// console.log(`${"#".repeat(10)}`)

// // Map also will skip undefined and will not excute call back function on empty element
// arr.map((ele,index) => console.log(`${index} - ${ele}`) ) // 4 will not show up
// console.log(`${"#".repeat(10)}`)

// function makeTheLoop(ele , index) {
//   console.log(`${index} - ${ele}`)
// }
// arr.forEach(makeTheLoop)

// forEach in array (element , index , array)
// forEach in Set (element value, element key , set) (set does not has key so value = key)
// // forEach in map (element value, element key , map) 
// const arr = [1,2,3,4,5]
// const mySet = new Set([1,1,2,3,4,4,4,5])
// const myMap = new Map().set("1" , "A").set("2", "B").set("3","C")
// mySet.forEach((ele, ele2 , set) => console.log(`${ele} - ${ele2}`))
// console.log(`${"#".repeat(10)}`)
// arr.forEach((ele, index , arr) => console.log(`${index} - ${ele}` ))
// console.log(`${"#".repeat(10)}`)
// myMap.forEach((value, key , map) => console.log(`${key} - ${value}` ))

// ------------------Set vs WeakSet-----------------------
/* 
Set 
- Contains Any Type pf Values
- Get Elements Count with size
- forEach Available to Iterate
- You can Get its Keys

WeakSet
- Contains Only Object
- You Can't USe Size to Get Elements Count
- forEach Not Availabe
- You Can not Get Key
*/

// Set 

// let mainObject = { A : 1}
// let mySet = new Set([mainObject])
// let objOne = { B : 2}
// let objTwo = { C : 3}
// mySet.add(objOne)
// mySet.add(objTwo)
// console.log(mySet)
// console.log(mySet.has(objOne))
// console.log(mySet.has(objTwo))
// console.log(mySet.size)
// console.log(mySet.keys())
// mySet.delete(objOne)
// console.log(mySet.has(objOne))
// objTwo = null
// console.log(mySet.has(objTwo))
// // objTwo will show here (we assign objTwo to null but still in set)
// console.log(mySet) 

// weakSet
// let mainObject = { A : 1}
// let myWeakSet = new WeakSet([mainObject])
// let objOne = { B : 2}
// let objTwo = { C : 3}
// myWeakSet.add(objOne)
// myWeakSet.add(objTwo)
// console.log(myWeakSet)
// console.log(myWeakSet.has(objOne))
// console.log(myWeakSet.has(objTwo))
// myWeakSet.delete(objOne)
// console.log(myWeakSet.has(objOne))
// objTwo = null
// console.log(myWeakSet.has(objTwo))
// // objTwo will show here (we assign objTwo to null but still in set)
// console.log(myWeakSet) 

/* 
Set is ordered and live
WeakSet is not ordered and live
but i am not sure ? check again

If any of those objects loses all references it will be “marked” for garbage collection. 
When this garbage collection happens this object is released from the memory. It is gone. 
The thing about garbage collection is that it works whenever it wants. You can’t predict when it will happen.
Let’s say you have an object. You add this object to a WeakSet. What if you, 
in another part of the code, remove that object? The answer is, it depends. 
It depends on whether the garbage collection had time to run or not. If it did, 
the object is released from memory, and it is also gone from the WeakSet.
*/

// ------------------Map vs WeakMap-----------------------

// let myMap = new Map()
// let obj1 = { a: 1}
// myMap.set(obj1 , "Test")
// myMap.set("B" , 2)
// myMap.set("C" , 3)
// myMap.set(1 , 15)
// console.log(myMap)
// console.log(myMap.get("C"))
// console.log(myMap.get(obj1))
// console.log(myMap.has("B"))
// myMap.delete("B")
// console.log(myMap.has("B"))
// obj1 = null;
// console.log(myMap.get(obj1))
// console.log(myMap.has(obj1))
// // objTwo will show here (we assign objTwo to null but still in Map)
// console.log(myMap)

// let myWeakMap = new WeakMap()
// let obj1 = { a: 1}
// let obj2= { b : 1}
// let obj3= { c : 1}
// myWeakMap.set(obj1 , "Test")
// myWeakMap.set(obj2 , "Test")
// myWeakMap.set(obj3 , "Test")
// console.log(myWeakMap)
// console.log(myWeakMap.get(obj1))
// console.log(myWeakMap.get(obj2))
// myWeakMap.delete(obj3)
// console.log(myWeakMap.has(obj3))
// obj2 = null;
// console.log(myWeakMap.get(obj2))
// console.log(myWeakMap.has(obj2))
// // objTwo will show here (we assign objTwo to null but still in Map)
// console.log(myWeakMap)

// let mySet = new Set(["A", "B", 2 , "C", 3 , 4])
// console.log(mySet)
// for( let x of mySet) {
//   console.log(x)
// }
// mySet.forEach(ele => console.log(ele))

// ----------------Symbol.iterator------------------

/* 
Iterable => object has Symbol.iterator
Iterator 
- object with interface designed for Iteration
- All iterators has Next() Method That return Result Object
- the Result Object has two props
[1] value => the next value
[2] Done => boolean 

for ... of loop
[1] Call Symbol.iterator with Next Method
[2] Save Value inside Variable => [ for (let variable of iterator)]
[3] Check for Done if its Ture => Exit Loop
*/
// let arr = [1,2,3]
// let myName = "Osama"
// let myNum = 1000
// let myObject = { 
//   a : "A",
//   b : "B"
// }
// console.log(typeof arr[Symbol.iterator])
// console.log(typeof myName[Symbol.iterator])
// console.log(typeof myNum[Symbol.iterator])
// console.log(typeof myObject[Symbol.iterator])

// let strIterator = myName[Symbol.iterator]()
// let arrIterator = arr[Symbol.iterator]()
// console.log(arrIterator)
// console.log(arr.entries())
// console.log(strIterator)
// console.log(strIterator.next())
// console.log(strIterator.next())
// console.log(strIterator.next())
// console.log(strIterator.next())
// console.log(strIterator.next())
// console.log(strIterator.next())
// for ... of loop underhood is next() ..... till done true then stop loop
// for (let char of myName) {
//   console.log(char)
// }

// --------------custom iterable object----------------


// const myObj  = {
//   theName : "Osama",
//   age : 36 ,
//   country : "Egypt",
//   skills : "JS",
// }
// // Add Symbol.iterator to Object
// myObj[Symbol.iterator] = function () {
//   let i = 0;
//   let prop  = Object.keys(this)
//   return{
//     next() {
//       return {
//         value : prop[i],
//         done : i++ === prop.length
//       } 
//     }
//   }
// }

// for( let x of myObj) {
//   console.log(`${x} => ${myObj[x]}`)
// }

// you can use  Method Shorthand & Computed Object Property Name to shortcut the code

// const myObj  = {
//   theName : "Osama",
//   age : 36 ,
//   country : "Egypt",
//   skills : "JS",
//   [Symbol.iterator]() {
//     let i = 0;
//     let prop  = Object.keys(this)
//     return{
//       next() {
//         return {
//            value : prop[i], // key
//           // value : myObj[prop[i]], // value
//           done : i++ === prop.length
//         } 
//       }
//     }
//   }
// }

// for( let x of myObj) {
//   console.log(`${x} => ${myObj[x]}`)
// }

// -----------Generator--------------
/* 
Generator create iterator
function stop Excution after each yield 
yield is like pause
function give you control to yield
*/
// function *generateTicket () {
//   yield 1;
//   yield 2;
//   yield 3;
// }

// let iterator = generateTicket()
// console.log(iterator.next().value)
// console.log(iterator.next().value)
// console.log(iterator.next().value)
// console.log(iterator.next())

// let myNums = [1,2,3,4,5]
// function *generateNums(nums) {
//   for ( let i =0; i < nums.length; i++) {
//     yield nums[i]
//   }
// }

// let generator = generateNums(myNums)
// console.log(generator.next().value)
// console.log(generator.next().value)
// console.log(generator.next().value)
// console.log(generator.next().value)
// console.log(generator.next().value)

// let myNums = [1,2,3,4,5]
// function *generateNums2() {
//   yield * [1,2,3,4,5]
// }
// let generator = generateNums2(myNums)
// console.log(generator.next().value)
// console.log(generator.next().value)
// console.log(generator.next().value)
// console.log(generator.next().value)
// console.log(generator.next().value)

// Normal Function
// function orderBook() {
//   window.alert("Order This Book?")
//   console.log("Order This Book?")
//   window.alert("Added to Cart")
//   console.log("Added To Cart")
//   window.alert("Payment is Done")
//   console.log("Payment is Done")
// }
// // function will excute once you assign it to variable
// let order = orderBook();

// Generator
// function * orderBook() {
//   window.alert("Order This Book?")
//   console.log("Order This Book?")
//   window.alert("Added to Cart")
//   console.log("Added To Cart")
//   window.alert("Payment is Done")
//   console.log("Payment is Done")
// }
// // function will excute only you use next()
// let order = orderBook();
// order.next()

// function * myskills() {
//   yield "HTML";
//   yield "CSS";
//   yield "JS";
// }
// // using generator with function generate iterator like adding [Symbol.iterator] to Object to create iterator
// let skills = myskills()
// for ( let skill of skills) {
//   console.log(skill)
// }
// // you can also directly loop on generator
// for ( let skill of myskills()) {
//   console.log(skill)
// }

// return stop excution and return done:true; ( anything after return will not excuted)
// function *sayName() {
//   yield "Osama";
//   yield "Ahmed";
//   return "Sayed"
//   yield "Eman"
// }
// let names = sayName();
// console.log(names.next())
// console.log(names.next())
// console.log(names.next()) // value : Sayed done : true;
// console.log(names.next())


// function *createInfinite() {
//   let i = 0;
//   while(true) {
//     yield i++;
//   }
// }
// let infiniteIterator = createInfinite()
// console.log(infiniteIterator.next())
// console.log(infiniteIterator.next())
// console.log(infiniteIterator.next())
// // here will start from 3 because we used next 3 times on infiniteIterator
// for (let num of infiniteIterator) {
//   if (num > 5) {
//     break;
//   }
//   console.log(num)
// }
// // here will start from 0 because we used generator itself not the iterator
// for (let num of createInfinite()) {
//   if (num > 5) {
//     break;
//   }
//   console.log(num)
// }

// console.log(createInfinite())
// console.log(infiniteIterator)

// user defined Iterable
// const myIterable = {
//     *[Symbol.iterator]() {
//       yield 1;
//       yield 2;
//       yield 3;
//   }
// }
// for (let value of myIterable) {
//   console.log(value);
// }


// Delegating generator

// function *generateNums() {
//   yield 1
//   yield 2
//   yield 3
// }
// function *generateNames() {
//   yield "Mohamed"
//   yield "Ahmed"
//   yield "Soliman"
// }

// function *generateAll() {
//   yield * generateNums() // without star will generator name
//   yield * generateNames() // without star will generator name
//   // return "Break From Inside" // will break iterstion
//   yield * [4,5,6] // without star will return array it self 
// }

// let genAll = generateAll()
// // will start from nums then go to names
// console.log(genAll.next())
// console.log(genAll.next())
// console.log(genAll.next())
// console.log(genAll.next())
// console.log(genAll.next())
// console.log(genAll.next())
// // console.log(genAll.return("Break")) // will break iteration and return {value: break , done: true}
// console.log(genAll.next())
// console.log(genAll.next())
// console.log(genAll.next())
// console.log(genAll.next())

// ------------New Array Methods---------------

/* 
Array.of
Array.from
Array.fill
Array.find
Array.findIndex
Array.copyWithin
*/

// Array.of(Elements to Create The Array)

// will create 100 empty elements inside Array
// let oldArray = Array(100)
// console.log(oldArray)
// console.log(oldArray.length)

// will create array of two elements 
// let oldArray = Array(100 , 200)
// console.log(oldArray)
// console.log(oldArray.length)

// will create array of one string element "100"
// let oldArray = Array("100")
// console.log(oldArray)
// console.log(oldArray.length)

// here will create only one element not 100 empty element like Array(100)
// let newArray = Array.of(100)
// console.log(newArray)
// console.log(newArray.length)

// Array.from(iterable , Map func, this) 

// let myName = "Osama"
// let arrspread = [...myName]
// let arrfrom = Array.from(myName)
// console.log(arrspread)
// console.log(arrfrom)

// let myNums = [10,20,30,40,50,60]
// let arrFrom = Array.from(myNums, num => num - 10)
// let arrMap = myNums.map(num => num - 10)
// console.log(arrFrom)
// console.log(arrMap)

// Array.fill (value to fill, start (default 0) , end (default array.lenght))

// let nums = [10,20,30,40,50,60]
// // all elements inside array will be 100 because we did not give it start or end so defautl start 0 end arr.length
// // nums.fill(100)
// // nums.fill(100,2)
// nums.fill(100,1,3)
// console.log(nums)

// Arrar.find() will return 1st value only
// let num = [10,20,30,40,50,60]
// let found = num.find(el => el > 10)
// console.log(found) //20

// Arrar.findIndex() will return 1st index of value only
// let num = [10,20,30,40,50,60]
// let found = num.findIndex(el => el > 10)
// console.log(found) //  1

/* 
Array.copywithin(Target, Start => Optional (default 0 ), End => Optional (default arr.length))
target = where to copy // start of the copied part // End of the copied part 
but will not increase Array length
Copy Part of an Array to Another Location in the Same Array
*/

// let myletters = ["A","B","C","D","E","F","G"]
// // target 0 start 0 end arr.length => will copy all array and paste it at index 0 so will give you same array
// // myletters.copyWithin(0)
// // myletters.copyWithin(0,3,6)
// myletters.copyWithin(1,5,7)
// console.log(myletters)

//-------------------------Module-----------------------

/* ------Import and Export
import defaultExport from "module-name";
import * as name from "module-name";
import { export } from "module-name";
import { export as alias } from "module-name";
import { export1 , export2 } from "module-name";
import { export1 , export2 as alias2 , [...] } from "module-name";
import defaultExport, { export [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";
import "module-name";
var promise = import(module-name);

export { name1, name2, …, nameN };
export { variable1 as name1, variable2 as name2, …, nameN };
export let name1, name2, …, nameN; // also var, const
export let name1 = …, name2 = …, …, nameN; // also var, const
export function FunctionName(){...}
export class ClassName {...}

export default expression;
export default function (…) { … } // also class, function*
export default function name1(…) { … } // also class, function*
export { name1 as default, … };

// Aggregating modules (ReExporting)
export * from …;
export { name1, name2, …, nameN } from …;
export { import1 as name1, import2 as name2, …, nameN } from …;
export { default } from …;

note: if you need to use module with node not with browser just change file name from .js to .mjs
*/

// import{myRank, myArray as arr , sayName } from '/Module/Module.js'; //(as is alias )
// import (Module object) everything from module (everything means everything you have exported from ./Module.js)
// import * as all from './Module.js';

// console.log(a)
// console.log(myRank)
// console.log(all.myRank)
// // console.log(arr)
// console.log(all.arr)
// // console.log(sayName("Soliman"))
// console.log(all.sayName("Soliman"))
// console.log(all)

// import anyName from 'Module/Module.js'
// you can merge named export and default export in one line code 
// every model has only one default export (you can write any name for default export because it's only one default)
// import anyName , {myArray, myRank, sayName} from './Module.js';
// // console.log(anyName())
// console.log(anyName)
// console.log(myRank)

// console.log(this) // undefined

// ------Aggregating modules (ReExporting)
/* 
Aggregating modules : 
- The imported function or variables from Module.js can be also 
exported to another JS File (reExport.js) 
- but in Aggregating modules there is no Default 
- you can use wildCard with Aggregating modules export * from "/Module/Module.js" but with normal modules no
*/

// import{myRank, myArray as arr , sayName } from '/Module/Module.js';
// export {myRank, myArray as arr , sayName } from '/Module/Module.js';
// export * from "/Module/Module.js" // wild card to export everything


/* 
In Node modules, this at the top level doesn’t reference the global object. 
Instead, it has the same value as module.exports. Inside functions (Node environment), 
the value of this is determined based on how the function is called. In JavaScript modules, 
this at the top level is undefined.
*/

//------------------classes ES6------------------------
// Old Syntax

// // Constructor 
// function User(name,age){
//   this.name = name;
//   this.age = age;
// }
// // create Methods (Properties and methods can be added to a constructor using a prototype:)
// User.prototype.getInfo = function(){
//   console.log(`Your Name is ${this.name} and your Age is ${this.age}`)
// }
// User.prototype.getDays =  function(){
//   console.log(`You live for ${this.age * 365} Days`)
// }
// // Create new Object using constructor and this object will inherit Methods from User.prototype
// const firstUser = new User("Soliman", 33)
// firstUser.getInfo()
// firstUser.getDays()
// console.log(firstUser.name)
// console.log(firstUser.age)

// ES6 Syntax

// class User {
//   constructor(name, age) {
//     this.name = name;
//     this.age = age;
//   }
//   getInfo() {
//     console.log(`Your Name is ${this.name} and your Age is ${this.age}`);
//   }
//   getDays() {
//     console.log(`You live for ${this.age * 365} Days`);
//   }
// }

// const firstUser = new User("Soliman", 33)
// firstUser.getInfo()
// firstUser.getDays()
// console.log(firstUser.name)
// console.log(firstUser.age)

// import User from './Module.js'

// let firstUser = new User("Soliman","Mohammed.soliman88@gmail.com")
// firstUser.getInfo()

// note : code within the class body is always executed in strict mode.
//------------Derived class (sub-class)-----------------
/* 
A derived class is a class created or derived from another existing class. 
The existing class from which the derived class is created through the process of 
inheritance is known as a base class or superclass.
*/
// extends means (Admin) is a child class of parent class (User) to inherit every thing from parent
// import User from './Module.js'
// class Admin extends User {
//   constructor(name, email,age){
//     // call parents constructor like this.name & this.email
//     super(name ,email);
//     this.age = age;
//   }
// };
// let firstAdmin = new Admin("Soliman" ,"Mohammed.soliman88@gmail.com",33);
// // because of extends Admin inherited getInfo Method from parent User
// firstAdmin.getInfo();
// console.log(firstAdmin.age)

// ---------------Important Knowledge----------------

// [1] Call Stack
/* 
- Mechanisam to make interpreter Track Your Call
- When you call a function its added to the stack
- when function excuted its removed from the stack
- the interpreter continue calling from the last point reached
- Call Stack detect web api method and leave it to the browser to handle it
*/

// [2] Web API
/* 
- Method Availabe from environment => browser
- when complete it will add the callback to the callback queue
*/

// [3] Event Loop
/*
- Wait the call stack to finish
- Get callback from callback queue
- add callback to callstack
*/


// // one three two
// console.log("One")
// window.setTimeout(_ => console.log("Two"), 0)
// console.log("Three")

// // one three last two 
// window.setTimeout(_ => console.log("last"), 1000)
// console.log("One")
// window.setTimeout(_ => console.log("Two"), 1000)
// console.log("Three")

// // one three two last 
// here web API will add two to callback queue  before last because it will not wait two to complete
// because two has 0 delay but last has delay 1 sec so will be added after two
// window.setTimeout(_ => console.log("last"), 1000)
// console.log("One")
// window.setTimeout(_ => console.log("Two"), 0)
// console.log("Three")


// Error
// console.log(myVar)
// let myVar = 100;
// myVar += 200;

// 300
// window.setTimeout(_ => console.log(myVar),0) 
// let myVar = 100;
// myVar += 200;

// (4) hi outside 1 2 3 4
// let arr = [1,2,3,4]
// arr.forEach((el) => { 
//   window.setTimeout(_ => console.log(el),0)
//   console.log("hi")
// } )
// console.log("Outside")

// ---------------Asynchronous Vs Synchronous------------
// bad will stop console.log("Two") to excute you should press ok to alert and finish it 
// then console.log("Two") will be excuted
/* 
Web APIs can include functions that are synchronous and asynchronous. 
For example, the setTimeout will use the event loop, 
console.log() will synchronously write to the browser's console  
fetch will call an asynchronous function that can be awaited.
Asynchronous JavaScript code requires Callback functions that get 
executed later after the desired time.
(that's why console.log() is Web API Synchronous and  setTimeout(callback function) is Web API Asynchronous)
*/
// console.log("One")
// window.alert("Bad")
// console.log("Two")

// we used setTimeout because will use event loop and will stop important func but window.alert will stop
// console.log("normal Func")
// // window.alert("Stop")
// window.setTimeout(_ => console.log("Get Friends Lists"),0)
// window.setTimeout(_ => console.log("Get Latest News"),0)
// console.log("Important func , no waiting")

// -----------Promises------------------

/* 
- Promise Make it Easy to support Asynchronous Programming
- Promise is something that will happen in the future
- Promise is a Placeholder for a future value
- EXP : 
  You ordered food from resturant
  [Promise] is the order record
  [the future value ] is the food you will receive 
- Promise is an Object
- Promise is the event completion or failure of async operation & its resulting value
- Js use callbacks for asynchronous Programming 
  [1] function called and do the task
  [2] Action complete
  [3] another function called (nested function)
  [4] Action complete
  [5] another function called (nested function)
  in complex cases => every call add nesting call
  http://callbackhell.com/
- Promise Avoiding callbackhell or Pyramid of Doom
- Promise is one of this operation
  [1] Pending => Not fulfilled or rejected
  [2] fulfilled => operation succeeded (using resolve parameter)
  [3] rejected => operation failed (using reject parameter)
*/


// promise accept one parameter and this parameter is excuter function (which accept 2 parameters => resolve and reject they called handelers) 
// const myPromise = new Promise((resolve, reject) => {
//   // console.log("Welcome to my First Promise")
//   let connect = false;
//   if(connect) {
//     resolve("Connection Established")
//   }else {
//     reject(Error("Connection Failed"))
//   } 
// });
// // then to add onfulfilled function and take value from resolve inside myPromise
// // and add onreject function and take value from reject inside myPromise
// // will take values from resolve and reject so when connect is false 
// // will not throw an Error will give you a string of Error
// myPromise.then(
//   (resolved) => console.log(resolved),
//   (rejected) => console.log(rejected)
// )


// ----you can write promise.then in smaller syntax 
// const theResolved = (resolved) => console.log(resolved)
// const theRejected = (rejected) => console.log(rejected)
// myPromise.then(theResolved,theRejected)

// ----or add it to promise
// const myPromise = new Promise((resolve, reject) => {
//   // console.log("Welcome to my First Promise")
//   let connect = true;
//   if(connect) {
//     resolve("Connection Established")
//   }else {
//     reject(Error("Connection Failed"))
//   } 
// }).then(
//   (resolved) => console.log(resolved),
//   (rejected) => console.log(rejected)
// )

/* 
A promise is used to handle the asynchronous result of an operation. 
JavaScript is designed to not wait for an asynchronous block of code to completely execute 
before other synchronous parts of the code can run. With Promises, we can defer the execution 
of a code block until an async request is completed. This way, other operations can keep 
running without interruption.
*/

// ----------setTimeout vs Promise vs Promise.then()
// setTimeout after the call stack is empty (Task queue) but promise.then() at the end of the main stack (micro-task queue)
// let x = 0;
// let myPromise = new Promise((resolve , reject) => {
//   let status = false;
//   console.log("From inside of Promise")
//   if(status) {
//     resolve( x = 2 )
//   }else{
//     reject(x = 3)
//   }
// });
// myPromise.then(
//   (resolved) => console.log(resolved),
//   (rejected) => console.log(rejected)
// )
// console.log("From Outside of Promise")

/* output
[1] "From inside of Promise"
[2] "From outside of Promise"
[3] 2 => 2 printed after "From outside of Promise" 
*/

// window.setTimeout(_=>console.log("From setTimeout") , 0)
// let myPromise = new Promise((resolve , reject) => {
//   let status = true;
//   console.log("From inside of Promise")
//   if(status) {
//     resolve("From Resolve")
//   }else{
//     reject("From reject")
//   }
// });
// myPromise.then(
//   (resolved) => console.log(resolved),
//   (rejected) => console.log(rejected)
// )
// console.log("From outside of Promise")

//output 
/* 
[1] "From inside of Promise"
[2] "From outside of Promise"
[3] "From Resolve" => from Promise.then
[4] "From setTimeout"
*/

// ---------asynchronous of then--------
/*
// then itself return promise Object
// its handlers will be triggered asynchronously as demonstrated by the console.logs
const resolvedProm = Promise.resolve(33);

let thenProm = resolvedProm.then(value => {
    console.log("this gets called after the end of the main stack. the value received and returned is: " + value);
    return value;
});
// instantly logging the value of thenProm
console.log(thenProm);
// using setTimeout we can postpone the execution of a function to the moment the stack is empty
setTimeout(() => {
    console.log(thenProm);
});

logs, in order:
Promise {[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined}
"this gets called after the end of the main stack. the value received and returned is: 33"
Promise {[[PromiseStatus]]: "resolved", [[PromiseValue]]: 33}

// another Exp. 
// let x = 5;
// let pro = new Promise((resolve , reject) => {
//   resolve(x)
// })
// pro.then(
//   (resolved) => x += 1 
// )
// console.log(x) // 5 because then will be excuted at the end of main Stack
// window.setTimeout(_ => console.log(x)) // 6 because setTimeout (Task Queue) after promise(microTask Queue)
// let x = 5;
// let pro = new Promise((resolve , reject) => {
//   resolve(x += 1)
// })
// console.log(x) // 6 resolve inside promise itself will excute immediatly
// window.setTimeout(_ => console.log(x)) // 6 because setTimeout will wait till call stack to be empty

// then will be excuted once p1 (Promise) resolved 
// even if P1 will be resolved when call stack is empty (because of setTimeout)
// so then will be excuted not only at the end of main stack but also once Promise resolved
// let p1 = new Promise((resolve, reject) => {
//   setTimeout(resolve, 2000, "P1 Resolved")
// })
// console.log(p1) //pending
// setTimeout(_=> console.log(p1), 1000) // pending
// setTimeout(_=> console.log(p1), 3000) // fulfilled
// p1.then((result) => console.log(result)) // "P1 Resolved"
// // output order : pending pending "P1 Resolved" fulfilled
*/

// -----------catch and then--------------
// const myPromise = new Promise((resolve, reject) => {
//   // // only one state allowed
//   // resolve("Success")
//   // reject("Failed") // will ignore this only one state allowed
//   if(Math.random() * 100 < 50) {
//     resolve("Good")
//   }else{
//     reject("Bad")
//   }
// });
// myPromise.then(
//   (resolved) => console.log(resolved),
//   (rejected) => console.log(rejected)
// )

// myPromise.catch((rejected) => console.log(rejected))

// will give you Error when rejected happend because then accept 2 functions or you can chain then and catch
// myPromise.then((resolved) => console.log(resolved))
// myPromise.catch((rejected) => console.log(rejected))

// chain then and catch
// myPromise.then((resolved) => console.log(resolved)).catch((rejected) => console.log(rejected))
// or you can write null to skip resolved or rejected inside then
// myPromise.then(null , (rejected) => console.log(rejected) )

// you can chain more than one then and catch
// let myPromise = new Promise((resolve , reject) => {
//   let x = 5;
//   let y = -1;
//   resolve(x);
//   reject(y);
// })
// myPromise.then((resolved) => {
//   console.log(resolved)
//   return resolved * 2
// }).then((resolved2) => {
//   console.log(resolved2)
// }).catch((rejected) => console.log(rejected))
// // output 5 , 10 will output -1 if remove resolve(x) from Promise

// different syntax but same thing
// let p1 = new Promise((resolve , reject) => {
//   if(true){
//     resolve("P1 resolved")
//   }else {
//     reject("P1 reject")
//   }
// })
// let p2 = Promise.resolve("P2 Resolved")
// p1.then((resolved) => console.log("P1:" , resolved))
// p2.then((resolved) => console.log("P2:" , resolved))

// without Promise (callback hell)
// firstRequest(function(response){
//   secondRsponse(response, function(nextResponse){
//     thirdRespose(nextResponse, function(finalResponse) {
//       console.log('Final Response: '+ finalResponse);
//     }, failureCallback);
//   }, failureCallback);
// },failureCallback);

// with Promise
// firstRequest()
//   .then((response) => secondRequest(response))
//   .then((nextResponse) => thirdRequest(nextResponse))
//   .then((finalResponse) => console.log("final Respose: " + finalResponse))
//   .catch(failureCallback);

// without nesting function
// let btn = document.querySelector(".btn")
// btn.addEventListener("click" , function(){
//   setTimeout(_=> console.log(1),1000)
//   setTimeout(_=> console.log(2),3000)
//   setTimeout(_=> console.log(3),2000)
// }) // output 1 3 2

// with nesting function => callBack hell example
// btn.addEventListener("click" , function(){
//   setTimeout(_=>{
//     console.log(1) 
//     setTimeout(_=> {
//       console.log(2)
//       setTimeout(_=> console.log(3),2000)
//     },3000)
//   },1000)
// }) // output 1 2 3

// // then can be used also for reject or Error 
// /* 
// here when we can add another function to .then(resolveFun , resolveFun2) so resolveFun2 will catch reject or Error
// */
// function myPromise(){
//   return new Promise((resolve , reject) => {
//     // resolve("Resolved!")
//     reject("Rejected!")
//     throw Error ("Error From inside Promise")
//   })
// }

// myPromise()
//   .then(resolveFun , resolveFun2)
//   .catch(rejectFun)

// function resolveFun(result) {
//   console.log(`From ResolveFun : ${result}`)
// }
// function resolveFun2(result) {
//   console.log(`From ResolveFun2 : ${result}`)
// }
// function rejectFun(result) {
//   console.log(`From rejectFun : ${result}`)
// }

/* --------------callback hell and Promise----------------------
// callback hell EXP.
function getUsername(callback) {
  callback({name : "Soliman"});
};

function getAge(data, callback) {
  data = {...data, age : 50};
  callback(data);
};

function getDepartment (data, callback) {
  data = {...data, department : "Production"};
  callback(data);
};

function getEmployee(data, callback) {
  callback(data);
};

function printInfo(data) {
  console.log(data);
};


getUsername(function(firstResponse){
  getAge(firstResponse , function(secondResponse){
    getDepartment(secondResponse , function(thirdResponse){
      getEmployee(thirdResponse , function(finalResponse){
        printInfo(finalResponse)
      })
    })
  })
})


with Promise

function getUsername() {
  return new Promise ((resolve , reject) => {
    resolve({name : "Soliman"})
  })
};
function getAge(data) {
  return new Promise ((resolve , reject) => {
    data = {...data, age : 33}
    resolve(data)
  })
};
function getDepartment (data) {
  return new Promise ((resolve , reject) => {
    data = {...data, department : "Production"};
    resolve(data)
  })
};
function getEmployee(data) {
  return new Promise ((resolve , reject) => {
    resolve(data)
  })
};
function printInfo(data) {
  console.log(data);
};

getUsername()
  .then((firstResponse) => getAge(firstResponse))
  .then((secondResponse) => getDepartment(secondResponse))
  .then((thirdResponse) => getEmployee(thirdResponse))
  .then((finalResponse) => printInfo(finalResponse))

*/
/* Another Promise exp.
function watchTutorialCallback(callback,errorCallback){
  let userLeft = false;
  let userWatchingCatMeme = false 
  if (userLeft) {
    errorCallback({
      name: 'User Left', 
      message: ':('
    })
  } else if (userWatchingCatMeme) {
    errorCallback({
      name: 'User Watching Cat Meme',
      message: 'WebDevSimplified < Cat' 
    })
  } else {
    callback('Thumbs up and Subscribe')
  }
}

function watchTutorialPromise() {
  let userLeft = false
  let userWatchingCatMeme = false
  return new Promise((resolve, reject) => {
    if (userLeft) {
      reject({
        name: 'User Left', 
        message: ':('
      })
    } else if (userWatchingCatMeme) {
      reject({
        name: 'User Watching Cat Meme',
        message: 'WebDevSimplified < Cat' 
      })
    } else {
      resolve('Thumbs up and Subscribe')
    }
  })
}

watchTutorialCallback(message => {
  console.log(message)
}, error => {
  console.log(error.name + ' ' + error.message)
})

watchTutorialPromise().then(message => {
  console.log(message)
}).catch(error => {
  console.log(error.name + ' ' + error.message)
})

// const recordVideoOne = new Promise((resolve, reject) => {
//   resolve('Video 1 Recorded')
// })

// const recordVideoTwo = new Promise((resolve, reject) => {
//   resolve('Video 2 Recorded')
// })

// const recordVideoThree = new Promise((resolve, reject) => {
//   resolve('Video 3 Recorded')
// })

// Promise.all([
//   recordVideoOne,
//   recordVideoTwo,
//   recordVideoThree
// ]).then(messages => {
//   console.log(messages)
// })

// Promise.race([
//   recordVideoOne,
//   recordVideoTwo,
//   recordVideoThree
// ]).then(message => {
//   console.log(message)
// })
*/

/* with Promise you will wait till declaring y because then will excute at the end of main stack
let x = 2;
let sum;
let p1 = new Promise((resolve , reject)=> {
  resolve(x)
})
p1.then((resolved) =>{
  sum = resolved + y
  console.log(sum) // 7
})
console.log(sum) // undefined
window.setTimeout(_=> console.log('From SetTimeout ' +  sum)) // 7
let y = 5;
*/

/* with Promise you will wait till PromptMsg from user because then will excute at the end of main stack
let promtMsg;
let p1 = new Promise((resolve, reject) => {
  resolve(promtMsg)
})
p1.then((resolved) => {
  resolved = promtMsg ? promtMsg : "No Msg"
  console.log(resolved)
}).catch((rejected) => {
  console.log(rejected)
})

promtMsg = prompt("Promise?", "Please write something!");
*/


// -----------ignoring Pyramid of doom ( callback hell)-----------

// const myPromise = new Promise((resolve , reject)=> {
//   let thePosts = ["A","B","C","D","E","F","G","H"];
//   resolve(thePosts);
// });

// myPromise
//   .then((result) => {
//     console.log("Total no. of Posts is " + result.length + " Posts")
//     return result
//   })
//   .then((result) => {
//     console.log(`The first Post is ${result[0]}`)
//     return result
//   })
//   .then((result) => {
//       console.log(`The Last Post is ${result[result.length - 1]}`)
//       return result
//   })
//   .then((result) => {
//       console.log(`Application has ${result.length / 2} Pages`)
//       return result
//   })

// -------------fetch---------------
/* 
Fetch return a promise object 
resolve => when the server reply to the request and data come in
data.json() return a promise object also
*/
// fetch ("https://api.github.com/users/ElzeroWebSchool/repos")
//   .then(
//     (result) => {
//       let allRepos = result.json()
//       console.log(allRepos)
//       return allRepos;
//     }
//   )
//   .then(
//     (result) => {
//       console.log(`Total Number of Repos is ${result.length}`)
//       return result
//     }
//   )
//   .then(
//     (result) => {
//       console.log(`First Repo is ${result[0].name}`)
//       return result
//     }
//   )
//   .then(
//     (result) => {
//       console.log(`Last Repo is ${result[result.length - 1].name}`)
//       return result
//     }
//   )
//   .then(
//     (result) => {
//       result.forEach(element => {
//         let newElement = document.createElement("div")
//         let elementText = document.createTextNode(element.name)
//         newElement.appendChild(elementText)
//         document.body.appendChild(newElement)
//       });
//     }
//   )

// ----------------Promise All and race , allSettled------------------------------

// const myFirstPromise = new Promise((resolve , reject) => {
//   let connect = true;
//   if (connect) {
//     resolve("First Promise Resolved")
//   }else {
//     reject ("First Promise Rejected")
//   }
// })
// const mySecondPromise = new Promise((resolve , reject) => {
//   let settings = false;
//   if (settings) {
//     resolve("Second Promise Resolved")
//   }else {
//     reject("Second Promise Rejected")
//   }
// })
// promiseAll accept array of promises and return array if resolved of all promises if one of promises rejected will not return that array
// Promise.all([myFirstPromise, mySecondPromise]).then(
//   (result) => console.log(result)
// ).catch((result) => console.log(result))

// const myFirstPromise = new Promise((resolve , reject) => {
//   // window.setTimeout(() => {
//   //   resolve("First Promise Resolved")
//   // },500)
//   window.setTimeout(resolve , 500 , "First Promise Resolved")
// })
// const mySecondPromise = new Promise((resolve , reject) => {
//   // window.setTimeout(() => {
//   //   resolve("Second Promise Resolved")
//   // },100)
//   window.setTimeout(resolve , 100 , "Second Promise Resolved")
// })

// myFirstPromise.then((result) => console.log(result))
// mySecondPromise.then((result) => console.log(result))

// // promise race accept array of promises and return the fastest Promise
// Promise.race([myFirstPromise , mySecondPromise]).then((result) => {
//   console.log(result)
// })

// if all promises don't have delay by setTimeout the first one in array will be first resolve
// let p1 = Promise.resolve("First")
// let p3 = Promise.resolve("Third")
// let p2 = Promise.resolve("Second")
// Promise.race([p2,p1,p3]).then((result) => console.log(result)) // second

// ----- race vs all vs allSettled vs any
// let p1 = new Promise((resolve, reject) => {
//   // reject(1)
//   resolve(1)
// })
// let p2 = new Promise((resolve, reject) => {
//   resolve(2)
// })
// let p3 = new Promise((resolve, reject) => {
//   reject(3)
//   // throw Error("Error from Promise")
// })
// let p4 = new Promise((resolve, reject) => {
//   reject(4)
// })

// // all will return array if all promises resolved and you can loop on that array
// Promise.all([p1,p2,p3,p4])
//   .then((results) =>{
//     results.forEach((result) => {
//       console.log({result})
//     })
//   })
//   .catch((err) => console.log(`Rejected From all Promise no.: ${err}`))

// // race will return fastet resolve or reject
// Promise.race([p1,p2,p3,p4])
//   .then((result) => {
//     console.log(`Resolved from race ${result}`)
//   })
//   .catch((err) => console.log(`Rejected From race Promise no.: ${err}`))

// // allSettled return array of objects {status : , value : } if resolved and {status : , reason : } if rejected
// // rejected will not trigger catch but will return {status : , reason : } from then
// // error will not trigger catch but will return {status : , reason : Error}
// Promise.allSettled([p1,p2,p3,p4])
//   .then((results) => {
//     results.forEach((result => console.log(result)))
//   })
//   .catch((err) => console.log(`Rejected From allS Promise no.: ${err}`))

// // regular then
// p1.then((result)=>{
//   console.log(`resolved from regular p1 ${result}`)
// })
//   .catch((err) => console.log(`Rejected From regular Promise no.: ${err}`))

// // any => like race but race if first promise rejected will got to Error with catch but with any will search 
// // for all promises and give you first founded promise resolved
// Promise.any([p1,p2,p3,p4])
//   .then((result) => {
//     console.log(`Resolved from any Promise no. ${result}`)
//   })
//   .catch((err) => console.log(`Rejected From any Promise no.: ${err}`))


/* 
small note about order of output in last exp.
[1] resolved from regular p1 1
[2] Resolved from race 1
[3] loop from Promise.allSettled
[4] Rejected From all Promise no.: 3

* 
- regular P1 is the first in console despite last in code because p1.then will be excuted once p1 resolved
but race , all and allSettled should check for each promise in array [p1,p2,p3,p4] and will take 
time but regular only one promise p1

- Promise.all is the last in console despite the first in code because promise.all will only be resolved
when all [p1,p2,p3,p4] resolved but p3 and p4 rejected so will go to catch and all catches will
be excuted after then

- Promise.allSettle is in console before Promise.all but in code after because Promise.allSettle 
will not go to catch so then(s) before catch(s) 

*/
// ------------------------promise.all with imgs---------------------------
// let log = console.log;
// let warn = console.warn;

// let p1 = new Promise((resolve, reject)=>{
//     let img = document.createElement('img');
//     img.setAttribute('alt', '');

//     img.addEventListener('load', function(ev){
//         //the CSS has been loaded into the style tag
//         log('your image be here')
//         resolve(img);
//     });
//     img.addEventListener('error', function(err){
//         //there was an error
//         warn('your image is ready, NOT.')
//         reject(err);
//     });
//     img.src = "https://picsum.photos/g/500/300?image=1";
//     document.body.appendChild(img);
// });

// let p2 = new Promise((resolve, reject)=>{
//   let img = document.createElement('img');
//   img.setAttribute('alt', '');

//   img.addEventListener('load', function(ev){
//       // load event will trigger once the image loaded but if you load css file 
//       // the load event will only load once you append css file to head
//       log('your image be here')
//       resolve(img);
//   });
//   img.addEventListener('error', function(err){
//       //there was an error
//       warn('your image is ready, NOT.')
//       reject(err);
//   });
//   img.src = "https://picsum.photos/g/500/300?image=2";
//   document.body.appendChild(img);
// });

// //  promise.all accept array of promises as parameter and the parameter 
// // inside then is an array of resolved values from promises
// Promise.all([p1, p2])
// .then((things)=>{  
//     log('BOTH the links for CSS have been loaded');
//     //now my page can run and use both the scripts
//     //OR images, or scripts...
//     console.log(things) // [img,img] 
// })
// .catch((err)=>{
//     warn('SOMETHING BAD HAPPENED')
// })

// ---------------------Promise.all with fetch------------
// fetch return promise so that you can use promise all on fetches 

// let output = document.getElementById("output")
// let url1 = 'http://jsonplaceholder.typicode.com/users/1'
// let url2 = 'http://jsonplaceholder.typicode.com/users/2'
// let url3 = 'http://jsonplaceholder.typicode.com/users/3'
// let p1 = fetch(url1)
// let p2 = fetch(url2)
// let p3 = fetch(url3)

// // fetches return promises so that you can use promise all on fetches
// Promise.all([p1, p2, p3])
//   // after then of promises (from fetches) we will take responses as array
//   .then((responses)=>{ 
//     // we need to loop over array of responses and apply .json() on each response
//     responses.forEach (p => {
//       // .json() return also promise and we need to use .then() to get data
//       let prom = p.json()
//       prom.then(res => {
//         let parag = document.createElement("p");
//         // now we get the data as object so we transfere this data object to string using JSON.stringify(res) 
//         parag.textContent = JSON.stringify(res);
//         output.appendChild(parag)
//       })
//     })
//   });

// ---------------async / await ------------------
/* 
with async await you tell JS engine convert this function to promise
the function will run its synchronous prefix immediately, 
but whenever you await something, the rest of its code will be put into a microtask 
because await wrap everything behind it in Promise.resolve()
*/

/* ----Normal Function
normal function return myProm (Promise {<Pending>}) and when we try to console.log(myProm) 
will give us also (Promise {<Pending>}) because it's inside normal function and excuted synchronous
*/
// function promFunc(){
//   // Promise Object
//   let myProm = new Promise((res,rej)=>{
//     setTimeout(function(){
//       res(77)
//     },5000)
//   })
//   // will excute immediatly will not wait the Promise to be resolved
//   console.log("From Inside 1" ,myProm) // promise Pending
//   // will return (Promise {<Pending>})
//   return myProm
// }
// // will return (Promise {<Pending>})
// console.log(promFunc())
// // will print the resolved value after 5 sec because we used then and wait till Promise to be resolved
// promFunc().then(doubleSeven => console.log(doubleSeven))

/* ------Async function without await 
it's like normal function but the difference is Async functions always return a promise. 
If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.
*/
// async function promFunc3(){
//   return 88
// }
// // return {<fulfilled>: 88} because always Async function return 
// console.log(promFunc3())
// // will print the resolved value immediatly because we used then
// promFunc3().then(result => console.log(result))

/* ----Async Function + await
Async Function return here myProm (Promise {<Pending>}) and when we try to console.log(myProm) 
will give us (77) because it's inside Async function and we add await before promise to pause the excution
until the promise resolved and take value of resolved promise and assign it to myProm ( that's how await works)
*/
// async function promFunc2(){
//   // await will pause the excution till promise resolved then take value of resolved and assign it to myProm
//   let myProm = await new Promise((res,rej)=>{
//     setTimeout(function(){
//       res(77)
//     },5000)
//   })
//   // 77 after 5 sec not (Promise {<Pending>}) because of await
//   console.log("From Inside 2", myProm) // 77
//   return myProm
// }
// // will return (Promise {<Pending>}) because return will not pause or wait till promise resolved
// console.log(promFunc2())
// // will print the resolved value after 5 sec because we used then and wait till Promise to be resolved
// promFunc2().then(doubleSeven => console.log(doubleSeven))

// ---------async with fetch
// [1] without Async - Await
// let url = 'http://jsonplaceholder.typicode.com/users/7'
// fetch(url)
//   .then(function(response){
//     if(response.status === 200){
//       return response.json()
//     }else{
//       return Promise.reject(response.statusText)
//     }
//   }) 
//   .then(function(data){ 
//     console.log( data ); 
//   }) 
//   .catch(function(err){ 
//     console.log(err) 
//   }); 

// [2] with Async - Await
// let url = 'http://jsonplaceholder.typicode.com/users/7'
// async function asyncAwait(){
//   let response = await fetch(url);
//   let responseObj = await response.json()
//   console.log(responseObj)
//   return responseObj
// }

// console.log(asyncAwait()) // promise pending

// -----------finally-----------
// finally will always run regardless resolved , rejected or Error finally will always work
// let myPromise = new Promise((resolve , reject) => {
//   // resolve("Resolved!")
//   // reject("Rejected!")
//   throw Error ("Error from inside Promise")
// })
// myPromise
//   .then(console.log)
//   .catch((err)=>{
//     console.log(err)
//   })
//   .finally(_ => {
//     console.log("From Finally")
//   })

// -------then accept upto 2 arguments 1st callback func is for resolved and 2nd for rejected--------------

// let p1 = new Promise((resolve , reject)=>{
//   // resolve("Resolved")
//   reject("Rejected")
//   // throw Error("Error")
// })
// p1 
//   .then((result)=> {
//     console.log(`1st then 1st func : ${result}`)
//     // throw Error("Error from 1st then 1st func")
//     // return "Value from 1st then 1st func"
//   },
//   (result)=>{
//     console.log(`1st then 2nd func: ${result}`)
//     // throw Error("Error from 1st then 2nd func")
//     // return "Value from 1st then 2nd func"
//   })
//   .then((result)=>console.log(`2nd then : ${result}`))
//   .catch((err)=>console.log(`Catch: ${err}`))

  /* 
  2nd then will only show the value returned from 1st then not catching any Errors or rejects 
  2nd function in 1st then will catch any Errors or rejects 
  catch will catch Error from thens because then return Promise Object also
  */

// Promise.then() is also a promise
// let p1 = new Promise((resolve , reject)=>{
//   resolve("Resolved")
//   reject("Rejected")
//   throw Error("Error")
// })
// let p1Then = p1.then((result)=>result)
// p1Then.then((result)=>console.log(result)).catch((err)=>console.log(err))

//----------------------------------Object Oriented Programming-----------------------------

/* 
The idea behind object-oriented programming (OOP) is that you organize your code 
in classes/ objects (objects are based on classes).
Your data is stored in properties, your logic in methods. 
And properties and methods that work closely together live in the same class.
*/

// Procedual vs OOP

/* 
[1] Procedual Programming
- Progran divided into Function + Variables
- Overloading is not possible (function overloading => the concept where multiple functions with the same names can have different implementations)
- Hiding Data not possible
- Data is separated

[2] OOP
- Program divided into Objects + Methods
- Overloading is possible (not supported in JS ... supported in other languages)
- Hiding data possible
- Data is in one location
*/

/* 
defining Object
[1] Object Literal
[2] new Keyword
[3] Object.create()
[4] Object.assign()
*/

// [1] Object Literal
// let user = {
//   firstName : "Mohamed",
//   lastName : "Hussein",
//   adresses : {
//     egy : "Cairo",
//     usa : "California",
//     ksa : "Riyadh",
//     getMainAdress : function(){
//       return `Main Adress is ${this.egy}`
//     }
//   },
//   getFullName : function(){
//     return `Full names is ${this.firstName} ${this.lastName}`
//   }
// };
// console.log(user.firstName) //Dot Notaion
// console.log(user["lastName"]) //Bracet Notaion
// console.log(user.getFullName())
// console.log(user.adresses.egy)//Dot Notaion
// console.log(user["adresses"]["usa"])//Bracet Notaion
// console.log(user.adresses.getMainAdress())

// Arrow Function syntax but we can not use this here because arrow function does not hasv it's own this
// let user = {
//   firstName : "Mohamed",
//   lastName : "Hussein",
//   age : 33,
//   adresses : {
//     egy : "Cairo",
//     usa : "California",
//     ksa : "Riyadh",
//     getMainAdress : () =>`Main Adress is ${user.adresses.egy}`,
//   },
//   getFullName :() => `Full names is ${user.firstName} ${user.lastName}`,
//   getAgeinDays : () => `Age in Days is ${user.age * 356}`
// };
// console.log(user.firstName) //Dot Notaion
// console.log(user["lastName"]) //Bracet Notaion
// console.log(user.getFullName())
// console.log(user.adresses.egy)//Dot Notaion
// console.log(user["adresses"]["usa"])//Bracet Notaion
// console.log(user.adresses.getMainAdress())
// console.log(user.getAgeinDays())

// Dot Notaion vs Bracket Notation

// let myObj = {
//   "One" : 1,
//   "Two-" : 2,
//   3 : "Three",
//   4 : "Four",
//   "Five" : "by Variable"
// }
// let myVar = "Five"

// Dot Notation
// console.log(myObj."One") // Syntax Error
// console.log(myObj.Two-) // Syntax Error
// console.log(myObj.3) // Syntax Error
// console.log(myObj.4) // Syntax Error
// console.log(myObj.myVar) // undefined

// Bracket Notation
// console.log(myObj["One"])
// console.log(myObj["Two-"])
// console.log(myObj["3"])
// console.log(myObj["4"])
// console.log(myObj[myVar])

// [2] new Keyword
// let user = new Object()
// user.firstName = "Mohamed"
// user.lastName = "Hussein"
// user["age"] = 33
// user.getFullName = () => `Full Name is ${user.firstName} ${user.lastName}`
// console.log(user)
// console.log(user.getFullName())

// [3] Object.create()
// let mainObj = {
//   hasDicount : false,
//   showMsg : function (){
//     // but you have to use this if user.hasDicount you can not change value of property (hasDiscount) from otherObj
//     return `You ${this.hasDicount ? "" : "Don't "}Have Discount`
//   } 
// }
// console.log(mainObj.showMsg())

// let otherObj = Object.create(mainObj)
// console.log(otherObj) //{} properties and methods inside prototype
// otherObj.hasDicount = true
// console.log(otherObj.showMsg())

// let otherObj2 = Object.create(mainObj)
// otherObj.hasDicount = false
// console.log(otherObj.showMsg())


// [4] Object.assign()

// const src1 = {
//   prop1 : "Value 1",
//   prop2 : "Value 2",
//   method1 : function(){
//     return `Method 1`
//   }
// }

// const src2 = { 
//   prop3 : "Value 3",
//   prop4 : "Value 4",
//   method2 : function(){
//     return `Method 2`
//   }
// }

// const targetObj = {
//   prop5 : "Value 5"
// }

// Object.assign(targetObj, src1, src2, {prop6 : "value 6"})
// console.log(targetObj)

// const newObj = Object.assign({}, {prop7 : "Value 7"})
// console.log(newObj)

// Delete Operator (to delete property of object)

// const userName = {
//   name : "Soliman"
// }

// console.log(userName)
// console.log(userName.name)
// // you cannot delete object but you can delete properties
// // delete userName;
// delete userName.name;
// console.log(userName)
// console.log(userName.name)

// because of freeze you can not delete property
// const freezedObj = Object.freeze({age  : 33})
// console.log(freezedObj)
// console.log(freezedObj.age)
// delete freezedObj.age;
// console.log(freezedObj)
// console.log(freezedObj.age)

// you can not delete variable
// const userName = "Soliman"
// console.log(userName)
// delete userName;
// console.log(userName)

// because of configurable : false you can not delete property
// const emptyObj = {}
// Object.defineProperty(emptyObj, "a", {value : 1, configurable : false})
// console.log(emptyObj.a)
// delete emptyObj.a
// console.log(emptyObj.a)

// For ---- in Loop ( loop on Properties inside Object)

// const user = {
//   name : "Soliman",
//   Country : "Egypt",
//   age : 37
// }
// for (let prop in user){
//   console.log(prop)
// }
// let allData = ""
// for (let prop in user){
//   console.log(user[prop])
//   allData += user[prop] + " "
// }
// console.log(allData)


// let obj = {name : "Mohamed"}
// let obj2 = Object.create({} ,{age : {value : 33}})
// let obj3 = Object.assign(obj)
// obj3.name = "hi"
// console.log(obj2)


// ---------------------Constructor---------------------

// this refer to created object
// function Phone(serial, color , price) {
//   this.serial = 1;
//   this.color = 2;
//   this.price = 3;
// }
//  called instance (new keyword will invoke the constructor)
// let phone1 = new Phone(123,"red",500)
// // values from constructor will override
// console.log(phone1) // 1 2 3

// function Phone(serial, color , price) {
//   this.serial = serial;
//   this.color = color;
//   this.price = price - 100;
// }
// let phone1 = new Phone(123,"red",500)
// console.log(phone1) // 123 red 500
// let phone2 = new Phone(324,"black",500)
// let phone3 = new Phone(564,"blue",500)
// let phone4 = new Phone(867,"silver",500)
// let phone5 = Phone(746,"Pink",500)
// console.log(phone2)
// console.log(phone3)
// console.log(phone4)
// let phone6 = {serial : 123}
// console.log(phone4 instanceof Phone) //true
// console.log(phone4.constructor === Phone) //true
// // phone4.constructor.prototype === phone4.__proto__
// console.log(phone4.__proto__.constructor === Phone) //true
// console.log(phone6 instanceof Phone) //false
// console.log(phone6.constructor === Phone) //false
// console.log(phone5) // undefined
// console.log(this.serial) // 746

// function User(fName,lName,age){
//   this.fName = fName;
//   this.lName = lName;
//   this.age = age;
//   this.country = "EGYPT"
//   // this.fullName = _ => `Full Name: ${this.fName} ${this.lName}`
//   this.fullName = function(){ return `Full Name: ${this.fName} ${this.lName}`} 
// }
/* 
Why this inside Arrow function inside constructor refer to created Object?
Instance Objects are powerful because they are derived from a function, 
they provide private scope when they are created, and expressions can be executed on instantiation.
But A JavaScript object literal does not, by nature, provide private scope.

Arrow functions don't have their own context. Instead, the context is inherited from the function in which they’re defined.
So inside constructor function this === {}. While, when defining object literal this still points to global object or undefined if in strict mode.
*/

// let user1 = new User("Mohamed","Hussein",33)
// let user2 = new User("Osama","elzero",37)
// console.log(user1)
// console.log(user2)
// console.log(user2.fullName())

// function User(name,email,age,showEmail){
//   this.name = name;
//   // this.email= email;
//   this.age = age;
//   this.updateName = function(newName){
//     if(this.age > 18){
//       this.name = newName
//     }else{
//       console.log("You can not update the name")
//     }
//   }
//   this.showEmail = function(){
//     if(showEmail){
//       return `Email is ${this.email}`
//     }else{
//       return `Data is Private`
//     }
//   }
// }

// let user1 = new User("Soliman", "o@nn.sa", 37,false)
// console.log(user1)
// console.log(user1.showEmail())
// user1.updateName("Mohamed")
// console.log(user1)

// ------built-in Constructor

// let obj2 = new Object({b:2})
// let obj1 = new Object({a:1})

// let num1 = new Number(1)
// let num2 = new Number(2)

// let str1 = new String("Mohamed")
// let str2 = new String("Ahmed")

// // here under the hood you are using String Constructor let str3 = new String("Soliman")
// let str3 = "Soliman"


// -----------------protoType------------------
/* 
=> Steps of Built in Object constructor

* JavaScript has the built-in Object() function (constructor)
* Also, JavaScript provides an anonymous object that can be referenced via the prototype property of the Object() function
* The Object.prototype object has some useful properties and methods such as toString() and valueOf(). 
* The Object.prototype also has an important property called constructor that references the Object() function. 

=> Steps of Built in Person Constructor then instances 

* Behind the scenes, JavaScript creates a new function Person() and an anonymous object that can be referenced via the prototype property
* And the anonymous object (Person.prototype) has the constructor property that references the Person() function
* the JavaScript engine creates a new object named p1 (instance) and links the p1 object to the Person.prototype object via the prototype linkage:

The __proto__ is pronounced as dunder proto. The __proto__ is an accessor property of the Object.prototype object. It exposes the internal prototype linkage ( [[Prototype]]) of an object through which it is accessed.
However, it may be deprecated in favor of Object.getPrototypeOf() in the future. Therefore, you should never use the __proto__ in your production code.

Another popular way to get the prototype linkage is when the Object.getPrototypeOf() method is not available is via the constructor property as follows


example of shadowing: 
If p1 (instance ) has Method and Person(constructor) has Method with same name

P1.greet() executes it immediately without looking it up in the prototype chain.

The greet() method of the p1 object shadows the greet() method of the prototype object which the p1 object references.

*/
// ----exp. tp understant Prototype----------------
// Constructor
// function Person(name,age){
//   this.name = name 
//   this.age = age
//   this.instFunc = function(){
//     console.log("instance Method p1")
//   }
// }

// Class
// class Person2 {
//   constructor(name,age){
//     this.name = name 
//     this.age = age
//     // Property of instance not Method
//     this.classInstFunc = function(){
//       console.log("instance p2")
//     }
//   }
//   // Property for instance 
//   classInstProp = "Property"
//   // Method for Instance
//   classInstFunc2 = () => {
//     console.log("static Method from Class")
//   }
//   // Static Method for Constructor
//   static classStatFunc = () => {
//     console.log("static Method from Class")
//   }
// }
// instances
// let p1 = new Person()
// let p2 = new Person2()


// console.log(Object.hasOwnProperty("prototype")) // true
// console.log(Person.hasOwnProperty("prototype")) //true
// console.log(p1.hasOwnProperty("prototype")) // false
// // you can add method to prototype of Object ( will be shown in prototype)
// Object.prototype.polluted = function(){
//   console.log("Polluted")
// }
// Object.prototype.polluted()
// // you can add Static Method to Object ( will be shown in constructor)
// Object.polluted2 = function(){
//   console.log("Polluted2")
// }
// Object.polluted2()
// console.log(Object.prototype)
// // you can add method to prototype of Person ( will be shown in prototype)
// Person.prototype.protoFunc = function () {
//   console.log("Prototype Method from Person")
// }
// Person.prototype.protoFunc()
// // you can add Static Method to Person ( will be shown in constructor) this is before ES6
// // after ES6 adding static method by static keyword inside class see Person2 exp.
// Person.statFunc = function(){
//   console.log("Static Method from Person")
// }
// Person.statFunc()
// p1.__proto__.constructor.statFunc()
// p1.constructor.statFunc()
// console.log(Person.prototype)
// p1.protoFunc() // will work because method added to prototype and availabe for every one contructor or instances
// // p1.statFunc() // Error because it is static method and only availabe for constructor
// p1.instFunc() // will work
// // Person.instFunc() // Error because it's method for instance not availabe in prototype

// // static method from class
// Person2.prototype.classProtoFunc = function () {
//   console.log("Prototype Method from Person2")
// }
// Person2.prototype.classProtoFunc()
// console.log(Person2.prototype)
// Person2.classStatFunc()
// p2.__proto__.constructor.classStatFunc()
// p2.constructor.classStatFunc()
// // p2.classStatFunc()// Error because it is static method and only availabe for constructor
// p2.classInstFunc() // will work
// // Person2.classInstFunc() // Error because it's method for instance not availabe in prototype

// every thing in js is Object and have at the end of protoType chain Object Prototype
// function is object and created by built-in Object constructor

// steps of contructor under the Hood
// function User(name){
//   /*
// [1] Create Empty Object
// [2] assign the New Object to this Context (this = {}) 
// [3] links the new object to the User.prototype object via the prototype linkage
// */
//   this.name = name;
//   /* 
//   [4] return new Object
//   */
//   // you can throw Error by this if condition incase of new Object without new keyword 
//   // if(!(this instanceof User)){
//   //   throw new Error("no New KeyWord")
//   // }
//   // ES6 Version
//   if(!new.target){
//     throw new Error("no New KeyWord")
//   }
// }

// let user1 = new User("Mohamed")
// console.log(User.prototype)
// console.log(user1.__proto__)
// let user2 = User("Ahmed") // handmade Error from constructor
// console.log(user2)
// // Array is created by Array built-in constructor but Array constructor is created by Object 
// // constructor so prototype chain will be Array protoType => Object Prototype => null
// let myArr = [1,2,3,4]
// console.log(myArr.__proto__)


/* 
The new.target pseudo-property lets you detect whether a function or constructor 
was called using the new operator. In constructors and functions invoked using 
the new operator, new.target returns a reference to the constructor or function. 
In normal function calls, new.target is undefined.
In arrow functions, new.target is inherited from the surrounding scope.
*/
// function Constructor(name){
//   this.name = name;
//   console.log(new.target);
//   this.arrowFunc = ()=> console.log(new.target.name) ;
// }

// let instance = new Constructor("Mohamed") // Constructor
// // In arrow functions, new.target is inherited from the surrounding scope.
// instance.arrowFunc() // Constructor
// let instance2 = Constructor("Ahmed") // undefined

/* 
---------------------ProtoType chain---------------------
because Js is prototype-based not class-based language childObj is not taking a copy of properties
and methods os parentObj it is just have a link to parent's prototype using __proto__
*/
// let parentObj = {
//   prop1 : 123,
//   method1 : () => console.log("This is Method1 from parentObj")
// }
// let childObj = {}
// // prototype chain here is : 
// // childObj ---> parentObj ---> Object.prototype ---> null
// Object.setPrototypeOf(childObj, parentObj)  // same like let childObj =  Object.create(parentObj)
// // or Object.assign
// // Object.assign(childObj, parentObj) // will copy properties and methods 
// console.log(childObj.prop1)
// childObj.method1()
// console.log(childObj.__proto__)
// // this is the Prove that childObj is not taking a copy of properties
// console.log(childObj) // {} incase of Object.assign will be {prop1: 123, method1: ƒ}
// // here we are not overriding the prop1 inside parentObj we are creating a new prop1 inside childObj
// childObj.prop1 = 777;
// console.log(parentObj.prop1)
// console.log(childObj.prop1)
// console.log(childObj) // {prop1: 777}

// using Constructor
// function ParentObj(){
//   this.prop1 = 123
//   this.method1 = () => console.log("This is Method1 from parentObj")
// }
// let childObj = new ParentObj()
// // childObj ---> parentObj ---> Object.prototype ---> null
// console.log(childObj.prop1)
// childObj.method1()
// console.log(childObj.__proto__)
// console.log(childObj)

// ----------------------Classes----------------------------

/* 
Js is prototype based language not class based language.
Classes are primarily syntactical sugar for prototype-based inheritance.

the difference between ES6 Class and old syntax :
[1] Hoisting
* old syntax is a function and you can create instance before constructor function 
because function is always hoisted
* ES6 class you should create instances after class decleration 
[2] forcing to use new keyword (will throw Error autmatically not handmade Error like old syntax)

*/

// Old Syntax
// let user1 = new User("Mohamed")
// let user2 = new User("Ahmed")

// function User(name,email){
//   this.name = name;
//   this.email = email;
//   this.sayHello = _ => `Hello ${this.name}`;
// }

// console.log(user1)
// console.log(user2)

// ES6 class
// class User {
//   constructor(name, email) {
//     this.name = name;
//     this.email = email;
//     this.sayHello = _ => `Hello ${this.name}`;
//   }
// }

// let user1 = new User("Mohamed")
// let user2 = new User("Ahmed")

// console.log(user1)
// console.log(user2)

// --------------Static Properties and Methods---------------
// Static properties only for consructor not for instances

// class User {
//   // Static Properties
//   static counter = 0;
//   // constructor
//   constructor(name, email) {
//     this.name = name;
//     this.email = email;
//     // we used User not this because this here refer to created instances not class User
//     User.counter++;
//   }
//   // Methods for instances
//   sayHello = () => `Hello ${this.name}`;
//   showEmail = () => `Email is ${this.email}`
  
//   // Static Method (this here refer to class User static counter even it is arrow function)
//   static countObj = () => `${this.counter} Objects Created`
// }

// let user1 = new User("Mohamed","Email_1")
// let user2 = new User("Ahmed","Email_2")
// // will throw Error autmatically not handmade Error like old syntax
// // let user3 = User("Soliman","Email_3") 

// console.log(user1)
// console.log(user1.sayHello())
// console.log(user2)
// console.log(user2.showEmail())

// console.log(User.countObj())


// to use Static with old sytnax of constructor  you can use Object.defineProperty or directly add it by dot notation
// function User(name) {
//   this.name = name;
//   // Instance Method
//   this.innerInfo = () => console.log("Inner Method");
// }
// // Prototype Method
// User.prototype.outerInfo = () => console.log("Outer Method");
// // Static Method using defineProperty
// Object.defineProperty(User, "staticInfo", {
//   value : () => console.log("Static Method")
// })
// // Static Method using dot notation
// User.staticInfo2 = () => console.log("Static Method 2")
// let user1 = new User("Soliman")
// user1.innerInfo()
// user1.outerInfo()
// User.prototype.outerInfo()
// User.staticInfo()
// console.log(User.prototype)
// -----------static from another class ----------
// class Triple {
//   static customName = 'Tripler';
//   static description = 'I triple any number you provide';
//   static calculate(n = 1) {
//     return n * 3;
//   }
// }

// class SquaredTriple extends Triple {
//   static longDescription;
//   static description = 'I square the triple of any number you provide';
//   static calculate(n) {
//     // return Triple.calculate(n) * Triple.calculate(n); // super.calculate like Triple.calculate
//     return super.calculate(n) * super.calculate(n);
//   }
// }

// console.log(Triple.description);            // 'I triple any number you provide'
// console.log(Triple.calculate());            // 3
// console.log(Triple.calculate(6));           // 18

// const tp = new Triple();

// console.log(SquaredTriple.calculate(3));    // 81 (not affected by parent's instantiation)
// console.log(SquaredTriple.description);     // 'I square the triple of any number you provide'
// console.log(SquaredTriple.longDescription); // undefined
// console.log(SquaredTriple.customName);      // 'Tripler'

// This throws ERROR because calculate() is a static member, not an instance member.
// console.log(tp.calculate());                // 'tp.calculate is not a function'
// --------------Getter and Setter----------------
/* 
Get and Set in Js is only for simple syntax
The get syntax binds an object property to a function that will be called when that property is looked up that's why we don't need ()
in other languages like PHP there is an option for private prperties accessable only by get and set
*/

// class User {
//   constructor(name, email) {
//     this.name = name;
//     this.email = email;
//     this.sayHello = _ => `Hello ${this.name}`;
//   }
//   showInfo(){
//     return `name : ${this.name}, Email: ${this.email}`
//   }
//   get showInfoGetter(){
//     return `name : ${this.name}, Email: ${this.email}`
//   }
//   changeName(newName){
//     this.name = newName;
//   }
//   set changeNameSetter(newName){
//     this.name = newName;
//   }
// }

// let user1 = new User("Mohamed","Email-1")
// let user2 = new User("Ahmed","Email-2")
// // method
// console.log(user1.showInfo())
// // no need for ()
// console.log(user1.showInfoGetter)
// // difference between getter method and regular method only simple syntax you have been changed
// // the Method to computed property and you do not need ()
// user1.changeName("Soliman")
// console.log(user1.name) // soliman
// user1.changeNameSetter = "Hussein"
// console.log(user1.name) // Hussein


// ----------------Inheritance--------------

// ---------difference between class and old syntax in inheritance---------------

// [1] inheritance in old Syntax
/* 
Moreover, JavaScript takes advantage of this prototype chain to create Inheritance. 
To make the Admin class inherit from the User class, first we define the Admin constructor, 
making sure to call the User's constructor with its this context pointing to Admin’s. 
This is equivalent to calling super().
Then, using Object.create(), we pass in User’s prototype to return a new object with
its __proto__ property assigned to it, pointing the returned object to User’s prototype. 
For clarity, we also point Admin’s prototype constructor to itself 
because JavaScript does not do this automatically. 
Finally, we can define the protoFunc() method on the prototype.
note : if we use setPrototypeOf we do not need to point Admin’s prototype constructor to itself 
note : but performance in Object.create() is better than setPrototypeOf
*/
// function User(name,email){
//   this.name = name;
//   this.email = email;
//   this.showDetails = () => `#Name is ${name} and email is ${email}`
// }
// User.prototype.protoFunc = () => "Proto Function from User"
// User.staticFunc = () => "Static Function From User"

// function Admin(name,email,id){
//   User.call(this,name,email) // like super
//   this.id = id
//   this.showDetails = () => `&Name is ${name} and email is ${email} and id is ${id}`
// }
// // Object.setPrototypeOf(Admin.prototype, User.prototype) // like extends

// Admin.prototype = Object.create(User.prototype) 
// Admin.prototype.constructor = User

// Admin.prototype.protoFunc = () => "Proto Function from Admin"

// Admin.prototype.protoFunc2 = () => "Proto Function from Admin"
// console.log(Admin.prototype)
// let Admin1 = new User("Soliman","email")
// let Admin2 = new Admin("Soliman","email",321)
// console.log(Admin1.showDetails())
// console.log(Admin2.showDetails())
// console.log(Admin1.protoFunc())
// console.log(Admin2.protoFunc())
// console.log(User.prototype.protoFunc())
// console.log(Admin.prototype.protoFunc())
// console.log(Admin.prototype.protoFunc2())
// console.log(Admin1.protoFunc())
// console.log(Admin2.protoFunc()) 
// console.log(Admin2.protoFunc2())
// console.log(User.staticFunc())
// console.log(User.prototype)
// console.log(Admin.staticFunc()) // Error

// [2] inheritance in new syntax ( class )
// class User {
//   constructor(name, email) {
//     this.name = name;
//     this.email = email;
//     // property of instance not added to prototype
//     this.showDetails = () => `Name is ${name} and email is ${email}`;
//   }
//   // we are using Method Shorthand and add this method to prototype
//   instMethod(){return "Instance Method"} 
//   // will be added as property to prototype not Method 
//   // because we have to use a variable with it no Method shorthand for arrow function
//   arrowInstMethod = () => "Arrow Instance Method"
//   // will be added to constructor (you can access static Method from Admin but in old syntax you can not)
//   static staticFunc = () => "Static Method from User"
// }
// User.prototype.protoFunc = () => "Proto Method from User"

// class Admin extends User {
//   constructor(name, email, id) {
//     //to invoke the constructor of User
//     super(name, email); 
//     this.id = id;
//     this.showDetails = () => `Name is ${name} and email is ${email} and id is ${id}`;
//   }
// }

// Admin.prototype.protoFunc = () => "Proto Function from Admin"

// let Admin1 = new User("Soliman","email")
// let Admin2 = new Admin("Soliman","email",321)
// console.log(Admin1.showDetails())
// console.log(Admin2.showDetails())
// console.log(Admin.staticFunc())
// console.log(Admin1.protoFunc())
// console.log(Admin2.protoFunc())
// console.log(Admin.prototype)
// console.log(Admin2.instMethod())
// console.log(User.prototype)


// --------Override in inheritance-------
// class User {
//   constructor(name, email) {
//     this.name = name;
//     this.email = email;
//   }
//   sayHello = () => `Hello ${this.name}`;
//   showEmail = () => `Email is ${this.email}`
//   writeMsg = () => `Msg from parent Class`
// }

// class Admin extends User {
//   constructor(name,email){
//     super(name,email);
//   }
//   adminMsg = () => `You Are Admin`
//   // will override method from parent class
//   writeMsg = () => `Msg from Child Class`
// }

// let Admin1 = new Admin("Mohamed","Email-1")
// console.log(Admin1.sayHello())
// console.log(Admin1.adminMsg())
// console.log(Admin1.writeMsg())

// ------How to copy prototype of one constructor to another
// function Me(){
// this.name =  this.name || "Dejan";
// }
// function You(){
// this.name = this.name || "Ivan";
// }


// Me.prototype = new You();
// let somebody = new Me();
// console.log(somebody.name); // Ivan 

// class Me2 {
//   constructor() {
//     this.name = this.name || "Dejan";
//   }
// }
// class You2 {
//   constructor() {
//     this.name = this.name || "Ivan";
//   }
// }
// // In ES6, the .prototype property of classes is not writable and not configurable
// Me2.prototype = new You2();
// let somebody2 = new Me2();
// console.log(somebody2.name); // Dejan


/* 
The Advantage of inheritance in classes is you can access prototypes 
from parent and also you can override any Property or Method of parent
*/

/* 
JS engine wll search for id property inside instance(which take properties from constructor)
if did not find it inside instance will search at prototype Chain 
so in next Exp. if we remove this.id from constructor Old the outputs will be undefined and 7
*/
// function Old(name){
//   this.name = name;
//   // id here is a property of created instance
//   this.id = 6;
// }
// let user1 = new Old("Mohamed")
// console.log(user1.id) // 6 // undefined (incase of remving this.id = 6; from Old)
// // id here is prototype added to constructor
// Old.prototype.id = 7;
// console.log(Old.prototype)
// console.log(user1)
// console.log(user1.id) // 6 // 7 (incase of remving this.id = 6; from Old)

// class Old {
//   constructor(name , id = 6 ) {
//     this.name = name;
//     this.id = id;
//   }
// }
// class New extends Old {
//   constructor(name,id) {
//     super(name,id)
//   // override id of parent
//     this.id = 7;
//   }
// }
// let user1 = new Old("Mohamed")
// let user2 = new New("Soliman")
// console.log(user1.id) // 6
// console.log(user2.id) // 7



// ----------------Meta Data and Descriptor----------------

// let obj = {
//   a : 1,
//   b : 2
// }
// Object.defineProperty(obj, "c" , {
//   value : 3,
//   writable : false,
//   enumerable : false,
//   configurable: false
// })

// obj.c = 500;
// console.log(obj.c) // 3 not 500 because writable : false

// for(let prop in obj){
//   console.log(prop , obj[prop])
// } // a 1 - b 2 / c 3 will not be shown because of enumerable : false
// console.log(Object.keys(obj)) // [a,b] return only iterable properties
// console.log(Object.getOwnPropertyNames(obj)) // [a,b,c] because enumerable : false has no effect on getOwnPropertyNames

// console.log(delete obj.c) // false means can not delete property c becasue of configurable:false

// // Object.defineProperty(obj, "c" , {
// //   writable:true
// // }) // Error because of configurable:false you can not redefine property
// // obj.c = 600;
// // console.log(obj.c) 
// // default of porperty's attributes(inside Object) are true
// console.log(Object.getOwnPropertyDescriptor(obj, "a"))
// // default of porperty's attributes(created by defineProperty) are false
// console.log(Object.getOwnPropertyDescriptor(obj, "c"))

// Object.defineProperties(obj, {
//   d : {
//     value : 4,
//     writable : false,
//     enumerable : false,
//     configurable: false
//   },
//   e : {
//     value : 5,
//     writable : false,
//     enumerable : true,
//     configurable: false
//   }
// })

// console.log(obj)
// console.log(Object.keys(obj))
// console.log(Object.getOwnPropertyNames(obj))

// ---------------AJAX-------------------
// Asynchronous JavaScript And XML (Extensible Markup Language)
/* 
XML is one of the most widely-used formats for sharing structured information today: 
between programs, between people, between computers and people, both locally and across networks.
the syntax rules of XML are strict: XML tools will not process files that contain errors, 
but instead will give you error messages so that you fix them

XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data 
from a URL without having to do a full page refresh. 
This enables a Web page to update just part of a page without disrupting 
what the user is doing.
* Update a web page without reloading the page
* Request data from a server - after the page has loaded
* Receive data from a server  - after the page has loaded
* Send data to a server - in the background

Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML.
*/

/* 
The FormData interface provides a way to easily construct a set of key/value pairs 
representing form fields and their values, which can then be easily sent 
using the fetch() or XMLHttpRequest.send() method. It uses the same format 
a form would use if the encoding type were set to "multipart/form-data".
*/

//Run the script after loading DOM       
// let url = "https://jsonplaceholder.typicode.com/users";       
// let xhr = new XMLHttpRequest();       
// xhr.open("GET", url, true); // true is default and means Async - false means Sync       
// // xhr.open("POST", url, true);       
// let fd = new FormData();       
// fd.append("firstName", "Jesse");       
// fd.append("lastName", "Custer");        
// xhr.onreadystatechange = function(ev) {         
//   //2 - request sent, 3 - something back, 4 - full response         
//   console.log(xhr.readyState);         
//   if (xhr.readyState === 4) {           
//     switch (xhr.status) {             
//       case 200:             
//       case 304:               
//       console.log("OK or Not Modified (cached)", xhr.status);               
//       outputUsers(xhr.responseText); //responseXML               
//       break;             
//       case 201:               
//       console.log("Created", xhr.status);               
//       let main = document.querySelector("#xml");               
//       main.textContent = xhr.responseText;               
//       break;             
//       case 403:             
//       case 401:               
//       console.log("Not Authorized or Forbidden", xhr.status);               
//       break;             
//       case 404:               
//       console.log("Not Found", xhr.status);               
//       break;             
//       case 500:               
//       console.log("Server Side Error", xhr.status);               
//       break;             
//       default:               
//       console.log("Some other code: ", xhr.status, xhr.status);           
//     }         
//   }       
// }; 
// // another way to use onload instead of onreadystatechange 
// // xhr.addEventListener("load", function(){
// //   if (xhr.readyState === 4){
// //     console.log("OK or Not Modified (cached)", xhr.status);               
// //     outputUsers(xhr.responseText); //responseXML 
// //   }
// // })      
// xhr.onerror = function(err) {         
//   console.warn(err);       
// };       
// xhr.send(null); // with GET        
// // xhr.send(fd); // With POST
// function outputUsers(str) {         
//   let data = JSON.parse(str);         
//   let main = document.querySelector("#xml");         
//   data.forEach(item => {           
//     let p = document.createElement("p");           
//     p.textContent = item.id + " " + item.name;           
//     main.appendChild(p);         
//   });       
// }

/* ------onload vs onreadystatechange-------------------
A readystatechange occurs several times in the life of a request as it progresses to 
different phases, but a load event only occurs when the request has successfully completed.
If you're not interested in detecting intermediate states or errors, then onload might be a good choice.

* onreadystatechange needs : if (xhr.readyState === 4) & if (xhr.status === 200)
* onload needs only : if (xhr.readyState === 4)
*/

// var uri = 'http://jsonplaceholder.typicode.com/users/s7'; 
//none of these examples do proper error handling of 
//nasty http status codes or 
//invalid data types - text, xml, json, etc 
//********************************************************* 

// OLD Version AJAX 
// var xhr = new XMLHttpRequest(); 
// xhr.open('GET', uri, true); 
// xhr.addEventListener('load', function(ev){
//   if(xhr.status === 200 && xhr.readyState === 4){
//     //handle the response from the server 
//     var data = xhr.responseText; //or responseXML 
//     var json = JSON.parse(data); //JSON object 
//     console.log('XMLHttpRequest: ', json)
//   }else if(xhr.status === 404){
//     throw new Error(uri)
//   }
// }); 
// xhr.addEventListener('error', function(err){ 
//   //error handling network request but not for HTTP errors like 404
// }) 
// window.addEventListener('error', function(err){ 
//   //error handling for HTTP errors you should throw an Error by yourself if(xhr.status === 404)
//   console.log(err.message)
//   // to stop error to be shown (uncaught Error)
//   err.preventDefault()
// }) 
// xhr.send(null); 
  //********************************************************* 
  
//NEW Version AJAX 
// fetch(uri) 
//   .then(function(response){
//     if(response.status === 200){
//       return response.json()
//     }else{
//       return Promise.reject(response.statusText)
//     }
//   }) 
//   .then(function(data){ 
//     console.log( data ); 
//   }) 
//   .catch(function(err){ 
//     //error handling network request err = response because of return Promise.reject(response)
//     console.log(err) 
//   }); 
    //********************************************************* 
    
//REALLY OLD Version AJAX 
//IE 5.5 ActiveX object or XMLHttpRequest object 
// var request = false; 
// if (window.XMLHttpRequest) { 
//     // Mozilla, Safari,... 
//     request = new XMLHttpRequest(); 
//   } else if (window.ActiveXObject) { 
//     // IE 
//     try { 
//       request = new ActiveXObject("Msxml2.XMLHTTP"); 
//     } catch (e) { 
//       try { 
//         request = new ActiveXObject("Microsoft.XMLHTTP"); 
//       } catch (e) {} 
//     } 
//   } if(request){ 
//     request.open('GET', uri, true); 
//     request.addEventListener('load', function(ev){ 
//       if(request.status === 200 && request.readyState === 4 ){
//         //handle the response from the server 
//         var data = request.responseText; 
//         //or responseXML 
//         var json = JSON.parse(data); 
//         //JSON object 
//         console.log('XMLHttpRequest: ', json);
//       }else if(request.status === 404){
//         throw new Error(uri)
//       }
//     }); 
//     request.addEventListener('error', function(err){ 
//       //error handling request
//     }) 
//     window.addEventListener('error', function(err){ 
//       //error handling for HTTP errors you should throw an Error by yourself if(xhr.status === 404)
//       console.log(err.message)
//       // to stop error to be shown (uncaught Error)
//       err.preventDefault()
//     })
//     request.send(null); 
  // }
// ----------------Error Handling-----------------
// with onerror you can catch the error but you can not use preventDefault() user return true instead
// window.onerror = function (msg, url , col , err){
//   console.log(msg, url , col , err)
//   return true
// }
// soliman

// with addEventListener you can catch the error and you can use preventDefault()
// window.addEventListener("error" , function(ev){
//   console.log(ev)
//   ev.preventDefault()
// })
// soliman

// A 404 status will not trigger xhr.onerror() because, 
// technically it's not an error; the 404 itself is a valid response.

// ---------Error in fetch---------
/* The fetch() function will automatically throw an error for network errors 
but not for HTTP errors such as 4xx or 5xx responses. */

// fetch('http://jsonplaceholder.typicode.com/users/7')
//   .then(async response => {
//     const isJson = response.headers.get('content-type')?.includes('application/json');
//     const data = isJson ? await response.json() : null;
//     // check for error response
//     if (!response.ok) {
//       // get error message from body or default to response status
//       const error = (data && data.message) || response.status;
//       return Promise.reject(error);
//     }
//   })
//   .catch(error => {
//     console.log('There was an error!', error);
//   });

// ? and (&&) explanation of last exp.
// let arr = [1,2,3,4]
// let check = arr?.includes(5)
// console.log(check)
/* 
the operator returns the value of the first falsy operand encountered when evaluating 
from left to right, or the value of the last operand if they are all truth
*/
// let x = null;
// let y = 2; 
// let xy = ( x && y );
// console.log(xy)
// ------------------------Try Catch--------------------------

// Programme will crash 
// throw "ERROR" 
// console.log("After ERROR")

// Programm will not crash and continue normally
// try{
//   throw "ERROR"
//   console.log("After Error Directly") // will not be excuted
// }catch(err){
//   console.log(err)
// }finally{
//   console.log("Will Work regardless there is Error or not") // like outside
// }
// console.log("After ERROR of try catch")

// -------------------Function curring----------------------
/* 
Why Function is First-Class Object ? 
* A function is an instance of the Object type
* A function can have properties and has a link back to its constructor method
* You can store the function in a variable
* You can pass the function as a parameter to another function
* You can return the function from a function
*/

// function sayHello(msg){
//   return function (name){
//     console.log(msg, name)
//   }
// }
// let english = sayHello("Hi")
// let espanol = sayHello("Hola")
// let svenska = sayHello("Hej")
// let detusch = sayHello("Hello")
// english("Tom")
// espanol("Matheio")
// svenska("Ikea")
// detusch("Thomas")

// different between function curring and callback hell
// function curring => function return another function
// callback hell => passing function as parameter to another function

// -----------------Time and Date in JavaScript------------------

// let d = new Date() // constructor accept as parameters (TimeStamp(miliseconds) | Date String | numeric Values)
// console.log(d)
// let s = Date.now() // static method
// console.log(s) // miliseconds after default start date (Unix Epoch) Jan 1 00:00:00.0000 1970
// [1] TimeStamp 
// let d1 = new Date(1500000000000) // Date after 1500000000000 miliseconds start point Jan 1 00:00:00.0000 1970
// console.log(d1)
// [2] Date String
// let d2 = new Date("20 July 2012")
// console.log(d2)
// [3] Numeric Value :  year , Month , day , hours , minutes , seconds ,miliseconds
// let d3 = new Date(2017,0,2,13,30,40)
// console.log(d3)
// let d4 = d3-d2 // you can get difference by using - and result will be in miliseconds
// console.log(d4)
// you can use Date.parse to change Date to miliseconds
// console.log(Date.parse("Sep 1 1988"))
// using T and Z => T is space between date and Time | Z is time zone with Z will give you the time in your Time zone 
// console.log(new Date("1982-10-25T06:10:00Z"))

// // to change in date
// d.setFullYear(2020)
// d.setMonth(0) // will give you Jan because Month in 0 index
// d.setDate(12) // 0 will give you day 30 of last month | -1 negative value will give you day 29 of last month  
// d.setHours(9)
// d.setMinutes(20)
// d.setSeconds(30)
// d.setMilliseconds(50)
// you can also add more parameters for Exp. d.setMonth(0,12)
// d.setMonth(0,12) // 0 => Jan & 12 => day 12
// console.log(d)

// let getFullYear = d.getFullYear()
// let getMonth = d.getMonth() // 0 index => jan is 0 
// let getDate = d.getDate() // day of the month
// let getHours = d.getHours()
// let getMinutes = d.getMinutes()
// let getSeconds = d.getSeconds()
// let getMilliseconds = d.getMilliseconds()
// // not availabe in set methods
// let getDay = d.getDay() // give you day of the week 0 index =>  0 sunday => 1 monday => .....
// console.log(getDay)

// let d4 = new Date()
// console.log(d4.toDateString())
// console.log(d4.toTimeString())
// console.log(d4.toISOString()) // another format
// console.log(d4.toJSON()) // another format
// console.log(d4.toLocaleString()) // another format
// console.log(d4.toLocaleString("en-kw")) // another format
// console.log(d4.toUTCString()) // another format

// add d days to a date
// function myFunction(a,b){
//   return a.setDate(b + a.getDate())
// }

// console.log(myFunction(new Date(Date.UTC(2000,01,01)), 31)) //952041600000
// console.log(myFunction(new Date(Date.UTC(2000,01,01)), 10)) //950227200000
// console.log(myFunction(new Date(Date.UTC(2000,02,28,)), 2)) //954374400000


// -----------------null vs undefined----------------
// null is nothing value and you can add it to variable for exp. if you don't know yet what to assign to this variable
// but undefined is nothing added to variable or function does not return something or when you try to access property not exist in specific object
// null means this property exist but nothing in it 
// undefined means this property not exist

// console.log( null + 1) // 1
// console.log( undefined + 1) // NaN

// console.log(typeof null) //Object
// console.log(typeof undefined) // undefined

// -------------------debugging in Js--------------------
/* 
console.count => count how many time console.count method called for specific argument (var1 or var2)

console.time & console.timeEnd => calculate time in miliseconds start from  console.time to console.timeEnd
console.time("label") you can pass label for each timer to pass it again to console.timeEnd to end it

console.group & console.groupEnd to create a group will be shown in console and you can use also console.group("label1")

DEBUG_MODE if true will open source at line which have debugger; automatically 
and you can excute file line by line or you can mark specific line to pasue the code at this line
in source tab at bottom there is {} called pretter (it is like formatter) to organize code 
then you can add break points for debug easliy
*/
// const DEBUG_MODE = true;
// if(DEBUG_MODE){
//   debugger;
// }

// console.time("label1")
// console.group("label1")
// let var1 = "Mohamed"
// let var2 = "Soliman"
// function logCount(param){console.count(param)}
// logCount(var1) // Mohamed : 1
// logCount(var2) // Soliman : 1
// console.count(var1) // Mohamed : 2
// console.groupEnd("label1")
// console.timeEnd("label1")
// console.time("label2")
// console.group("label2")
// let arr = []
// for(let i = 0; i <= 100; i++){
//   arr.push(i)
// }
// console.log(arr)
// console.groupEnd("label2")
// console.timeEnd("label2")

// --------------NaN-------------
/* 
isNaN() try first to convert it to number by Number() or + 
if converted value is not Number return true
if if converted value is Number return false
*/
// console.log(isNaN(true)) // false => +ture 1
// console.log(isNaN(false)) // false => +false 0
// console.log(isNaN(null)) // false => +null 0
// console.log(isNaN(1)) // false => +1 1
// console.log(isNaN("1")) // false => +"1" 1
// console.log(isNaN("")) // false => +"" 0
// console.log(isNaN(" ")) // false => +"  " 0
// console.log(isNaN(new Date())) // false => timeStamp
// console.log(isNaN(new Date("31 Jan, 2022"))) // true
// console.log(isNaN(undefined)) // true => +undefined NaN
// console.log(isNaN("Soliman")) // true => +"Soliman" NaN
// console.log("" == false)  // true
// console.log("" == 0)  // true
// console.log(" " == 0)  // true
// console.log(" " == false)  // true
// console.log(0 == false) // true
// console.log(" " == "") // false

// ---------------Arguments keyWord---------------
// function args(){
//   console.log(arguments)
// }
// args(1,2,3,4,5)

// --------------delete keyWord-----------
// delete keyWord only for properties of object
// let obj = {
//   prop1 : 1,
//   prop2 : 2,
//   prop3 : 3
// }
// obj.prop2 = undefined;
// delete obj.prop3;
// console.log(obj.prop1) // 1
// console.log(obj.prop2) // undefined but still exist because you change it value to undefined by yourself
// console.log(obj.prop3) // undefined because it's not exist because we deleted it
// console.log(obj.prop4) //undefined because it's not exist
// for(let p in obj){
//   console.log(p)
// }

// -------------------Void------------

/*
The void operator evaluates the given expression and then returns undefined.
This operator allows evaluating expressions that produce a value into places where an expression that evaluates to undefined is desired.
*/

// [1] void with IIFE ( void force function to be treated as expression instead of decleration)

// function notIife(){
//   console.log("Excuted")
// }(); // Error because this is function decleration not expression

// void function iife(){
//   console.log("Excuted")
// }();

// [2] void with URL
/* 
When a browser follows a javascript: URI, it evaluates the code in the URI 
and then replaces the contents of the page with the returned value, 
unless the returned value is undefined. The void operator can be used to return undefined. 

<a href="javascript:void(0);">
  Click here to do nothing
</a>

<a href="javascript:void(document.body.style.backgroundColor='green');">
  Click here for green background
</a>
*/

// [3] non Leaking Arrow Function
// when you want arrow function that shouldn't return any Value
// function doSomething(){
//   // return null
//   return true
// }
// let arrowFunc = () => doSomething() || undefined
// console.log(arrowFunc()) // will return undefined only if doSomething() return falsy value 
// let arrowFuncVoid = () => void doSomething()
// console.log(arrowFuncVoid()) // will return undefined regardless doSomething() return falsy value or true value

// [4] with <a> in HTML
// <a href="javascript:void(0)"/>  like preventDefault

// [5] in older Browsers
/* 
undefined is actually a global property - it's not a keyword. 
So, undefined can be changed, where as void is an operator, 
which cannot be overridden in JavaScript and always returns the value undefined.
so it's safer in older Browsers to use void(O) instead of undefined
*/
// console.log(undefined); // undefined
// var undefined = 1;
// console.log(undefined); // 1

// [6] void evaluate expression and this is function decleration
// void function test(){
//   console.log("test is definedddd")
// }
// test(); // Error Test is not defined
// console.log(void function test(){
//   console.log("test is defined")
// }) // undefined

// and do not forget to use ( when evaluate expression like this exp.)
// console.log(void 2 === "2") // false because void 2 = undefined so here like undefined === "2"
// console.log(void (2 === "2")) // undefined

// -----------------------Private Variable--------------------------

// let obj1 = {
//   _prop1 : "Mohamed",
//   prop2 : "Soliman",
//   get prop1() {
//     return this._prop1
//   },
//   set prop1(_val){
//     this._prop1 = _val
//   }
// }
// console.log(obj1._prop1) // Mohamed
// console.log(obj1.prop1) // Mohamed
// Object.defineProperty(obj1, "_prop1" , {
//   writable : false
// } ) //here we can stop changing value of _prop1 by writable : false
// obj1._prop1 = "Ahmed" // here we are changing the old property _prop1 if writable : true
// console.log(obj1._prop1) // Ahmed
// for (let p in obj1){
//   console.log(obj1[p])
// } // Ahmed - Soliman - Ahmed (if writable : true)
// console.log("#############")

// let obj2 = (function(){
//   _prop1 = "Mohamed"
//   return {
//     prop2 : "Soliman",
//     get prop1() {
//       return _prop1
//     },
//     set prop1(_val){
//       _prop1 = _val
//     }
//   }
// })()

// console.log(obj2._prop1) // undefined
// console.log(obj2.prop1) // Mohamed
// Object.defineProperty(obj2, "_prop1" , {
//   value : "from defineProperty",
//   // writable : false,
//   enumerable : true
// } ) // here we are creating a new Property
// obj2._prop1 = "Ahmed" // here we are creating a new property called _prop1
// console.log(obj2._prop1) // Ahmed
// for (let p in obj2){
//   console.log(obj2[p])
// } // soliman - Mohamed - Ahmed

// -----------------in Operator-----------------
// in operator used to check if a property exist in object or index in array
// even if property's enumerable : false in operator will catch it also
// let obj1 = {
//   prop1 : 1,
//   prop2 : 2,
//   prop3: undefined,
//   prop4 : null
// }
// delete obj1.prop2
// if("prop1" in obj1){
//   console.log("Prop1 Exist")
// }else{
//   console.log("Prop1 not Exist")
// }
// if("prop2" in obj1){
//   console.log("Prop2 Exist")
// }else{
//   console.log("Prop2 not Exist")
// }
// if("prop3" in obj1){
//   console.log("Prop3 Exist")
// }else{
//   console.log("Prop3 not Exist")
// }
// if("prop4" in obj1){
//   console.log("Prop4 Exist")
// }else{
//   console.log("Prop4 not Exist")
// }
// // here we are creating new property inside obj2 not overriding prop4 from prototype chain because Object.create() only link created object to prototype of old object
// let obj2 = Object.create(obj1, {prop4 : {value : 5}})
// console.log(obj1.prop4)
// console.log(obj2.prop4)
// // here we are creating new property inside obj2 and descriptors default values all false 
// let obj2 = Object.create(obj1, {prop5 : {value : 5}}) 
// console.log(obj2.__proto__)
// if("prop1" in obj2){
//   console.log("Prop1 Exist from Prototype Chain")
// }else{
//   console.log("Prop1 not Exist")
// }
// if("prop2" in obj2){
//   console.log("Prop2 Exist from Prototype Chain")
// }else{
//   console.log("Prop2 not Exist")
// }
// if("prop3" in obj2){
//   console.log("Prop3 Exist from Prototype Chain")
// }else{
//   console.log("Prop3 not Exist")
// }
// if("prop4" in obj2){
//   console.log("Prop4 Exist from Prototype Chain")
// }else{
//   console.log("Prop4 not Exist")
// }
// if("prop4" in obj2){
//   console.log("Prop5 Exist")
// }else{
//   console.log("Prop5 not Exist")
// }

// let arr = ["a","b","c"]
// if( 0 in arr){
//   console.log("Array has index no 0")
// } else{
//   console.log("Array has no index no 0")
// }
// if( 1 in arr){
//   console.log("Array has index no 1")
// } else{
//   console.log("Array has no index no 1")
// }
// if( 2 in arr){
//   console.log("Array has index no 2")
// } else{
//   console.log("Array has no index no 2")
// }
// if( 3 in arr){
//   console.log("Array has index no 3")
// } else{
//   console.log("Array has no index no 3")
// }

// even if property's enumerable : false in operator will catch it also
// let obj3 = Object.create({},{prop :{value : 1}})
// for (let p in obj3){
//   console.log(p)
// } //nothing
// console.log("prop" in obj3) // true

// ---------------casting---------------
// let str = "12";
// // using unary plus operator to cast string to number
// let num = +str
// // using double bang !! to cast number or string to boolean 
// // (one !) will cast to boolean but will convert true to false and vice versus
// let boolStr = !!str
// let boolNum = !!num
// let convertedBoolNum = !num
// console.log(boolStr) //true
// console.log(boolNum) //true
// console.log(convertedBoolNum) //false

// -----------combine namespaces and IIFE and Private Variable or functions------------

// let nameSpace = {
//   fName : "Mohamed",
//   lName : "Hussein",
//   fullName : function(){
//     console.log(`Full Name is : ${this.fName} ${this.lName}`)
//   },
//   lastName : function(){
//     console.log(`Last Name Is ${this.lName}`)
//   }
// }
// nameSpace.fullName()
// nameSpace.lastName()

// let nameSpacePrivate = (function(){
//   let privateVar = "Hidden Variable"
//   let privateFunc = function(){
//     console.log("Private Function is Running")
//   }
//   return {
//     fName : "Mohamed",
//     lName : "Hussein",
//     pv : privateVar,
//     pf : privateFunc 
//   }
// })();
// console.log(nameSpacePrivate.pv)
// nameSpacePrivate.pf()
// console.log(nameSpacePrivate.privateVar) // undefined
// nameSpacePrivate.privateFunc() // Error

//--------------------------Inheritance vs Composition----------------------

// Inheritance vs Composition

//INHERITANCE
//  Character > Human > Sam
//  Character > Robot > x73
//  Character > Cyborg > Dolph

// const Character = {
//   talk: function(...msg){ 
//       console.log( msg.join(' ') ) 
//   }
// }

// const Human = Object.create(Character, {
//   speed: {value:3},
//   name: {value:'Hector'}
// });
// Human.walk= function(){ 
//   this.talk(this.name, 'walking') 
// };
// Human.eat= function(){ 
//   this.talk(this.name, 'eating') 
// };

// const Robot = Object.create(Character, {
//   speed: {value:8},
//   id: {value:'THX1138'}
// });
// Robot.drive= function (){ 
//   this.talk(this.id, '\u26A1', 'driving')
// };
// Robot.wifi= function (){ 
//   this.talk(this.id, '\u26A1', 'connecting')
// };

// const sam = Object.create(Human, {name:{value: 'Samuel'}});
// sam.walk();
// sam.talk('Hello from Samuel.');
// console.log(sam.__proto__) // prototype Chain sam > Human > character

// const x73 = Object.create(Robot, {id:{value: 'x73'}});
// x73.drive();
// x73.wifi();
// // ????What about a Cybernetically enhanced human with wifi?



// //COMPOSITION
// const talker = (state)=>({ 
//   talk: (...msg)=> console.log( msg.join(' '))
// });
// const walker = (state) => ({
//   walk: ()=> {
//       let nm = state.name || state.id;
//       console.log(nm, 'walking');
//   }
// });
// const eater = (state) => ({
//   eat: ()=> {
//       let nm = state.name || state.id;
//       console.log(nm, 'eating');
//   }
// });
// const driver = (state) => ({
//   drive: ()=>{
//       let nm = state.name || state.id;
//       console.log(nm, '\u26A1', 'driving');
//   }
// });
// const wifier = (state) => ({
//   wifi: ()=>{
//       let nm = state.name || state.id;
//       console.log(nm, '\u26A1', 'connecting');
//   }
// });

// const Person = (name, speed=3) => {
//   let state = {
//       name,
//       speed
//   }
//   return Object.assign({}, 
//     talker(state), 
//     walker(state),
//     eater(state));
// };
// let Bob = Person('Bob');
// Bob.talk('Hello from Bob.');
// Bob.eat();
// Bob.walk();
// console.log(Bob.__proto__) // no prototype chain 

// const Android = (id, speed=6) => {
//   let state = {
//       id,
//       speed
//   }
//   return Object.assign({}, 
//     talker(state), 
//     driver(state), 
//     wifier(state));
// };
// let k45 = Android('k45');
// k45.drive();
// k45.wifi();

// const Cyborg = (name, speed) => {
//   let state = {
//       name,
//       speed
//   };
//   return Object.assign({},
//     talker(state),
//     walker(state),
//     wifier(state));
// };
// let Dolph = Cyborg('Dolph', 9);
// Dolph.walk();
// Dolph.wifi();

// -------------Object.assign vs Object.create---------------

/* 
Object.create creates a new object with the specified [[Prototype]], 
and Object.assign assigns the properties directly on the specified object:
Object.create accept two arguments : Object.create(proto, properies(like Object.defineProperities()))

* The Object.create() method creates a new object, using an existing object 
as the prototype of the newly created object.
* The Object.assign() method copies all enumerable own properties from one or more source 
objects to a target object. It returns the modified target object.


Object.assign() provides shallow copying (Only properties and methods) 
but should use {} as 1st argument if you use object (target2 ) you are chaning same object (target2) not creating new object
and it will override the method and property 
(in case of same name property from source object will override property inside target object 
because steps of Object.assign is creating target object the copy from the source Object)
while Object.create() only link to prototype chain (also shallow copy).
Object.assign(target Object , source Object)

let target1 = {name : "Soliman"}, target2 = {name : "hussein"};
let obj1 = Object.create(target1, {age : {value : 33}});
let obj2 = Object.assign(target2, {age : 33});
console.log(obj1) // {age : 33 }
console.log(target1) // {name : "Soliman"}
console.log(obj1.__proto__) // target1 = {name : "Soliman"}
console.log(obj1.name) // soliman
console.log(obj1.age) // 33
console.log(obj1 === target1)
console.log(obj2) // {name: 'hussein', age: 33}
console.log(obj2 === target2) 


* 2nd param in Object.create is define property for this new created object
* 2nd and 3rd and ... param in Object.assign are one or more source objects to a target object

let obj = {
  fName : "Mohamed",
  lName : "Hussein"
}
let obj1 = Object.create(obj,{mName:{value : "Ahmed"}})
console.log(obj1)
console.log(obj1.fName)
console.log(obj1.lName)
console.log(obj1.mName)

let obj2 = Object.assign({},obj,{mName2:"Soliman"})
console.log(obj2)
console.log(obj2.fName)
console.log(obj2.lName)
console.log(obj2.mName2)

* Object.assign provide shallow copy Object.create provide new Object
  - Object.assign({},obj) shallow copy of obj
  - Object.create(obj) new empty object and it's __protot__ is obj
*/

// let target1 = {
//   tProp1 : "T1"
// }
// let target2 = {
//   tProp2 : "T2"
// }
// let obj1 = {
//   oProp1 : "O1"
// }
// let obj2 = {
//   oProp2 : "O2"
// }
// // Object.create define Property => all descriptors false && creating new property in finalObj1 not overriding obj1
// let finalObj1 = Object.create(obj1 , {oProp1 : {value : "F1"}})
// // Object.assign only assign => all descriptors true && overriding oProp2 in obj2
// let finalObj2 = Object.assign(obj2, {oProp2 : "F2"})
// console.log(finalObj1.oProp1) // F1
// console.log(finalObj2.oProp2) // F2
// finalObj1.oProp1 = "OF1"
// finalObj2.oProp2 = "OF2"
// console.log(finalObj1.oProp1) // F1 because all descriptors false
// console.log(finalObj2.oProp2) // OF2 because all descriptors true
// console.log(obj1.oProp1) // O1 because we used Object.create we will not override
// console.log(obj2.oProp2) // OF2 because we used Object.assgin we override the oProp2 in obj2



// -------------Object.create(null)--------------
/* 
Creating objects by using {} will create an object whose prototype is Object.
prototype which inherits the basic functions from Object prototype while creating objects 
by using Object.create(null) will create an empty object whose prototype is null.
*/
// let obj1 = Object.create(null)
// let obj2 = {}
// console.log(obj1.__proto__) // undefined 
// console.log(obj2.__proto__) // object prototype

// ---------Date.now() vs valueOf()---------------
// Miliseconds since 1 jan 1970

// let timeStamp1 = Date.now() //class Method or static Method
// let timeStamp2 = new Date() 
// console.log(timeStamp1)
// console.log(timeStamp2.valueOf()) // instance Method


// ----------------toSrting()-------------------------
/* The toString() method returns a string representing the object. [Object Type] 
By default, the toSrting() method is inherited by every object descended from Object. 
Every built-in core object overrides this method. 
For an array, that would return all of the array values joined with a comma, 
*/

// let obj = {fname : "Soliman"}
// let arr = [1,2,3,4]
// let num = 12;
// let date = new Date()
// console.log(obj.toString()) // toString Method from Object prototype
// console.log(arr.toString()) // toString Method from constructor Array (will override toString Method from Object prototype)
// console.log(num.toString())//  toString Method from constructor Number (will override toString Method from Object prototype)
// console.log(date.toString()) // toString Method from constructor Date (will override toString Method from Object prototype)
// console.log(Object.prototype.toString.call(obj))
// console.log(Object.prototype.toString.call(arr))
// console.log(Object.prototype.toString.call(num))
// console.log(Object.prototype.toString.call(date))


// --toString() with classes--
// class Person {
//   constructor(fName, lName){
//     this.fName = fName
//     this.lName = lName
//   }
//   // here we overriding toString() Method
//   toString(){
//     return `${this.fName} ${this.lName}`
//   }
// }
// class PersonAndAge extends Person{
//   constructor(fName,lName,age){
//     super(fName, lName)
//     this.age = age
//   }
//   // here we overriding toString() Method
//   toString(){
//     return `${this.fName} ${this.lName} ${this.age}`
//   }
// }
// let me = new Person("Mohamed" , "Hussein")
// let meAndAge = new PersonAndAge("Mohamed" , "Hussein", 33)
// // when string + object =>  under the hood JS will automaticall call toString() method me.toString()
// // without overriding toString() inside class the output will be My FullName is : [Object Object]
// console.log("My FullName is : " + me)
// console.log("My FullName and Age is : " + meAndAge)

// ----------------toString() vs String()-------------
/* 
toString() is a method of Object so will not work on null or undefined 
because they are dont support properties

String() is constructor and you can pass any argument to convert it to string 
(under the hood take that argument and use toString() on it => let x = new String(null))

The String constructor is used to create a new String object. 
When called instead as a function, it performs type conversion to a primitive string, 
which is usually more useful.
*/

// console.log(Object.prototype.toString())
// undefined.toString() // error
// null.toString() // error

// console.log(String.prototype)
// console.log(Number.prototype)

// console.log(String(null)) // null 
// console.log(String(undefined)) // undefined


// ---------------valueOf-------------------
/* 
JavaScript calls the valueOf method to convert an object to a primitive value. 
You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it 
when encountering an object where a primitive value is expected.
By default, the valueOf method is inherited by every object descended from Object. 
Every built-in core object overrides this method to return an appropriate value. 
If an object has no primitive value, valueOf returns the object itself.
*/

// when using literal JS under the hood create instance object (called auto-boxing) and automatically use method valuOf() on it 
// let strPrim = "Mohamed"
// // Under the Hood
// let strObj = new String("Mohamed")
// let strObjPrim = strObj.valueOf()
// console.log(typeof strPrim) // string
// console.log(typeof strObj) // object
// console.log(typeof strObjPrim) // string

// class Product {
//   constructor(name , cost){
//     this.name = name
//     this.cost = cost
//   }
//   // here are overriding valueOf() method
//   valueOf(){
//     return this.cost
//   }
// }
// let p1 = new Product("Samsung", 500)
// let p2 = new Product("Apple" , 1000)
// // without overriding valueOf() will return [object object][object object] 
// // because befault behavior of valueOf is returns the object itself If an object has no primitive value  
// console.log( p1 + p2) 

// ----------------------- toString() vs valueOf()-----------------
/*
var x = {
    toString: function () { return "foo"; },
    valueOf: function () { return 42; }
};

alert(x); // foo
"x=" + x; // "x=42"
x + "=x"; // "42=x"
x + "1"; // 421
x + 1; // 43
["x=", x].join(""); // "x=foo"

The toString function is not "trumped" by valueOf in general. 
The ECMAScript standard actually answers this question pretty well. Every object has a 
[[DefaultValue]] property, which is computed on-demand. When asking for this property, 
the interpreter also provides a "hint" for what sort of value it expects. If the hint is 
String, then toString is used before valueOf. But, if the hint is Number, then valueOf will
be used first. Note that if only one is present, or it returns a non-primitive, it will usually call the other as the second choice.
The + operator always provides the hint Number, even if the first operand is a string value. 
Even though it asks x for its Number representation, since the first operand returns a string from [[DefaultValue]], it does string concatenation.
If you want to guarantee that toString is called for string concatenation, use an array and 
the .join("") method.

*/

// ------------------convert Binary Number , decimal and HexDecimal--------------
/*
[1] Using toString(10) : Convert Binary or HexDecimal Number to Decimal Number 
[2] Using toString(2) : Convert Decimal or HexDecimal Number to Binary Number
[3] Using praseInt(binary, radix) : Convert binary to Decimal


Binary : Js don't know if this is a binanry or decimal number so if you need to tell 
js it's a binary number you should write 0b like let b = 0b1010 
Decimal : Js knows its Decimal no need to write something before
HexDecimal : Js don't know if this is a HexDecimal you should write 0x 
 */
// let a = 10; 
// let b = 0b1010;
// let c = 1010;
// let x = 0xFF3300
// let d = 16724736

// console.log(a.toString(2)) // convert Decimal to Binary
// console.log(b) // will print 10 because we tell JS it's Binary by writing 0b before
// console.log(c.toString(10)) // 1010 because we did not tell JS it's Binary
// console.log(b.toString(10)) // 10 toString() will work now because we told JS it's Binary
// console.log(parseInt(c,2)) // no need here to tell JS it's Binary because we wrote here the radix as 2nd parameter
// console.log(x.toString(2)) // convert HexDecimal to Binary
// console.log(d.toString(16)) // convert decimal to HexDecimal
// console.log(x.toString(10)) // convert HexDecimal to Decimal

// --------------BitWise Operator and Binary Numbers------------
// video 
// https://youtu.be/RRyxCmLX_ag
/* 
// bitwise.js
// JavaScript Bitwise operators
// AND &
// OR  |
// XOR ^
// NOT ~
// Shift Left <<
// Shift Right >>
// let log = console.log;
// let n = 10;     //1010
// let i = 6;      // 110
// log( n.toString(2), i.toString(2) );
// 1010
//  110
// 0010  2
log("AND &",  (n & i) )
let temp = 2;
log( temp.toString(2) )

//  1010
//   110
//  1110
log("OR | ",  (n | i) );

// 1010
//  110
// 1100  12 XOR
log('XOR ^', (n^i) );

// ~ 1010
//   0101
//  x  = -(x+1)  
log('NOT ~', (~n) );  -11

//PERMISSIONS
// read, write, delete
let perm = 6;

let allowedToRead = (perm & 4)?true:false;
let allowedToWrite = (perm & 2)?true:false;
let allowedToDelete = (perm & 1)?true:false;
//  0110  6
//  0100  AND 4
//  0100  4

//  0010  6
//  0100  AND 4
//  0000  0

for(var c=0; c<50; c++){
    if(c&1){
        //log('Odd');
    }else{
        //log('\t\tEven');
    }
}

//101010 >> 4  = 10
//  111  >> 1  = 3
log( 7 >> 1 );

//  111 << 1 = 1110   (14)
//  1000 << 1 = 10000  (16)
log( 7 << 1);
log( 8 << 1);

//  FF3300  - 24bit values  8bits Red, 8bits Green, 8 bits Blue
// GREEN  - Shift 8 >>, AND 11111111  (255)
//  111111110011001100000000  >> 8 = 1111111100110011
//  1111111100110011
//  0000000011111111
//          00110011

var color = 0xFF3300;
var noBlue = color >> 8;
var green = noBlue & 255;
log('GREEN', green, green.toString(16))
*/
/**************************
counting in decimal, binary
 0      0       
 1      1       2^0
 2     10       2^1
 3     11
 4    100       2^2
 5    101
 6    110
 7    111
 8   1000       2^3
 9   1001
10   1010
11   1011
12   1100
13   1101
14   1110
15   1111
16  10000       2^4
**************************/

// ----how ~ "NOT" Bitwise Operator works 
/*
JavaScript stores numbers as 64 bits floating point numbers, 
but all bitwise operations are performed on 32 bits binary numbers.
Before a bitwise operation is performed, JavaScript converts numbers to 32 bits signed 
integers. (A signed integer uses the leftmost bit as the minus sign.)
After the bitwise operation is performed, the result is converted back to 64 bits 
JavaScript numbers.

Number.toString(2) has some problems when representing negative numbers. 
For example, (-1).toString(2) output is "-1".
To fix this issue, you can use the unsigned right shift bitwise operator (>>>) to 
coerce your number to an unsigned integer.
If you run (-1 >>> 0).toString(2) you will shift your number 0 bits to the right, 
which doesn't change the number itself but it will be represented as an unsigned integer

Javascript represents negative binary integers in two's-complement notation
*/
// let a = 5;
// let b = ~5;
// let x = 0b11111111111111111111111111111010
// let y = -6;

// console.log(a) // 5
// console.log(b) // -6
// console.log(x.toString(2)) // 11111111111111111111111111111010
// console.log((y >>> 0).toString(2)) // 11111111111111111111111111111010


//————————colors with Bitwise operators
/* Color (8 bits red , 8 bits green , 8 bits blue ) 

FF3300
FF(Red) - 33(Green) - 00(blue) (111111110011001100000000)

[1] To get green part : FF3300 >> 8 & 255 : 

(a) FF3300 >> 8 : will shift to right and remove 8 bits of blue (1111111100110011)

(b) & 11111111(255) : will remove Remove Red part
1111111100110011 & 
0000000011111111
=              00110011 (Green part ) 

[2] To get blue part : FF3300 & 255

111111110011001100000000 & 
000000000000000011111111
= 00000000 (blue part) 

[3] To get Red Part : FF3300 >> 16

: will shift to right and remove 16 bits 8 bits blue and 8 bits green (11111111) */

// ------Avoiding Array Dubplicate values in loop--------

// give you duplicate of random values
// let arr = [1,2,3,4]
// for(let i =0; i < arr.length; i++){
//   let rnd = Math.floor(Math.random() * arr.length)
//   console.log(arr[rnd])
// }

/* 
to solve the problem of duplicate : 
[1] give for loop static no. of loops by creating variable len and assign to it a primitive value(immutable)
[2] use Splice() beacuse each loop arr.length will decrease and random method will give you smaller no. each loop
*/

// no Duplicate but will change the original Array
// let arr = [1,2,3,4]
// for(let i =0 ,len = arr.length; i < len; i++){
//   let rnd = Math.floor(Math.random() * arr.length)
//   console.log(arr[rnd])
//   arr.splice(rnd, 1)
// }
// console.log(arr) // []

// no Duplicate and no change the original Array
// let arr = [1,2,3,4]
// for(var i =0 ,arr2 = Array.from(arr) ,len = arr.length; i < len; i++){
//   let rnd = Math.floor(Math.random() * arr2.length)
//   console.log(arr2[rnd])
//   arr2.splice(rnd, 1)
// }
// console.log(arr) //[1,2,3,4]

// let nums = [10,11,12,13,14,15]
// let min = 16;
// let max = 20;
// let range = max - min

// Duplicate
// while(nums.length < 10){
//   let rnd = Math.floor(Math.random() * range) + min
//   nums.push(rnd)
//   console.log(nums.sort())
// }

// no Duplicate
// while(nums.length < 10){
//   let rnd = Math.floor(Math.random() * range) + min
//   if(!nums.includes(rnd)){
//     nums.push(rnd)
//     console.log(nums.sort())
//   }
// }


// ------------JSON (JavaScript Object Notation)-----------
/*
difference between normal Object and JSON object:
Json file is just a text file you can store object or array inside it 
key in object must be inside "" and 
value (inside object or array) can be only (string,number,object,array,true,false.null) 
reference this link => https://www.json.org/json-en.html


JSON VS XML 
- Text Based Format            - Markup Language (like HTML)
- Lightweight                  - Heavier
- Does Not Use Tags            - Using Tags
- Shorter                      - Not Short
- Can Use Arrays               - Cannot use Arrays
- Not Supprot Comments         - Support Comments
*/

// let obj = {
//   fName : "Mohamed",
//   lName : "Hussein",
//   age : 33
// }
// let jsonStrObj = JSON.stringify(obj)
// let jsonParseObj = JSON.parse(jsonStrObj)
// console.log(jsonStrObj)
// console.log(jsonParseObj)

// // you can add array as 2nd parameter to JSON.stringify to filter only specific properties
// let jsonStrObjFilter = JSON.stringify(obj, ["lName", "age"])
// console.log(jsonStrObjFilter)

// // you can add function as 2nd parameter 
// let jsonStrObjFunc = JSON.stringify(obj , function(key,value){
//   if(typeof value === "string"){
//     // return "STRING"
//     // if you return undefined will not print the whole property
//     return undefined
//   }else{
//     return value
//   }
// })
// console.log(jsonStrObjFunc)

// // you can add no. of spaces as 3rd parameters
// // let jsonStrObjSpaces = JSON.stringify(obj, null , 4)
// let jsonStrObjSpaces = JSON.stringify(obj, null , "\t") // you can use tab also
// console.log(jsonStrObjSpaces)

// -----------Object literal notation vs JSON(JavaScript Object Notation)
 //JSON has the following syntactical constraints:
/*
 * Object keys must be strings (enclosed in double quotes " ") and can not be computed (ES6).
 * Property can not be shorthanded
 * The values can be either:
     * a string
     * a number
     * an (JSON) object
     * an array
     * true
     * false
     * null
     * *** function not allowed
 * Duplicate keys ({"foo":"bar","foo":"baz"}) produce undefined

In JavaScript, object literals can have
 * Property can be shorthanded
 * String literals, number literals or identifier names as keys (since ES6, keys can now also be computed).
 * The values can be any valid JavaScript expression, including function definitions and undefined.
 * Duplicate keys produce defined, 
    specified results (in loose mode, the latter definition replaces the former; in strict mode, it's an error then allowed after ES6). 
 * Poperty can be accessed by dot notaion or bracket notaion obj.prop or obj["prop"]
 */


// -----------PlaceHolder for images AJAX-----------
// check the video
// https://youtu.be/uXTJnIUlVAA
// let fetch = require('node-fetch') // on command line 
// let url = "https://picsum.photos/list"

// fetch(url)
//   .then(response => response.json())
//   .then(data => {
//     console.log(data.length)
//     console.og(data[0])
//   })
//   .catch(err => {
//     console.log(JSON.stringify(err, null , 2))
//   })

// ----------Randomizing in JS-----------
/* 
if you want end of range included use (range+1)
Math.floor(Math.random() * (range+1)) + minimum

if you want end of range not included (range)
Math.floor(Math.random() * (range)) + minimum

Math.random() give you random number from 0 to 0.99999999
*/

// let people = ["John","Robert","Paul","Jimmy"]

// // number between 1 and 3
// let num = Math.floor(Math.random() * (2+1)) + 1
// console.log(num)

// // Number between 500 and 1000
// let num2 = Math.floor(Math.random() * 500) + 500
// console.log(num2)

// // random person
// let min = 0;
// let max = people.length-1
// let person = people[Math.floor(Math.random() * (max-min + 1) )] 
// console.log(person)


// ---------------json() vs JSON.parse()-------------

/* 
AJAX' works with 'callbacks'; 'fetch' works with 'promises'.
Use JSON.parse() to parse the response for AJAX (response from AJAX is already read to read). 
Use json() to parse the response for fetch (response from fetch need asynchronous function json() to read ).

Body.json() is asynchronous and returns a Promise object that resolves to a JavaScript object. 
JSON.parse() is synchronous can parse a string and change the resulting returned JavaScript object.
*/
// let url = "https://jsonplaceholder.typicode.com/users"; 
// fetch(url)
//   .then(response => response.json())
//   .then(data => console.log(data))


// let xhr = new XMLHttpRequest();       
// xhr.open("GET", url, true); // true is default and means Async - false means Sync       
// xhr.onreadystatechange = function(ev) {                
//   if(xhr.readyState === 4 && xhr.status === 200){
//     console.log(JSON.parse(xhr.responseText))
//   }        
// }      
// xhr.send()

// ----adding static and prototype Methods to built-in Array Object
// Array.staticMethod = (arr) => arr.splice(-1)
// Array.prototype.protoMethod =function () { return this.splice(0,1) } // we can not use arrow function because this will refer to window object
// Array.prototype.protoMethodLength = function(){return this.length}
// let arr1 = [1,2,3,4]
// Array.staticMethod(arr1)
// arr1.protoMethod()
// // this here refer to arr1 because arr1 inherit protoMethodLength from prototype chain and 
// // act as it's a method inside arr1 Object and this will refer to this arr object
// // conclusion this will refer to anything before .protoMethodLength()
// console.log(arr1.protoMethodLength())
// console.log(arr1)
// console.log(Array.prototype)


// ---------------Searching inside Array--------------

// let arr = ["Mohamed","Ahmed","Soliman","Hussein"]

// [1] includes
// includes accept 2nd argument (start index)
// console.log(arr.includes("Mohamed",0)) // true
// console.log(arr.includes("Mohamed",1)) // false

// [2] indexOf
// indexOf accept 2nd argument (start index)
// console.log(arr.indexOf("Soliman",3)) // -1
// console.log(arr.indexOf("Soliman",0)) // 2

// [3] some
/* 
default behavior of some is return true or false 
return true will stop the loop and assign true to variable result
if the loop finished and not returning true will assign false to variable result 
even if return false not exist will retrun false also because undefined also a falsy value

for exp. if we use here map instead of some will return array of [false,false,true,false]
*/
// let result = arr.some((name)=>{
//   if(name === "Soliman"){
//     return "true" 
//   }else{
//     return false 
//   }
// })
// let result = arr.some((name)=> name === "Soliman")
// console.log(result)

// [4]
/* 
Default behavior of find return found value or if not found return undefined
*/
// let result2 = arr.find((name)=> name === "Soliman")
// console.log(result2)

// ---------reduce can also return array or object not only return single value------
// let objKeys = ["a" , "b" , "c"]
// let objValues = [1 , 2 , 3]

// // For ...loop Version
// function myFunction(objKeys, objValues) {
//   let obj = {};
//   for( let i = 0; i < objKeys.length; i++){
//     obj[objKeys[i]] = objValues[i]
//   }
//   return obj
// }
// // reduce Version
// function myFunction2(objKeys, objValues) {
//   return objKeys.reduce((acc, cur, i) => ({ ...acc, [cur]: objValues[i] }), {});
// }
// console.log(myFunction(objKeys,objValues))
// console.log(myFunction2(objKeys,objValues))


// ------------how to search on string and replace------------------

// let lorem = `Lorem ipsum dolor sit amet consectetur adipisicing elit. 
// At, deserunt dolorem. Veritatis rerum iusto quidem saepe mollitia doloremque velit ullam, 
// et aperiam nemo placeat ea perferendis dicta repudiandae provident ratione!`

// let find =" "
// let replace = ""
// while(lorem.indexOf(" ") > -1){
//   lorem = lorem.replace(find,replace)
// }
// or you can use replaceAll
// to check if replaceAll supported in browser
// if("replaceAll" in String.prototype){
//   lorem = lorem.replaceAll(find,replace)
// }else{
//   // using regular Expression
//   let reg = new RegExp(" ","g")
//   lorem = lorem.replace(reg,"-")
// }
// console.log(lorem)

// note : if replaceAll not supported in browser you can add it to String.ProtoType manually
// String.prototype.replaceAll = function(find,replace){
//   let reg = new RegExp(find,"g")
//   return this.replace(reg,replace)
// }
// lorem = lorem.replaceAll(" ", "-")
// console.log(lorem)

// ---------------Trimming and Padding---------------
/* 
* trim remove all spaces between string left and right
* trimLeft remove spaces from left side
* trimRight remove spaces from right side

* padStart(minLength, "added pad") in added pad you can add space by " " or text "x" 
and the added pad will repeat till reach min length
* padEnd (minLength, "added pad") in added pad you can add space by " " or text "x" 
and the added pad will repeat till reach min length
default added pad is space if you didnt write anything
*/
// let name = "Soliman"
// let nameWithSpaces = "      Soliman     "

// console.log("!",nameWithSpaces.trim(),"!")
// console.log("!",nameWithSpaces.trimLeft(),"!")
// console.log("!",nameWithSpaces.trimRight(),"!")
// console.log("!",name.padStart(15,"x"),"!")
// console.log("!",name.padEnd(15,"x"),"!")

// some use cases for padding : 

// [1] id with constant length 
// let id = 123456
// console.log(id.toString().padStart(9,"0"))

// [2] fixed length file format
// let userId = 123456
// let userName = "Soliman"
// let userEmail = "@email"
// let file = userId.toString().padStart(9,"0") + "\n"+ userName.padStart(9,">") + "\n"+userEmail.padStart(9,"#")
// console.log(file)

// -------------Number Formatting-------------
/* 
The Math.round() function returns the value of a number rounded to the nearest integer.

The Math.floor() function returns the largest integer less than or equal to a given number.

The Math.ceil() function always rounds a number up to the next largest integer.

The toFixed() method formats a number using fixed-point notation.(return string)

The toPrecision() method returns a string representing the Number object to the specified precision.

The parseInt() function parses a string argument and returns an integer of the specified radix (the base in mathematical numeral systems).

The parseFloat() function parses an argument (converting it to a string first if needed) and returns a floating point number.

The toExponential() method returns a string representing the Number object in exponential notation.
*/
// let num = 111.547
// let dec = 0.000167
// let str = "111.467 this is a string"

// // round if number after . below 5 will be 111 if above 5 or 5 will be 112
// console.log(Math.round(num)) // 112 
// // Ceil will always give you the biggest number no matter number after . below or above 5
// console.log(Math.ceil(num)) // 112 
// // Ceil will always give you the smallest number no matter number after . below or above 5
// console.log(Math.floor(num)) // 111
// // toFixed will give you one number after . (depending on argument passed to toFixed())
// // and it will use round that's why return 111.5 not 111.6
// console.log(num.toFixed(1)) // 111.5 as string
// // toPrecision will give you two number after .000 (depending on argument passed to toFixed())
// // and it will use round that's why return  0.00017 not 0.00016
// console.log(dec.toPrecision(2)) // 0.00017 as string
// // toExponential return string in Exponential notation 
// // and it will use round that's why return 111.5e+2 not 111.6e+2
// console.log(num.toExponential(3)) // as string

// console.log(parseInt(str)) // 111 integer
// console.log(parseFloat(str)) // 111.467 float
// console.log(parseFloat(str).toFixed(2)) // 111.47 as string

// ------------------Object initializer--------------

//------------- New Notations in ES6
// // Short-hand property Name (ES6)
// let a =1 ,
//     b =2 ,
//     c =3 ;

// let obj1 = {a,b,c}
// console.log(obj1)

// // do not confuse between destructring and Short-hand property Name
// let {a : d, b : e, c : f} = obj1;
// console.log(d,e,f)

// // Short-hand Method Name (ES6)
// // no need of function word (instead of method2 : function(){console.log("Method from obj2")})
// let obj2 = {
//   method2(){
//     console.log("Method from obj2")
//   }
// }
// obj2.method2()

// // Computed property names (ES6)
// let prop = "foo"

// let obj3 = {
//   [prop] : "prop3",
//   ["b" + "ar"] : "prop4"
// }
// console.log(obj3[prop])
// console.log(obj3["bar"])


// -----------Spread operator vs Object.assign()
/* 
like Object.assign() take shallow copy but Object.assign() triggers setters, whereas the spread operator doesn't!
*/
// let mainObj ={
//   key : "Value"
// }
// let obj = {
//   a : 1,
//   b : 2,
//   c : 3,
//   // prototype mutaion
//   __proto__ : mainObj
// }
// console.log(obj.__proto__)
// console.log(obj.key)

// let spreadObj = {...obj}
// let assignObj = Object.assign({},obj)
// let createObj = Object.create(obj)
// console.log(obj)
// console.log(spreadObj)
// console.log(assignObj)
// console.log(createObj)

/* 
spread defines new properties, whereas Object.assign() sets them. 
For example, Object.assign() calls setters that are defined on Object.prototype, 
whereas the spread operator does not.
*/

// Object.defineProperty(Object.prototype, 'myProp', {
//   set: () => console.log('Setter called')
// });
// const obj = { myProp: 42 };
// let assignObj = Object.assign({}, obj); // Prints "Setter called"
// const newObj = {...obj }; // Does **not** print "Setter called"

// ------------ProtoType Mutaion

/* A property definition of the form __proto__: value or "__proto__": value does not create a property with the name __proto__. Instead, if the provided value is an object or null, it changes the [[Prototype]] of the created 
object to that value. (If the value is not an object or null, the object is not changed.) */
// let obj1 = {}
// console.log(Object.getPrototypeOf(obj1) === Object.prototype)

// let obj2 = {__proto__: null}
// console.log(Object.getPrototypeOf(obj2) === null)

// let protoObj = {a : "proto"}
// let obj3 = {__proto__: protoObj}
// console.log(Object.getPrototypeOf(obj3) === protoObj)

// let obj4 = {__proto__: 'not an object or null'}
// console.log(Object.getPrototypeOf(obj4) === Object.prototype)

/* 
----------------------Boxing Wrappers---------------

This happens in two cases in JavaScript:
1. When you pass a primitive value as the this value to .call or .apply (not in strict mode though).
2. When you are trying to access a "property" or a method of a primitive value, e.g. "foo bar".split().

AutoBoxing
Boxing is wrapping a primitive value in an Object. 
When you treat a primitive type like if it were an object, 
e.g., calling to the toLowerCase function, JavaScript would wrap the primitive type 
into the corresponding object. This new object is then linked to the related 
built-in <.prototype>, so you can use prototype methods on primitive types.

Manual Boxing and Gotchas
In general, using the boxed object wrapper directly isn’t usually a good idea 
because there are some gotchas related to him, and you have to be careful 
if you don’t want unexpected results.

const a = new Boolean(true)
if(a) console.log("it's true")// it's true
const b = new Boolean(false)
if(!b) console.log("never runs");// objects are “truthy.“
const c = Object(false)
if(!c) console.log("never runs"); // objects are “truthy.“

The problem here is that you are creating an object wrapper around a false value, 
but objects are “truthy.” So, if you want to box a primitive value manually, be careful.

Unboxing
The easiest way to obtain the underlying primitive value from an object wrapper is to use 
the valueOf() method ( that what happens automatically with string literal => autoBoxing string in object then use valueOf() method on it ) 
*/

// ----------------------getter and setter---------------
/* 
[1] set syntax binds an object property to a function to be called 
when there is an attempt to set that property.


[2] The get syntax binds an object property to a function that will be called 
when that property is looked up.

* you can not give getter or setter same name of existing property of object that have a value
* you can use getter or setter to create Psudo-property
* getter has zero param but setter has one param
*/
// [1] --------setter
// let obj = {
//   _prop1 : 1988,
//   get prop1(){
//     return this._prop1   + " From Getter"
//   },
//   set prop1(val){
//     this._prop1 = val + " From Setter"
//   }
// }
// console.log(obj.prop1) // 1988 " From Getter"
// obj.prop1 = 2000 // invoking setter method
// console.log(obj.prop1) // 2000 from Setter

// we can use setter to create Psudo-property

// let language = {
//   lang : [],
//   set current(val){
//     this.lang.push(val)
//   }
// }
// console.log(language.lang)
// language.current = "EN"
// console.log(language.lang) // ["EN"]
// language.current = "AR"
// console.log(language.lang) // ["EN","AR"]
// // Note that current is not defined, and any attempts to access it will result in undefined.
// console.log(language.current) // undefined
// we can delete setter with delete operator
// delete language.current;

//-----defineSetter-----
/* The __defineSetter__ method binds an object's property to a function to 
be called when an attempt is made to set that property. */
// Object.defineProperty(Object.prototype, 'myProp', {
//   set: () => console.log('Setter called')
// });
// const obj = { Prop: 42 };
// obj.myProp = 1; // will trigger setter method

// [1] Non-standard and deprecated way
// var o = {};
// o.__defineSetter__('value', function(val) { this.anotherValue = val; });
// o.value = 5;
// console.log(o.value); // undefined
// console.log(o.anotherValue); // 5

// [2] Standard-compliant ways
// Using the set operator
// var o = { set value(val) { this.anotherValue = val; } };
// o.value = 5;
// console.log(o.value); // undefined
// console.log(o.anotherValue); // 5

// [3] Using Object.defineProperty
// var o = {};
// Object.defineProperty(o, 'value', {
//   set: function(val) {
//     this.anotherValue = val;
//   }
// });
// o.value = 5;
// console.log(o.value); // undefined
// console.log(o.anotherValue); // 5

//[2] -------getter

// let obj = {
//   prop1 : ["A","B","C"],
//   get last(){
//     return this.prop1[this.prop1.length -1]
//   }
// }
// console.log(obj.last)

// ------difference between getter and defineProperty------
/* 
When using get the property will be defined on the instance's prototype, 
while using Object.defineProperty() the property will be defined on the instance it is applied to.
*/
// let obj = {
//   _prop1 : "Mohamed",
//   _prop2 : "Ahmed",
//   _prop3 : "Soliman",
//   get prop1(){
//     return this._prop1
//   },
//   get prop2(){
//     return this._prop2
//   }
// }
// Object.defineProperty(obj,"prop3",{
//   get: function prop3(){
//     return this._prop3
//   }
// })
// // because getter take zero parameters so we you try to assign value to it will no change anything
// obj.prop1 = "Hussein" // No changes happends
// console.log(obj)
// console.log(obj.prop1)
// console.log(obj.prop2)
// console.log(obj.prop3)
// we can delete getter with delete operator
// delete obj.prop1;



// ----check even Number
// function evenNum(num){
//   return num % 2 === 0 
// }
// console.log(evenNum(4))
// console.log(evenNum(5))


/*  ----------Arguments and Parameters------------
The arguments object is an array-like object that is available within all functions. 
It allows the argument’s values passed to the function to be retrieved by number, 
rather than by name. The object allows us to pass any number of arguments to a function

If a function expects to receive only one argument. 
When we call it with two arguments, the first argument is accessible in the function 
by the parameter name param1 or the arguments object arguments[0], 
but the second argument is accessible only as arguments[1]. 
But if you are using rest parameter you can access parameter [1]

function arg(){
  console.log(arguments)
  console.log(arguments[1])
  console.log(Array.prototype.slice.call(arguments))
  console.log(Array.from(arguments))
}
arg(1,2,3,4)

Parameter and argument are like two different names for the same variable.
the arguments object has an unusual feature: It keeps its values in sync with 
the values of the corresponding named parameters. but in strict mode this not happend

function foo(param) { 
  console.log(param === arguments[0]); // true 
  arguments[0] = 500; 
  console.log(param === arguments[0]); // true 
  return param 
} 
console.log(foo(200)) // 500


function foo2(param) { 
  "use strict"
  console.log(param === arguments[0]); // true 
  arguments[0] = 500; 
  console.log(param === arguments[0]); // false 
  return param 
} 
console.log(foo2(200)) // 200

-----Mandatory Arguments
If an argument is missing in a function call, it will be set to undefined
ES6 we can use default parameters to set mandatory arguments:

function throwError() { 
  throw new Error('Missing parameter'); 
} 
function foo(param1 = throwError(), param2 = throwError()) { 
  return [param1,param2]
} 
foo(10, 20); // ok 
foo(10); // Error: missing parameter
*/

/* ---------Function constructor Vs function declaration----------
Functions created with the Function constructor do not create closures to their 
creation contexts; they always are created in the global scope. When running them, 
they will only be able to access their own local variables and global ones, 
not the ones from the scope in which the Function constructor was created

var x = 10;
function funcObj (){
  var x = 20
  return new Function("return x")
}

function funcConstruc(){
  var x = 20
  return function f(){
    return x
  }
}
let newFunc = funcObj()
console.log(newFunc()) 
let newFunc2 = funcConstruc()
console.log(newFunc2()) 
*/

/*--------------Array like Object------------ 
EXP. 
* Arguments object
* HTML Collection
* NodeList 

one key difference between Arrays and Array-like Objects is that Array-like objects 
inherit from Object.prototype instead of Array.prototype. This means that Array-like 
Objects can't access common Array prototype methods like forEach(), push(), map(), filter(), 
and slice():

to Transfer Array like Object to Array : 

function arrLike(){
  // [1] Array.fom
  // let arr = Array.from(arguments)
  
  // [2] Spread operator
  // let arr = [...arguments]
  
  // [3] for..of loop
  // let arr = [];
  // for(let arg of arguments){
  //   arr.push(arg)
  // }
  
  // [4] Object.values
  // let arr = Object.values(arguments)

  // [5] Object.keys
  // let arr = Object.keys(arguments).map((key)=>arguments[key])

  // [6] Array.prototype.slice
  // let arr = Array.prototype.slice.apply(arguments)

  // [7] Function.prototype.apply.bind
  // let slice = Function.prototype.apply.bind(Array.prototype.slice) // slice now is bound function
  // let arr = slice(arguments)

  // [8] use a function directly to array like object without changing it to array
  // let arr = []
  // Array.prototype.forEach.call(arguments,function(arg){
  //   arr.push(arg)
  // })
  // return arr
}
console.log(arrLike(1,2,3,4))
*/

// ----------------------------Call , Apply and Bind------------------------------

// [1]-----------------------Call()
/* 
The call() allows for a function/method belonging to one object to be assigned 
and called for a different object.

Call (thisArg, arg1,arg2,....) takes arguments separately
*/

// EXP. 1
// The example below calls person1.fullName function with person2 as an argument,
//  this refers to person2, even if fullName is a method of person1:
// call force person1.fullName() to accept person2 (object) as thisArg

// const person1 = {
//   fullName: function() {
//     return this.firstName + " " + this.lastName;
//   }
// }

// const person2 = {
//   firstName:"John",
//   lastName: "Doe",
// }

// console.log(person1.fullName.call(person2))

// EXP. 2
// ---- adding function print to each object inside array animals using Call()
const animals = [
  { species: 'Lion', name: 'King' },
  { species: 'Whale', name: 'Fail' }
];

// for (let i = 0; i < animals.length; i++) {
//   (function(i) {
//     this.print = function() {
//       console.log('#' + i + ' ' + this.species
//                   + ': ' + this.name);
//     }
//     this.print();s
//   }).call(animals[i], i);
// }
// console.log(animals[0])
// console.log(animals[1])

// EXP. 3
// -----Using call() to invoke a function and without specifying the first argument
// In the example below, we invoke the display function without passing the first argument. 
// If the first argument is not passed, the value of this is bound to the global object.

// var sData = 'Wisen';
// function display() {
//   console.log('sData value is %s ', this.sData);
// }
// display.call();  // sData value is Wisen
// note : in strict mode this will not refer to global object -this will undefined

// EXP. 4
// ------Using call() to chain constructors for an object (Like Super in ES6 Class)
// function Product(name, price) {
//   this.name = name;
//   this.price = price;
// }

// function Food(name, price) {
//   Product.call(this, name, price);
//   this.category = 'food';
// }

// function Toy(name, price) {
//   Product.call(this, name, price);
//   this.category = 'toy';
// }

// const cheese = new Food('feta', 5);
// const fun = new Toy('robot', 40);

// [2]----------------------------Apply()
/* 
apply is very similar to call(), except for the type of arguments it supports. 
call() accepts an argument list, while apply() accepts a single array of arguments.
The call(thisArg, arg1,arg1,....) method takes arguments separately.
The apply(thisArg, argArray) method takes arguments as an array or array like object.
*/

// EXP. 1
// const person = {
//     fullName: function(city, country) {
//       return this.firstName + " " + this.lastName + "," + city + "," + country;
//     }
//   }
  
//   const person1 = {
//     firstName:"John",
//     lastName: "Doe"
//   }
//   // apply accept argument as Array
// console.log(person.fullName.apply(person1, ["Oslo", "Norway"]))
//   // call accept argument separatly
// console.log(person.fullName.call(person1, "Oslo", "Norway"))

// EXP. 2
// ------Using Apply() to chain constructors
// // creating global Method
// Function.prototype.construct = function(aArgs) {
//   // oNew object will be the future instance (myInstance) of future constructor (MyConstructor)
//   let oNew = Object.create(this.prototype); // this (MyConstructor)
//   // console.log(oNew instanceof this) // true
//   //  this here will refer to future constructor will user with (MyConstructor)
//   this.apply(oNew, aArgs); // using future constructor (oNew = (myInstance) is thisArg and argArray = myArray)
//   return oNew;
// };
// // future constructor
// function MyConstructor() {
//   for (let nProp = 0; nProp < arguments.length; nProp++) {
//     this['property' + nProp] = arguments[nProp];
//   }
// }
// // array of arguments
// let myArray = [4, 'Hello world!', false];
// // future instance
// let myInstance = MyConstructor.construct(myArray); //like new MyConstructor but with passing array of arguments
// // let myInstance = new MyConstructor(4, 'Hello world!', false);

// console.log(myInstance.property1);                // logs 'Hello world!'
// console.log(myInstance instanceof MyConstructor); // logs 'true'
// console.log(myInstance.constructor);              // logs 'MyConstructor'
// console.log(myInstance.__proto__);              // logs constructor function


// EXP. 3
// ----Using apply to append an array to another
// // without using Apply()
// const array = ['a', 'b'];
// const elements = [0, 1, 2];
// array.push(elements);
// console.info(array); // ["a", "b", [0, 1, 2]]

// // using Concat => concat creat a new array not changing existing array1
// const array1 = ['a', 'b'];
// const elements1 = [0, 1, 2];
// console.info(array1.concat(elements1)); // ["a", "b", [0, 1, 2]]
// console.info(array1); // ["a", "b"]

// // using spread operator
// const array2 = ['a', 'b'];
// const elements2 = [0, 1, 2];
// // console.log(array2.concat(...elements2))
// array2.push(...elements2)
// console.log(array2)

// // Using Apply()
// const array3 = ['a', 'b'];
// const elements3 = [0, 1, 2];
// Array.prototype.push.apply(array3, elements2);
// // array3.push.apply(array3, elements2);
// console.info(array3); // ["a", "b", 0, 1, 2]



// EXP. 4
// ---Math.max()
// let arr = [1,2,3,4,5]
// console.log(Math.max(arr)) // NaN because Math.max() accept arguments separate not array
// // [1] using Spread opertator
// console.log(Math.max(...arr))
// // [2] using apply() accept arguments as array or array like object
// console.log(Math.max.apply(Math,arr))
// console.log(Math.max.apply(null,arr))
// // Note Argument limit in js 65536 

// [3]----------------------------Bind()
/* 
The bind() function creates a new bound function. 
Calling the bound function generally results in the execution of its wrapped function.
*/

// EXP. 1
// ----bound function
// should be var x = 10 not let x = 10; because we want x to be added to global object
// var x = 10;
// let obj = {
//   x : 20,
//   getX : function(){
//     return this.x
//   }
// }
// console.log(obj.getX()) // 20
// let globalX = obj.getX;
// console.log(globalX()) // 10 because excuted in global object and this.x and this refer to global object
// // to solve this problem use bind()
// let objX = obj.getX.bind(obj)
// console.log(objX()) // 20

// EXP. 2
//---partial applied function 
// you can use bind() and bound function to add 3rd parameters to pre-specified no. of arguments in function
// function sum(param1, param2){
//   console.log(arguments)
//   return param1 + param2
// }
// console.log(sum(2,3,20)) // 5 because it accept only 2 arguments
// let sumResult = sum.bind(null,20)
// console.log(sumResult(5)) // 25 

// EXP. 3
// **** using bind to callBack function
// function MyObject (){
//   this.name = 'MyObjectName';
//   this.myProperty = 'property';
// };
// MyObject.prototype.doStuff = function (action) {
//   console.log(this.name + ' is ' + action + '!');
// }
// var obj = new MyObject();
// // here we are calling setTimeout and after delay 1 second there is no this.name 
// setTimeout(obj.doStuff, 1000, 'awesome1');
// // here we are calling callBack function immedialtly 
// setTimeout(obj.doStuff.call(obj,'awesome2'), 1000); 
// // here we bind this (which refer to obj) to function and ready once setTimeout invoke callBack function
// setTimeout(obj.doStuff.bind(obj), 1000, 'awesome3'); 
// // to understand EXP. 3 see below Implicit Binding & Explicit Binding

// reference (https://gist.github.com/zcaceres/2a4ac91f9f42ec0ef9cd0d18e4e71262)

// EXP. 4 
// -----using bind with addEventListener 
// let obj = {
//   theName : "soliman",
//   age : 33,
//   func : function () {
//     console.log(`my Name is ${this.theName} and my age is ${this.age}`)
//   }
// }
// let btn = document.getElementById("bind")
// // here we used bind beacuse now this refer to element that recive click and we want this to refer to obj
// btn.addEventListener('click',obj.func.bind(obj) )
// // if you use call or apply function will invoked immedialtly and give you output before clicking on element
// btn.addEventListener('click',obj.func.call(obj) )

// EXP. 5
// bind can be used as constructor see link below
// bound a constructor will not change this (which will refer to future instance inside the constructor)
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind

// EXP. 6
// shortcut to function for exp. slice
// function args(){
//   // [1] shortcut with Apply()
//   // let arr = Array.prototype.slice.apply(arguments)
//   // console.log(arr)
//   // Shortcut with bind()
//   // let slice = Function.prototype.apply.bind(Array.prototype.slice) // slice now is bound function
//   // let arr = slice(arguments)
//   // console.log(arr)
// }
// args(1,2,3,4)

// -----------------------Implicit Binding & Explicit Binding-------------
// [1] Implicit Binding
// Implicit binding occurs when dot notation is used to invoke a function ( obj.func()).

// [2] Explicit Binding
// Explicit binding of this occurs when .call(), .apply(), or .bind() are used on a function (obj.func.call(anotherObj)).

/* 
This is all about where a function is invoked. 
Often, early programmers worry about where the function was declared. 
Perhaps the function was declared in a specific file or a particular object. 
Surely this changes it's this!
*/

// Eyeballing This ( Steps to know this refer to what)
/*
1. Is there a dot? Look to the left. That's this.
2. Do you see .call() or .apply()? What's passed in before the first comma? Thats this.
3. Does the function stand alone when it's invoked? Then what's your global context? That's this.

Note : bind creates a persistent this context, 
we can't eyeball it. We have to go back and find where this is bound.
*/

// -------using forEach on Object
// let obj = {
//   0 : "A",
//   1 : "B",
//   2 : "C",
//   length : 3
// }
// let arr = [1,2,3]

// Array.prototype.forEach.call(obj, (ele)=> console.log(ele))
// arr.forEach((ele)=> console.log(ele))

// ------------difference between Map and Set

/* 
---------------------Maps - Like Objects they have keys and values---------------
    (unique keys)
    .size
    .set(key, value)
    .delete(key)
    .get(key)
    .has(key)
    .keys() - returns Iterator with array of keys
    .values() - returns Iterator with array of values
    .entries() - returns Iterator with array of [key, value]
    .clear()
    .forEach()

// An Array or other iterable object whose elements are key-value pairs. 
// (For example, arrays with two elements, such as [[ 1, 'one' ],[ 2, 'two' ]] ) 
// Each key-value pair is added to the new Map.

let map = new Map([[ 1, 'one' ],[ 2, 'two' ]])
console.log(map) // Map(2) {1 => 'one', 2 => 'two'}

let obj = {
  prop1 : "D",
  prop2 : "E",
  prop3 : "F",
}
let map = new Map(Object.entries(obj))
console.log(map)

------------------------Sets - Like Arrays they have values-------------------
    (unique values) - remove non-unique values from array
    .size
    .add(value)
    .delete(value)
    .entries() - returns Iterator with array of [value, value]
    .values() - returns Iterator with array of values
    .has(value)
    .clear()
    .forEach()

// Set Constructor accept one argument (If an iterable object is passed, 
// all of its elements will be added to the new Set.)
let arr = ["A","B","C"]
let set = new Set(arr)
console.log(set)

*/

// --- return undefined
/* 
All Function in JS return by Default undefined unless you tell the function to return something else
except Constructor when you use new it return instance
*/


// --------------Chaining Objects and Methods together
// let myObj = function(nm){
//   this.name = nm;
//   //when used with 'new' it will return an instance
// }

// myObj.prototype.capitalize = function(){
//   this.name = this.name.substring(0,1).toUpperCase() + this.name.substring(1);
//   return this;
// }

// myObj.prototype.upper = function(){
//   this.name =  this.name.toUpperCase();
//   return this;
// }

// myObj.prototype.getName = function(){
//   console.log(this.name);
// }

// let bob = new myObj('bob');
// let cole = new myObj('cole');

// // without (retun this) in capitalize and Upper Functions you have to seperate them
// bob.capitalize()
// bob.upper()
// bob.getName()

// // with (retun this) in capitalize and Upper Functions you can chain them
// cole.capitalize().upper().getName()


// there is an Built in Exp. for Chaining Methods like sort() - sort() change array and return it
// let arr = [4,2,3,1]
// arr.sort().forEach((ele)=>console.log(ele))

// -----------home-Made iterator with generator
/*
So your code basically means that the iterator of NumbersFromOne is defined as a generator. 
Instead of manually having to define a function which returns a next and other properties

Returning the generator creates the next function automatically for. 
This allows you to yield when you need to.
*/
//  Old Way without generator
// var NumbersFromOne = {
//   [Symbol.iterator]: function () {
//     var i = 1;
//     return {
//         next: function() {
//             if( i < 4){
//               return { value: i++, done: false };
//             }else{
//               return { value: undefined, done: true };
//             }
//         }
//     };
//   }
// };
// let ite = NumbersFromOne[Symbol.iterator]()
// console.log(ite.next())
// console.log(ite.next())
// console.log(ite.next())
// console.log(ite.next())

// // new Way with Generator
// var NumbersFromOne1 = {
//   [Symbol.iterator]: function* () {
//     for (let i = 1; i < 4 ; ++i) yield i;
//   }
// };
// let ite1 = NumbersFromOne1[Symbol.iterator]()
// console.log(ite1.next())
// console.log(ite1.next())
// console.log(ite1.next())
// console.log(ite1.next())

// -----------For.....in loop

/* 
The for...in statement iterates over all enumerable properties of an object 
that are keyed by strings (ignoring ones keyed by Symbols), 
including inherited enumerable properties. 
Objects created from built–in constructors like Array and Object have inherited 
non–enumerable properties from Object.prototype and String.prototype, 
such as String's indexOf() method or Object's toString() method. 

** Iterating over own properties only :
if (obj.hasOwnProperty(prop)){} => the inherited properties are not displayed.
or if(Object.prototype.hasOwnProperty.call(myObject, prop)){}
in case myObject has overwritten the inherited hasOwnProperty() method.

var triangle = {a: 1, b: 2, c: 3};

function ColoredTriangle() {
  this.color = 'red';
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (const prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}

// OR 

for (const prop in obj) {
  if (Object.prototype.hasOwnProperty.call(obj, prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}
*/

//--------------------------Before and After Spread operator--------------
// // [1] Array of Arguments
// function sum(x,y,z){
//   return x + y + z
// }
// let args = [1,2,3]
// // Before Spread Operator
// console.log(sum.apply(null,args))
// // After Spread Operator
// console.log(sum(...args))

// // [2] Combine two Arrays
// let arr1 = [1,2,3]
// let arr2 = [4,5,6]
// // Before Spread Operator
// let arr3 = arr1.concat(arr2)
// // After Spread Operator
// let arr4 = [...arr1,...arr2]

// [3] Adding Array at the beginning of another array
// let arr1 = [1,2,3]
// let arr2 = [4,5,6]
// // Before Spread Operator
// Array.prototype.unshift.apply(arr1,arr2)
// // After Spread Operator
// arr1 = [...arr2,...arr1]
// console.log(arr1)

// [4] clone new Object
/*
It copies own enumerable properties from a provided object onto a new object.
Note that Object.assign() triggers setters, whereas spread syntax doesn't.
*/
// // before Spread Operator
// let obj ={
//   a : "A",
//   b : "B"
// }
// let clone = Object.assign({},obj)
// clone.c = "C"
// console.log(obj)
// console.log(clone)

// // After Spread Operator (ES2018)
// let obj1 = {
//   a : "A",
//   b : "B"
// }
// let clone1 = {...obj1}
// clone1.c = "C"
// console.log(obj1)
// console.log(clone1)

//[5] array of parameters with new Operator
// Before Spread Operator
/*
it's not possible to directly use an array and apply() (apply() does a [[Call]] and not a [[Construct]])
check the EXP. how to use array of parameters with new Operator without Spread Operator
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax
*/ 
// After Spread Operator
// let dateFields = [1970, 0, 1];  // 1 Jan 1970
// let d = new Date(...dateFields);


// ----------Spread operator is not suitable for copying multidimensional arrays
/* 
here a is array of arrays and when we take a copy of array using spread operator we are taking
shallow copy of array put child arrays(arrays inside the parent array) we are taking deep copy
so when we change one of child arrays from b it will be changed also at a
*/
// let a = [[1], [2], [3]];
// let b = [...a];

// b.shift().shift()
// console.log(a) // [[],[2],[3]]
// console.log(b) // [[2],[3]]


// ----------------------------Callee and Caller------------------
/* 
[1] Callee : 
The arguments.callee property contains the currently executing function. 
This is useful when the name of the function is unknown, 
such as within a function expression with no name (also called "anonymous functions").

[2] Caller :
The function.caller property returns the function that invoked the specified function. 
It returns null for strict, async function and generator function callers.
*/


// function test(a,b,c){
//   console.log(arguments)
//   console.log(arguments.callee) // like console.log(test) // test
//   console.log(arguments.callee.caller) // like console.log(test.caller) // null
//   function inside(d,e,f){
//     console.log(arguments)
//     console.log(arguments.callee) // inside
//     console.log(arguments.callee.caller) // test
//   }
//   inside("Hussein","Mohamed","Ahmed")
// }
// test("Mohamed","Ahmed","Soliman")
// console.log(test.length) // retrun arguments length
// console.log(test.name) // return function name

// now you can refer to anonymous functions by arguments.callee
// let arr = [1,2,3,4]
// arr.map(function(){
//   console.log(arguments.callee) 
// })

// No arguments object returned from Arrow function
// let arrowFunc = (a,b,c,d)=>{
//   console.log(arguments)
// }
// arrowFunc(1,2,3,4) // Error

// ----------------[[Call]] and [[Construct]]-------------
/*
In technical terms, functions in Javascript are defined by the two internal methods 
[[Call]] and [[Construct]] . Any object with a [[Call]] method is called a function, 
and any function that additionally has a [[Construct]] method is called a constructor¹. 
The [[Call]] method determines what happens when you invoke an object as a function, 
e.g. foo(args) , while [[Construct]] determines what happens when you invoke it as 
a new expression, i.e. new foo or new foo(args) .

For ordinary function definitions², calling [[Construct]] will implicitly create a new object
whose [[Prototype]] is the prototype property of the constructor function 
if that property exists and is object valued, or Object.prototype otherwise. 
The newly created object is bound to the this value inside the function’s local environment. 

If the function returns an object, the new expression will evaluate to that object, 
otherwise, the new expression evaluates to the implicitly created this value.
As for the prototype property, that is implicitly created whenever you define an ordinary 
function.

function Func (){
  this.a = 1
  console.log(new.target)
}

function Func2 (){
  return {a : 2}
}

let myFunc = new Func()
console.log(myFunc) // Func {a: 1}
console.log(myFunc instanceof Func) // true

let myFunc2 = new Func2()
console.log(myFunc2) // {a: 2}
console.log(myFunc2 instanceof Func2) // false

Each newly defined function has a property named “prototype” defined upon it
with a newly created object as its value. That object in turn has a constructor property 
which points back to the original function. Note that this prototype property is not the 
same as the [[Prototype]] slot. In the previous code example, Foo is still just a function, 
so its [[Prototype]] is the predefined object Function.prototype .
*/



// -------why we can not use Apply with new keyword-------------
/* 
[[Call]] is invoked via Date(…) whereas [[Construct]] is invoked via new Date(…). 
If you were to attempt to [[Construct]] a Date via new Date.apply(…, dateFields), 
it actually invokes [[Construct]] on the Function.prototype.apply method, 
not the Date object, which does not properly initialize a Date object, 
but rather it attempts to initialize an object with [[Prototype]] equal to 
apply.prototype which is undefined since apply() is not a constructable function, 
and therefore throws a TypeError.
*/

/* ------Steps for new Keyword
1. Creates a blank, plain JavaScript object.
2. Adds a property to the new object (__proto__) that links to the constructor function's prototype object
3. Binds the newly created object instance as the this context (i.e. all references to this in the constructor function now refer to the object created in the first step).
4. Returns this if the function doesn't return an object.
*/

// ---------------------------------------Reflect.construct()-------------------
/*
Reflect.construct(target , args , newTarget)

Reflect.construct() allows you to invoke a constructor with a variable number of arguments. 
(This would also be possible by using the spread syntax (rest parameters) combined with the new operator.)
The static Reflect.construct() method acts like the new operator, but as a function. 
It is equivalent to calling new target(...args)

let obj = new Foo(...args)
let obj = Reflect.construct(Foo, args)

Return value
A new instance of target (or newTarget, if present), 
initialized by target as a constructor with the given argumentsList.
*/

// ---------Reflect.construct() vs Object.create()
/*
* Reflect.construct(target , argument list, newTarget)

* Reflect.construct() like new Constructor() so new.target will refer to constructor of
of target (or newTarget, if present)

* Object.create() not like new Constructor so new.target will refer to undefined

you can use Object.create to create a new object with the specified prototype object and properties. 
((instance)) 

function Parent(name){
  this.name = name;
}
let obj = Object.create(Parent.prototype)
Parent.call(obj,"Soliman")
console.log(obj)
console.log(obj instanceof Parent) // true

*/
// function OneClass() {
//   this.name = 'one'
//   console.log(new.target)
//   console.log(this)
// }

// function OtherClass() {
//   this.name = 'other'
//   this.age = 33
// }
// let args = [1,2,3,4]
// // Calling this:
// let obj1 = Reflect.construct(OneClass, args, OtherClass)

// // // ...has the same result as this:
// let obj2 = Object.create(OtherClass.prototype)
// OneClass.apply(obj2, args)

// // console.log(obj1.name)  // 'one'
// // console.log(obj1.age)  // 'undefined'
// // console.log(obj2.name)  // 'one'
// // console.log(obj2.age)  // 'undefined'

// console.log(obj2)
// console.log(obj1 instanceof OneClass)  // false
// console.log(obj2 instanceof OneClass)  // false

// console.log(obj1 instanceof OtherClass)  // true
// console.log(obj2 instanceof OtherClass)  // true

// ----------------------Encapsulation----------------------

/* 
- Class Fields are Public by Default
- Guards the Datat against illegal Access
- Helps to Achieve the target without revealing its complex details
- will reduce human errors
- make the app more flexible
- simplifies the app
*/


// class User {
//   // to declare private property
//   #passWord;
//   constructor(id,userName, passWord){
//   this.id = id;
//   this.userName = userName;
//   this.#passWord = passWord;
//   }
//   getPass(){
//     return parseInt(this.#passWord)
//   }
//   #privatMethod(){
//     return "i Am Private Method"
//   }
//   getPrivateMethod(){
//     return this.#privatMethod()
//   }
// }

// let user1 = new User(1,"Soliman","1234 lool")
// console.log(user1.id)
// console.log(user1.userName)
// console.log(user1.getPass())
// console.log(user1.getPass() * 2)
// console.log(user1.getPrivateMethod())

// class Admin extends User {
//   constructor(id,userName, passWord,age){
//     super(id,userName, passWord)
//     this.age = age
//   }
// }
// let admin1 = new Admin(1,"Soliman","1234 lool", 33)
// console.log(admin1.passWord) // undefined
// console.log(admin1.getPass()) // 1234
// console.log(admin1.privatMethod) // undefined
// console.log(admin1.getPrivateMethod()) // "i Am Private Method"



// -------------Asyn Iterators for Big Data--------------
// you have really big data and you need to fetch a lot of times
// based on Youtube Video(https://youtu.be/u2hwYeN1P-I)
//https://jsonplaceholder.typicode.com/posts
//retrieves 100 records
//let's pretend that there are millions of records
// let posts = {};
// posts[Symbol.iterator] = function(){
//   const URL = "//jsonplaceholder.typicode.com/posts";
//   return {
//     async next(){
//       //early pre-emptive move
//       let rand = Math.random();
//       if(rand > 0.7){
//         console.log("> 0.7")
//         return {
//           value: undefined,
//           done: true
//         };
//       }
//       let request = new Request(URL+`?r=${rand}`, {
//         method: 'GET',
//         mode: 'cors'
//       });                
//       let response = await fetch(request);
//       //need to add catch()
//       let data = await response.json();
//       console.log('array of posts fetched', data);
//       return {
//         value: data,
//         done: false
//       }
//     }
//   }
// }
// let output = document.getElementById('output');
// let main = document.querySelector('.main');
// main.addEventListener('click', de);        
// function de(ev){
//   //start getting data
//   //output.textContent += JSON.stringify(d);
//   let iterator = posts[Symbol.iterator]();          
//   (async function getData(){
//     let data = await (iterator.next()); // we needs await because we are dealing with fetch here (async next return promise )
//     console.log(data)
//     if(data.value && !data.done){
//       output.textContent += '\r\n' + JSON.stringify(data.value);
//       console.log('getData', data.value);
//       setTimeout(getData, 2000);
//     }else{
//       console.log( 'Done:', data.done );
//       output.textContent += '\r\n DONE.';
//     }
//   })();
// }


// -----------------------------–Typed Array-------------------------------
/* 
Typed Arrays in JavaScript accept only one data type look exp. of restricted data type in type array :  

Int8Array - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array
-128 to 127

Uint8Array - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array
0 - 255

Uint8ClampedArray - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray
0 - 255

Int16Array - like Int8Array but 16 bits in length
-32768 to 32767
Uint16Array - like Uint8Array but 16 bits in length
0 to 65535

Int32Array - like Int8Array but 32 bits in length
-2147483648 to 2147483647
Uint32Array - like Uint8Array but 32 bits in length
0 to 4294967295

unsigned means non-negative int

clamped means (If you are trying to set one element to a clamped array to any value outside of the range 0-255, it will simply default to 0 or 255 (depending on whether the value is smaller or larger))

Float32Array - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array
1.2x10-38 to 3.4x10 38

Float64Array - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array
5.0x10 -324 to 1.8x10 308

ArrayBuffer - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
- used to represent a generic, fixed-length raw binary data buffer.

DataView - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView

Typed Arrays are used by: WebGL, Canvas, Web Audio API, XMLHttpRequests, Fetch API,  WebSockets, Web Workers, Media Source API and File APIs. 
*/

//new Int8Array(length(bytes) | buffer | TypedArray);
// array of 8-bit integers
// most Array methods are available on TypedArrays too

// let buffer = new ArrayBuffer(16);
// //create a 16 byte buffer

// let dv1 = new DataView(buffer);
// //create a DataView to be able to access/set whole buffer
// let dv2 = new DataView(buffer, 10, 3);
// //start at slot 10, get 3 bytes


// dv1.setInt8(11, 42);
// //put "42" in slot 11 of the buffer through view1
// let num = dv2.getInt8(1);
// console.log(num)
// console.log( dv2.getInt8(0))
// console.log( dv2.getInt8(2))
// //retrieve the 42 from the 2nd byte in view2 which was 
// //the 11th byte in the buffer

//--------------------Private Variable inside Factory Function with Closure -------------------
/* 
The closure preserves the outer scope inside its inner scope.
JavaScript engine uses the scope to manage the variable accessibility.
normally, a local variable only exists during the execution of the function.
The magic of this is closure. In other words, the sayHi() function is a closure.
A closure is a function that preserves the outer scope in its inner scope.

function greeting() {
    let message = 'Hi';
    function sayHi() {
        console.log(message);
    }
    return sayHi;
}
let hi = greeting();
hi(); // still can access the message variable
*/

// function Factory(x){
//   let _privateVariable = x;
//   return {
//     prop1 : _privateVariable,
//     prop2 : function(){
//       console.log(_privateVariable)
//     }
//   }
// }
// let obj = Factory(10)
// obj.prop2()

// ------------------------Closure with Loops-------------------

/* [1] Function inside Function
this will work normally because here where are using setTimeout function inside
another function so we are creating closure which preserves the outer scope inside its inner scope.
so this will work even if we use var not let because we already create a closure (function inside function)
*/

// let myNames = ["Mohamed","Ahmed","Soliman","Hussein"]
// for(var i =0 ; i < myNames.length; i++){
//   myFunc(i,myNames[i])
// }
// function myFunc(index,name){
//   setTimeout(function(){
//     console.log(`The Index : ${index} and the name : ${name}`)
//   },1000*index)
// }
/* [2] Using Let
this will work normally because of using let : let is block scope and each loop create separate scope 
for the code block which create a closure and the closure preserves the outer scope inside its inner scope
*/
// let myNames2 = ["Mohamed","Ahmed","Soliman","Hussein"]
// for(let i = 0 ; i < myNames2.length; i++){
//   setTimeout(function(){
//     console.log(`The Index : ${i} and the name : ${myNames2[i]}`)
//   },1000*i)
// }

/*
this will not work normally will return index 4 and undefined 4 times because we are usning var
and var is not block scope and each loop create seperate scope or create closure and var will not be preserved in each block scope
so when setTimeout excute will search at var i inside global scope and i in global scope 
after loop will be 4 and there is no myNames3[4] so myNames3[4] = undefined 

*/
// let myNames3 = ["Mohamed","Ahmed","Soliman","Hussein"]
// for(var i = 0 ; i < myNames3.length; i++){
//   setTimeout(function(){
//     console.log(`The Index : ${i} and the name : ${myNames3[i]}`)
//   },1000*i)
// }

// ----to Solve this Problem you have 4 options : 

// [1] Using let instead of var

// [2] using bind method
// because once the setTimeout function excute in future we already bound(thisArg, arg1) to it
// let myNames = ["Mohamed","Ahmed","Soliman","Hussein"]
// for(var i =0 ; i < myNames.length; i++){
//   setTimeout((function(index){
//     console.log(`The Index : ${index} and the name : ${this[index]}`)
//   }).bind(myNames,i),1000*i)
// }

// [3] passing parameters to setTimeout
// like concept of binding we pass the value of i each loop to setTimeout Function once it excute in future it has it's i value
// let myNames = ["Mohamed","Ahmed","Soliman","Hussein"]
// for(var i =0 ; i < myNames.length; i++){
//   setTimeout(function(index){
//     console.log(`The Index : ${index} and the name : ${myNames[index]}`)
//   },1000*i,i)
// }

// [4] Using IIFE
// IIFE will create a new scope for each setTimeout execution
// let myNames = ["Mohamed","Ahmed","Soliman","Hussein"]
// for(var i =0 ; i < myNames.length; i++){
//   (function(index){
//     setTimeout(function(){
//       console.log(`The Index : ${index} and the name : ${myNames[index]}`)
//     },1000*i)
//   })(i)
// }
// a good link for this problem
// https://discuss.codecademy.com/t/var-and-let-in-a-loop-working-differently/550468/8

// ----------------escape sequence in javascript-----------------
/*
\b Backspace 
\f Form Feed 
\n New Line 
\r Carriage Return
\t Horizontal Tabulator 
\v Vertical Tabulator 
\' Single quote 
\" Double quote 
\\ Backslash

* Carriage return (\r): moves the cursor to the beginning of the line
* Line Feed (\n): moves the cursor down to the next line 
* Form Feed  :"On printers, load the next page. In some terminal emulators, 
it clears the screen." (truncates the string on Safari.)
* Backspace : "Move the cursor one position leftwards." (ignored on Safari.)
*/

// ------------------------trimStart and trimEnd---------------------
/* 
white space : space, tab , no-Break space , LF, CR => depending on which operator system

* Carriage return (\r): moves the cursor to the beginning of the line
* Line Feed (\n): moves the cursor down to the next line 

A CR immediately followed by a LF (CRLF, \r\n, or 0x0D0A) moves the cursor down to the next 
line and then to the beginning of the line.

non-breaking spaces can't be split on separate lines
non-breaking spaces will not be "collapsed" like regular spaces will
*/

// let nbsp = "\u00A0" // \xa0 in hex
// let cr = "\u000D" // \x0D in hex
// let lf = "\u000A" // \x0A in hex
// let tab = "\t" // \x09 in hex

// let str = `${tab}.i am a front-end developer.${nbsp}`
// let str1 = `\t.i am a front-end developer.${nbsp}`
// console.log(str)
// console.log(str.trim())
// console.log(str.trimStart())
// console.log(str.trimEnd())

// -------------------Clock-------------
// you can use it in your clock (count down in vs folder on desktop)

/*
 * Converting seconds into proper time values like a digital clock
 * 00:01:03
*/

// let timmy = setInterval(showTime, 1000);
// let seconds = 3595;

// function showTime() {
//      //update the time as hours, minutes, and seconds 00:00:00
//   seconds++;
//   let hours = Math.floor(seconds / 3600);
//   let mins = Math.floor(seconds / 60) - (hours * 60);
//   let secs = Math.floor(seconds % 60);
//   let output = hours.toString().padStart(2, '0') + ':' +
//   mins.toString().padStart(2, '0') + ':' +
//   secs.toString().padStart(2, '0');
//   console.log(output);
// } 

// --------------Chained Variable Declaration--------------
/*
=> z will be added to global object because we didn't declare z with var or let
JS engine will search for variable with name z in local scope will not find variable z
then will go to global scope also will not find variable z so will add z as property to 
global object

=> b like z will be added as property to global scope

* let and var are function scope but let is block scope var is not block scope
* because var is function scope will not added to global scope but if it's inside block or 
in global scope will be added to global scope
*/
// (function f1(){
//   let x = 1;
//   var y = 2;
//   z = 3
//   var a = b = 4
// })()
// console.log(window.z)
// console.log(window.b)
// if(true){
//   let f = 5;
//   var g = 6
// }
// var k = 7;
// console.log(window.g)
// console.log(window.k)

// --------------------Conditional Operand Selectors----------------
/*
(&&) will look first at first value :
* if truthy value will render second value 
* if falsy value will render first value

(||) will render first truthy value if no truthy value will render last falsy value
*/

// console.log( true && true) // true
// console.log( false && true) // false
// console.log( true || false) // true
// console.log( false || true) // true
// console.log("#######")
// console.log( 0 && true) // 0
// console.log( 0 && false) // 0
// console.log( 1 && true) // true
// console.log( 0 || false) // false
// console.log( 1 || true) // 1
// console.log("#######")
// console.log( 0 && "text") // 0
// console.log( 1 && "text") // "text"
// console.log( 0 || "text") // "text"
// console.log( 1 || "text") // 1
// console.log("#######")
// console.log( false && "text") // false
// console.log( true && "text") // "text"
// console.log( false || "text") // "text"
// console.log( true || "text") // true

// -----------------------charCodeAt and codePointAt------------
/**
 * Character Codes and Code Points 
 * str.charCodeAt(index) //good for UTF-8  (0 - 65535 or 0xFFFF) for normal characters
 * str.codePointAt(index) //better for UTF-16 (0 - 1114111 or 0x10FFFF) for different characters like Emoji
 * str.charAt(index)
 *
 * String.fromCharCode(code) //good for UTF-8 (0 - 65535 of 0xFFFF)
 * String.fromCodePoint(code) //better for UTF-16 (0 - 1114111 or 0x10FFFF) better for Emoji
 */
// Emoji is bigger than 65535 so it will be 2 charachters
// let emojis = "😆😀😂🍔🔥❤";
// let str = "ab🔥C";

// console.log(str.length); // 5 because 🔥 divided to 2 charachter
// console.log(
//   str.charAt(0),
//   str.charAt(1),
//   //  position 2 and 3 is 🔥 (because it's divided to 2 charachter)
//    str.charAt(2), // ? because it half of 🔥
//    str.charAt(3), // ? because it half of 🔥
//   str.charAt(4)
// );

// let cs = str.charCodeAt(0);
// console.log(cs, cs.toString(16)); // 97 => a
// console.log(String.fromCharCode(97)) // a

// let cca = emojis.charCodeAt(0);
// let cpa = emojis.codePointAt(0);
// console.log(cca, cpa, cca.toString(16), cpa.toString(16));

// let char3 = String.fromCharCode(cs);
// console.log(char3); // a
// let char1 = String.fromCharCode(cca);
// let char2 = String.fromCodePoint(cpa);
// console.log(char1, char2); // ? 😆

// -----------------------------For Await of Loop-------------------------
/*
When a for await...of loop iterates over an iterable, it first gets the iterable's 
[@@asyncIterator]() method and calls it, which returns an async iterator.
If the @asyncIterator method does not exist, it then looks for an [@@iterator]() method,
which returns a sync iterator. 
The sync iterator returned is then wrapped into an async iterator 
by wrapping every object returned from the next(), return(), and throw() methods 
into a resolved or rejected promise, with the value property resolved if it's also 
a promise. The loop then repeatedly calls the final async iterator's next() method 
and awaits the returned promise, producing the sequence of values to be assigned to 
variable.

in other word 
*for await...of loop works for object has [@@asyncIterator]() method inside it next() return promise
next() return promise

*for await...of loop works for object has [@@iterator]() method inside it next() object it's value is promise 
next() return object it's value is promise
 */
// let arr = [
//   new Promise(resolve =>setTimeout(resolve,4000,"One")),
//   new Promise(resolve =>setTimeout(resolve,1000,"Two")),
//   new Promise(resolve =>setTimeout(resolve,1000,"Three"))
// ];

// for(let p of arr ){
//   console.log(p) // will return Promise<pending>
// };

// (async function(){
//   for await (let res of arr ){
//     console.log(res) // will return one two three
//   }
// })();

// let myObj = {
//   //add an asyncIterator method to my object
//   [Symbol.asyncIterator]() {
//     //which will return an object that contains a method called next()
//     return {
//       i: 0 /* my counter property */,
//       next() {
//         if (this.i < 3) {
//           //return value from the next method must be an object
//           //the object should contain a value and a done property
//           return new Promise(resolve => {
//             let obj = { value: this.i, done: false };
//             this.i = this.i + 1;
//             setTimeout(resolve, 1000, obj);
//             //this timeout delay value is not set until next() is called by for await...of
//           });
//         }
//         //once our counter value is 3 or more tell whoever called next that we are done
//         return new Promise(resolve => {
//           setTimeout(resolve, 3000, { done: true });
//         });
//       }
//     };
//   }
// };

// let myObj = {
//   //add an asyncIterator method to my object
//   [Symbol.iterator]() {
//     //which will return an object that contains a method called next()
//     return {
//       i: 0 /* my counter property */,
//       next() {
//         if (this.i < 3) {
//           let p1 = new Promise(resolve=> resolve(this.i))
//           let obj = { value: p1, done: false }; // p1 is promise
//           this.i++
//           return obj
//         }
//         let obj2 = { value: this.i, done: true };
//         return obj2
//       }
//     };
//   }
// };




// (async function() {
//   for await (let num of myObj) {
//     console.log(num);
//   }
// })();


// ---------------------------custom event---------------------

//1. let evt = new Event('explode');
//2. let evt = new CustomEvent('explode', {detail:{speed:20, volume:40}});

// let born = new Event('born');
// //  if you want to add properties to event use CustomEvent constructor instead of Event
// // adding time:Date.now() will not give you time when this event triggered will give you time when event created
// // you can add just Date.now and add () when accessing time() property
// let died = new CustomEvent('died', {detail:{time:Date.now}});
// console.log(born) 
// console.log(died)


// document.addEventListener('DOMContentLoaded', function (){
//     let m = document.querySelector('.main');
//     addParagraph(m, 'This is a paragraph.');
//     addParagraph(m, 'A new Star Wars movie is coming soon.');
//     m.addEventListener('click', function(ev){
//         removeParagraph(m, m.firstElementChild);
//     })
// });

// function addParagraph(parent, txt){
//     let p = document.createElement('p');
//     p.textContent = txt;
//     //set up and dispatch events
//     p.addEventListener('born', wasBorn);
//     p.addEventListener('died', hasDied);
//     p.dispatchEvent(born)
//     //add to screen
//     parent.appendChild(p);
// }
// function removeParagraph(parent, p){
//     // dispatch event to trigger the event
//     p.dispatchEvent(died);
//     //remove element from screen
//     parent.removeChild(p);
// }
// function wasBorn(ev){
//     console.log(ev.type, ev.target);
// }
// function hasDied(ev){
//     console.log(ev.type, ev.target, new Date(ev.detail.time()));
//     //remove the listeners (its better to delete EventListener to save Memory)
//     ev.target.removeEventListener('born', wasBorn);
//     ev.target.removeEventListener('died', hasDied);
// }


// // Browser version with Event Listener to call a function
// let Schwift = new CustomEvent("schwifty");
// class MyObj extends EventTarget {
//   //allowed to receive / listen for events
//   constructor() {
//     super();
//   }
//   log(ev) {
//     console.log("EVENT", ev); // Schwift Event object
//   }
// }
// let obj = new MyObj();
// // you can also directly create obj from EventTarget constructor to be allowed to receive / listen for events
// // let obj = new EventTarget();
// obj.addEventListener("schwifty", obj.log);
// obj.addEventListener("schwifty", ev => console.log(ev.type)); //"schwifty"
// setTimeout(function() {
//   obj.dispatchEvent(Schwift); //trigger the two event listeners for "schwift"
// }, 1000);

// --------------------------new Object for everyThing-------------
// let obj1 = {
//   a: "this",
//   b: "is",
//   c: "an",
//   d: "object",
//   e: "literal"
// };
// let obj2 = new Object(["object", "contructor", "one"]); //  Array("", "", "")
// let obj3 = new Object({ an: "object", literal: "again" }); //  object
// let obj4 = new Object(obj1.a); // new Object("some string")  new String("asdfas")
// let obj5 = new Object(); //same as new Object(null) or new Object(undefined)
// let obj6 = new Object(true); // new Boolean(true)


// console.log(
//   "OBJ1",
//   obj1,
//   typeof obj1,
//   obj1 instanceof Object,
//   obj1.constructor,
//   "\n"
// );

// console.log(
//   "OBJ2",
//   obj2,
//   typeof obj2,
//   obj2 instanceof Array,
//   obj2 instanceof Object,
//   Array.isArray(obj2),
//   obj2.constructor,
//   "\n"
// );

// console.log(
//   "OBJ3",
//   obj3,
//   typeof obj3,
//   obj3 instanceof Object,
//   obj3.constructor,
//   "\n"
// );

// console.log(
//   "OBJ4",
//   obj4,
//   typeof obj4,
//   obj4 instanceof String,
//   obj4.constructor,
//   "\n"
// );

// console.log(
//   "steve",
//   String("steve"),
//   new String("steve"),
//   typeof "steve",
//   typeof String("steve"),
//   typeof new String("steve"),
//   "\n"
// );

// console.log(
//   "OBJ5",
//   obj5,
//   typeof obj5,
//   obj5 instanceof Object,
//   obj5.constructor,
//   "\n"
// );

// console.log(
//   "OBJ6",
//   obj6,
//   typeof obj6,
//   obj6 instanceof Boolean,
//   obj6 instanceof Object,
//   obj6.constructor,
//   "\n" 
// );


// ------------------------Before and After Destructuring--------------
//Why Destructuring (and ES6) is Awesome

// let person = {
//   id: 123,
//   name: "Leslie",
//   dob: new Date("1985-01-01").valueOf(),
//   age: 44,
//   salary: 55000,
//   department: "Parks and Recreation",
//   hometown: "Pawnee"
// };


// ---ES5 version
// function savePersonES5(someObj) {
//   let id = Date.now();
//   if (someObj.id) {
//     id = someObj.id;
//   }
//   let name = someObj.name;
//   if (!name) {
//     name = "Blank";
//   }
//   let dob = someObj.dob ? someObj.dob : new Date("2000-01-01").valueOf();
//   //save it in localStorage for later use
//   const KEY = "someRandomUniqueString";
//   let jsonStr = JSON.stringify({ id: id, name: name, dob: dob });
//   // localStorage.setItem(KEY, jsonStr);
//   console.log(jsonStr)
// }
// savePersonES5(person);

// ----ES6 Version
// function savePersonES6({id = Date.now(),name = "Blank",dob = new Date("2001-01-01").valueOf()}) {
//   const KEY = "someRandomUniqueString";

//   let jsonStr = JSON.stringify({ id, name, dob });
//   // localStorage.setItem(KEY, jsonStr);
//   console.log(jsonStr)
// }
// savePersonES6(person);

// ------------------------------Numeric Seperator---------------------
// you can add _ between numbers to make it easy to read and will not effect anything
// let num = 1_000_000_000
// console.log(num)
// console.log(num + 1)

// -------------------------------Optional Chaining--------------
/*
we have two exp. 
[1] 1st exp. is array 
* before Optional Chaining : we have to check first if arr1[0] has 
property called label using if condition

* After Optional Chaining : we can use ?. and it will search automatically if 
arr1[0] has property called label if exist will return it's value to variable 
propValue if not exist will return undefined

[2] 2nd Exp. is object 
* you can check for property name using ?. if if exist will return it's value to variable 
grandChild if not exist will return undefined

* it's very usefull in methods if the method does not exist and use ?.() instead of . 
will not thorw an Error will do nothing but using () directly will throw an Error
*/
// let arr1 = [
//   { label: 'ONE' },
//   { label: 'TWO' },
//   { label: 'THREE' },
//   { label: 'FOUR' },
//   { label: 'FIVE' }
// ]

// before Optional Chaining
// function hasLabel(arr){
//   if(arr[0].label){
//     let propValue = arr[0].label
//     console.log("Found", propValue)
//   }
// }
// hasLabel(arr1)


// // Using Optional Chaining
// function hasLabel2(arr){
//   let propValue = arr[0]?.labell
//   if(propValue){
//     console.log("Found", propValue)
//   }else{
//     console.log("Not Found", propValue)
//   }
// }
// hasLabel2(arr1)

// let obj1 = {
//   prop1 : 1,
//   prop2 : 2,
//   prop3 : {subProp1 : 3 , subProp2 : {subSubProp1 : 4 }},
//   method1 : function(){
//     console.log("I Am Method 1")
//   }
// }
// let grandChild = obj1.prop3.subProp2.subSubProp1
// let grandChild2 = obj1?.prop3?.subProp2?.subSubProp1
// let grandChild3 = obj1?.prop3?.subProp2?.subSubProp2
// let grandChild4 = obj1.prop3.subProp2.subSubProp2
// console.log(grandChild) // 4
// console.log(grandChild2) // 4
// console.log(grandChild3) // undefined
// console.log(grandChild4) // undefined
// obj1.method1()
// // obj1.method2() // Error
// obj1.method2?.() // No Error



// more complicated exp. from this video ( https://youtu.be/G662_abEci0)
// const dataArr = [
//   { label: 'ONE' },
//   { label: 'TWO' },
//   { label: 'THREE' },
//   { label: 'FOUR' },
//   { label: 'FIVE' }
// ];
// const dataObj = {
//   4: { label: 'I am Number Four' },
//   7: { label: `What's in the box?` },
//   m: () => {
//     console.log('custom method');
//   },
//   top: { mid: { deep: 123 } }
// };

// const addPara = (num, hex) => {
//   // let txt = 'default';
//   // if(dataArr && dataArr[num-1]) {
//   //   txt=dataArr[num-1].label
//   // }
//   // let txt = dataArr[num - 1]?.label;
//   let txt = dataObj[num]?.label;
//   if (txt) {
//     let p = document.createElement('p');
//     p.style.backgroundColor = hex; //8 digit hex
//     p.id = `_${num}`; // _4, _5, _6, _7
//     p.textContent = txt;
//     document.body.appendChild(p);
//   }
//   //console.log(dataObj?.toplevel?.mid?.deep);
//   //if (dataObj && dataObj.top && dataObj.top.mid && dataObj.top.mid.deep) {
//   //}
//   dataObj.m?.();
//   dataObj.f?.();
// };

// const handleClick = ev => {
//   let num = Math.floor(Math.random() * 7) + 1; // 1 - 7
//   console.log(num)
//   let id = '_'.concat(num); // _3
//   let hex = randColour(); // 8 digit hex
//   console.log(id, hex);
//   let div = document.getElementById(id);
//   div ? (div.style.backgroundColor = hex) : addPara(num, hex); // or void 0
//   //addPara.call(null, num, hex); //addPara(num, hex)
// };

// const randColour = () => {
//   let clr = Math.floor(Math.random() * Math.pow(2, 24));
//   let red = (clr >> 16).toString(16).padStart(2, '0');
//   let green = ((clr >> 8) & 255).toString(16).padStart(2, '0');
//   let blue = (clr & 255).toString(16).padStart(2, '0');
//   let alpha = Math.floor(Math.random() * 200 + 55)
//     .toString(16)
//     .padStart(2, '0'); //alpha is a value 0-100% but written as num 0-255
//   // and in hex that means 00 - FF. 50% is 128 in decimal or 80 in Hex
//   // https://codepen.io/chriscoyier/pen/XjbzAW - ref chart for percentages
//   //console.log(red, green, blue, alpha);
//   return `#${red}${green}${blue}${alpha}`;
// };

// document.addEventListener('DOMContentLoaded', () => {
//   document.body.addEventListener('click', handleClick);
// });


// ----------------------Custom Sorting--------------------
/* when use sorting it's under the hood convert elements inside the array to string so here 
elements inside array is objects and when converted to string using toString() all of them 
will convert to [Object Object] so using sort() with custom function will not do anything 

the custom function should return postive or negative number or zero  
number > 0 sort element1 before element2 | number < 0 sort element1 before element2 | === 0 keep original order
*/

// const people = [
//   { id: 12, name: 'Billy', dob: '1998-10-05' },
//   { id: 123, name: 'Bart', dob: '1993-02-15' },
//   { id: 45, name: 'Belinda', dob: '1996-01-31' },
//   { id: 67, name: 'Bonnie', dob: '1998-04-09' },
//   { id: 89, name: 'Brenda', dob: '1996-07-08' },
//   { id: 34, name: 'Bobby', dob: '1994-09-12' },
//   { id: 234, name: 'Blake', dob: '2000-01-01' },
// ];

// const log = console.log;

// log('\n\n built-in sort method');
// log(people.sort());

// log('\n\n sort by name');
// log(people.sort(byName));

// log('\n\n sort by id');
// log(people.sort(byId));

// log('\n\n sort by date');
// log(people.sort(byDate));

// log('\n\n sort by birthday as it occurs during the year');
// log(people.sort(byBirthday));

// function byName(a, b) {
//   //alphabetically by name
//   if (a.name > b.name) {
//     return 1;
//   } else if (b.name > a.name) {
//     return -1;
//   } else {
//     return 0;
//   }
// }

// function byId(a, b) {
//   //numerically by id
//   return parseInt(a.id) - parseInt(b.id);
// }

// function byDate(a, b) {
//   //chronologically by year, month, then day
//   return new Date(a.dob).valueOf() - new Date(b.dob).valueOf(); //timestamps
// }

// function byBirthday(a, b) {
//   //by month and then by day
//   let d1 = new Date(a.dob); // 1993-02-15T00:00:00Z =>   1993-02-14T20:00:00EST
//   let d2 = new Date(b.dob);
//   // always when you want to get time from instance (d1,d2) of Date constructor (Date)
//   // use d1.getUTCDate() instead of d1.getDate() because when you create instances (d1,d2)
//   // without adding time will add default T00:00:00Z and if you live in region time less 
//   // than UTC so when you try to use d1.getDate() the day will be less 
//   //  like 1993-02-15T00:00:00Z =>   1993-02-14T20:00:00EST but using d1.getUTCDate() will not

//   log(d1.getDate(), d1.getUTCDate(), d1.getMonth(), d1.getUTCMonth());
//   if (d1.getUTCMonth() > d2.getUTCMonth()) {
//     return 1;
//   } else if (d1.getUTCMonth() < d2.getUTCMonth()) {
//     return -1;
//   } else {
//     //same month
//     return d1.getUTCDate() - d2.getUTCDate();
//   }
// }

// Custom Sorting solve this problem
// let nums = [44,91,34,12,19,100]
// let sortedNums = nums.sort()
// console.log(sortedNums) // (6) [100, 12, 19, 34, 44, 91]
// let customSorted = nums.sort((a,b)=>a-b)
// console.log(customSorted) // (6) [12, 19, 34, 44, 91, 100]

// ---------------------------flat() with level -----------------
//Array.prototype.flat() to flat multi dimension array
// let numbers = [
//   1,
//   2,
//   [3, 4, 5],
//   [6, 7],
//   8,
//   9,
//   [
//     [10, 11],
//     [12, 13],
//   ],
// ];
// // level number
// let arr1 = numbers.flat(); // default flat(1)
// let arr2 = numbers.flat(2);
// console.log(arr1); // [1, 2, 3, 4, 5, 6, 7, 8, 9, Array(2), Array(2)]
// console.log(arr2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] 

// -------------------------------------Array.prototype.flatMap()-----------------

// Array.prototype.flatMap()  equivalent to  myArray.map().flat(1)

// let movies = [
//   'Dog Soldiers',
//   ['In Bruges', 'From Paris with Love', 'Layer Cake'],
//   'The Big Lebowski',
//   '',
//   '    ',
//   'Memento, The Platform,Fight Club, ',
//   'Hotel Rwanda, Moon, Under the Skin',
//   'Lady Bird',
//   ['Platoon', 'Wall-E'],
// ];
// let arr = movies.flatMap((entry) => {
//   if (Array.isArray(entry)) {
//     return entry;
//   } else if (typeof entry === 'string' && entry.trim() === '') {
//     // this to remove '','    ', because when you return [] and use flat() flat will remove rempty arr
//     return []; //remove the empty strings
//   } else {
//     //other strings
//     return entry
//       .split(',')
//       // this to remove space before , The Platform,
//       .map((txt) => txt.trim())
//       // this to , ' after Fight Club
//       .filter((txt) => txt != '');
//   }
// });
// console.log(arr);

// --------------------------------Memoization----------------------------------

/**
 * Memoization - save the results of your function
 * to improve performance.

custom function if you give it same arguments instead if run the function again it will give
you the result saved in memo object 
 */

// const myFunc = (function buildFunc() {
//   const memo = {};
//   return (args) => {
//     //this is the function that will be myFunc
//     let key = getKey(args);
//     if (memo[key]) {
//       return memo[key];
//     } else {
//       let sum = 0;
//       for (let i = args[0]; i > 0; i--) {
//         sum += args[0] * args[1];
//       }
//       memo[key] = sum;
//       return sum;
//     }
//   };
// })();
// const getKey = ([a, b]) => {
//   //we are always expecting to get two values
//   let key = `${a}-${b}`;
//   return key;
// };


// here same arguments
// let start = Date.now();
// let result1 = myFunc([9000008, 100001]);
// let result2 = myFunc([9000008, 100001]);
// let result3 = myFunc([9000008, 100001]);
// let result4 = myFunc([9000008, 100001]);
// let result5 = myFunc([9000008, 100001]);
// let result6 = myFunc([9000008, 100001]);
// let result7 = myFunc([9000008, 100001]);
// let end = Date.now();
// console.log(end - start); // will give you time less than next version

// // here different arguments
// start = Date.now();
// result1 = myFunc([9000001, 100001]);
// result2 = myFunc([9000002, 100001]);
// result3 = myFunc([9000003, 100001]);
// result4 = myFunc([9000004, 100001]);
// result5 = myFunc([9000005, 100001]);
// result6 = myFunc([9000006, 100001]);
// result7 = myFunc([9000007, 100001]);
// end = Date.now();
// console.log(end - start);

// ------Dynamic Object properties-------
// let obj = {}
// let str = "Soliman"
// let str2 = "hussein"
// // here will take "str" itself as name of key
// obj.str = "test"
// // using [] will take value of variable str as name of key
// obj[str] = "test2"
// console.log(obj)
// // you can add variable directly to object and name of variable will be the key of the property 
// // and value of variable will be the value of property this called (Property value Shorthand )
// let obj2 = {str,str2}
// console.log(obj2)

// function addProp(obj,prop,value){
//   obj[prop] = value
//   // if we use obj.prop will create property key called prop (will not use prop argument)
//   obj.prop = "Mohamed"
// }
// addProp(obj,"str3","Ahmed")
// console.log(obj)

// --------------------?? nullish coalescing operator--------------------
// // in ternanry operator if truthy value => Yes if falsy value => No
// // in nullish coalescing operator if null or undefined(not all falsy value) return value after ?? if not null or 
// // undefined return that value
// let result1 = null ? "Yes" : "No" 
// let result2 = null  ?? "Yes" 
// let x = 10;
// let result3 = x ?? "Yes" 
// x = NaN
// let result4 = x ?? "Yes"
// console.log(result1) // No
// console.log(result2) // Yes
// console.log(result3) // 10
// console.log(result4) // NaN because x is NaN (falsy but not null or undefined)

// // exp. of using nullish coalescing operator inside function
// let current;

// function f(){
//   let result = current ?? getNum() // because current in undefined so will invoke getNum()
//   console.log(result)
// }

// function getNum(){
//   current = Math.floor(Math.random() * 100)
//   return current
// }

// f()

// ---------------------tagged template literal ------------------
// template literal is using ``

// let num = 41;
// let str1 = `"\t" and "\n" are escape sequences. ${num}`;
// let str2 = `"\\t" and "\\n" are escape sequences. ${num}`;
//  // instead of using escape sequences you can use tring.raw before ``
// let str3 = String.raw`"\t" and "\n" are escape sequences. ${num}`;
// // &{} inside can be variable or expression
// let str4 = `The meaning of life is ${num + 1}.`;
// const log = console.log;

// // log(1, str1);
// // log(2, str2);
// // log(3, str3);
// // log(4, str4);

// let first = 'ham';
// let second = 'pineapple';
// let txt = f`I don't like pizza with ${first} and ${second}.`;
// log(txt);
// function f(strings, ...expressions) { // strings or expression is array
//   // return strings 
//   // return expressions
//   // return `I don't like pizza with ${expressions[0]} and ${expressions[1]}.`
//   // return `I don't like pizza with ${expressions.join(" and ")}.`
//   return expressions.reduce((acc, exp, idx) => {
//     return acc + exp.toUpperCase() + strings[idx + 1];
//   }, strings[0]);
// }


//--------------------Identifiers and IdentifierNames in JavaScript--------------
  /*************
   * //Reserved keywords
   * break, case, catch, class, const, continue, debugger, default, delete, do, else,
   * export, extends, finally, for, function, if, import, in, instanceof, new, return,
   * super, switch, this, throw, try, typeof, var, void, while, with, yield,
   * enum, true, false, null,
   *
   * //In strict mode
   * implements, interface, let, package, private, protected, public, static
   *
   * //In modules
   * await
   *
   * //In older versions of ECMAScript
   * abstract, boolean, byte, char, double, final, float, goto, int, long, native,
   * short, synchronized, throws, transient, volatile
   */

// var $;
// let _;
// let aas;
// let abc1;
// let $as3423d_;
// let abc123_ = 'something';
// const STEVE = Symbol();

// // with object you can number as key because it will converted to string anyway
// let obj = {
//   $: 'a',
//   _: 'b',
//   abc: 'c',
//   [abc123_]: 'd',
//   [STEVE]: 'e',
//   1: 'f',
//   '1.213423': 'g'
// };

// ----------------------------type casting and coercing in JavaScript----------------
//
// String(), +, Number(), +, -, Boolean(), !, !!
// toString(), valueOf()
// parseInt(), parseFloat()
// unary plus, logical NOT, addition operator, comparison operators
// let log = console.log;
// let n = '56';
// //log(-n, +n);
// //                              String,         Number,       Boolean
// let obj = { a: 1, b: 2 }; // '[object Object]'    NaN           true
// let emptyObj = {}; //        '[object Object]'    NaN           true
// let arr = [1]; //            '1'                  1             true 
// let arr2 = [1, 2, 3]; //     '1,2,3'              NaN           true 
// let emptyArr = []; //        ''                   0             true
// let str = 'hello'; //        'hello'              NaN           true
// let emptyStr = ''; //        ''                   NaN           false   ('43'=>43, '0'=>0)
// let num = 1; //              '1'                  1             true
// let zero = 0; //             '0'                  0             false
// let T = true; //             'true'               1             true
// let F = false; //            'false'              0             false
// //  null    //               'null'               0             false
// //  undefined   //           'undefined'          NaN           false
// //  NaN       //             'NaN'                NaN           false


/**
 * Plus vs Concatenation
 * exp1 + exp2
 * if either exp1 or exp2 is a string then treat the '+' as a concatenation
 *  coerce both values to Strings as needed
 *
 * if neither exp1 or exp2 is a string then treat the '+' as an addition operation
 *  coerce both values to Numbers as needed
 *
 */

//log(F + num);
//"234234".toLowerCase()
// Falsey values - false, 0, '', null, undefined, NaN
// Truthy values - Everything else....
// Boolean() != new Boolean(), String() != new String(), Number() != new Number()
// Boxing of Primitives
// Boolean() == !!  (! will flip truthiness too) // log(!!0)
// Number() == +  (- will flip sign too) // log(-"1")
// String() == .toString() unless null or undefined (toString will throw an Error)

// log(Boolean(234), Boolean(0), new Boolean(0));
// log(true && Boolean(new Boolean(0)));

// && compares the two operands and then actually returns
// the second if the first is truthy

// Operator Precedence
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

// log(!arr < +T || !!arr > +emptyArr);
//unary plus 17, logical NOT 17, less than 12, greater than 12, logical OR 6
// (false < 1 || true > 0)
// ( 0 < 1 || 1 > 0 )
// ( true || )
// true

/* look at the link + will work from right to left and check 
=> if + between 2 numbers will be addition 
=> if one of them string will be concatenate
=>  one oe them neither number or string will be unary plus */
// log(1 + - + + + - +1); //2

// -----------------------Premissions with Bitwise-----------------------------
/**
 * Using a single integer to represent multiple permissions
 * based on binary values using bitwise operators
 *
 *  & bitwise AND - if both the top and bottom bit are 1, result is 1
 *  | bitwise OR - if either the top and bottom bit or both are 1, result is 1
 *  ^ bitwise XOR - if only one of the bits are 1, result is 1
 * 0101
 * 0100 & =   0100
 *
 * 0100
 * 1110 | = 1110
 *
 * 0101
 * 0001 ^ = 0100
 *
 * 0 - 0000
 * 1 - 0001 x
 * 2 - 0010 x
 * 3 - 0011
 * 4 - 0100 x
 * 5 - 0101
 * 6 - 0110
 * 7 - 0111
 * 8 - 1000 x
 * 9 - 1001
 * 10 - 1010
 */

//  const READ = 1; //   0001
//  const DRINK = 2; //  0010
//  const SING = 4; //   0100
//  const DELETE = 8; // 1000

// class Person {
//   constructor(name, access = 0) {
//     this.name = name;
//     this.access = access;
//   }
//   getAll() {
//     return {
//       [READ]: !!(this.access & READ),
//       [DRINK]: !!(this.access & DRINK),
//       [SING]: !!(this.access & SING),
//       [DELETE]: !!(this.access & DELETE),
//     };
//   }
//   addPerm(perm) {
//     this.access = this.access | perm;
//   }
//   removePerm(perm) {
//     if (this.getAll()[perm]) {
//       this.access = this.access ^ perm;
//     }
//   }
// }

// let steve = new Person('Steve', 5);
// let joanne = new Person('Joanne');
// joanne.addPerm(DRINK);
// joanne.addPerm(SING);
// joanne.addPerm(DELETE);
// steve.addPerm(SING);

// joanne.removePerm(READ);
// steve.removePerm(READ);

// console.log(steve.access, steve.getAll());
// console.log(joanne.access, joanne.getAll());

// console.log(steve.getAll()[READ]);
// console.log(joanne.getAll()[READ]);

// ----------------------globalThis-----------------
// in node.js version will not add var to window object but will be added to global object
// varaible without keyword like (n) will be added to global object in both

//-----node.js version 

// let l = 10;
// var v = 20;

// (function(){
//   n = 30;
//   console.log(this)
//   console.log(global)
//   console.log(globalThis)
//   console.log(globalThis.l) // undefined
//   console.log(globalThis.v) // undefined
//   console.log(globalThis.n) // 30
// })();

// // ---browser version

// (function(){
//   n = 30;
//   console.log(this)
//   console.log(window)
//   console.log(globalThis)
//   console.log(globalThis.l) // undefined
//   console.log(globalThis.v) // 20
//   console.log(globalThis.n) // 30
// })();


// -------------------slice vs splice-------------- 
/*
slice return shallow copy of original array
splice return deleted part and cahnge original array
*/

// //[1] Slice
// let arr = [1,2,3,4]
// let arrSlice = arr.slice()
// arrSlice[0] = 5
// console.log(arr) // [1,2,3,4]
// console.log(arrSlice) // [5,2,3,4]

// //[2] Splice
// let arr2 = [1,2,3,4]
// let arrSplice = arr2.splice(0,4,5,6,7,8)
// console.log(arrSplice) // [1,2,3,4] return deleted part
// console.log(arr2) // change original array

// -------------------------Record and Tuples (new)-------------------
/*
Tuple like Array ----------Record like Object
let tuple = #[1,2,3]
let record = #{a:1, b:2, c:3}

- Tuple and Record are primitive value so thy are assigned by value not reference
- Tuple and Record are immutable but Array and Object mutable
- nesting:  only primitive value allowed to be nested you can not add normal array inside tuple
but you can add tuple or any another primitive value inside it
let tuple = #[1,2,3,#[4,5]]
- JSON.parseImmutable() like JSON.parse but return tuple or Record instead of array or Object
- because they are primitive they have wrapper Object to have methods(Boxing) but some methods
that change the original array will be replaced to another method for exp. push will be replaced
with pushed and return a new array not changing the original one
 */

// let obj = {
//   fName : "Mohamed",
//   get getterMethod(){
//     return "Shekmo"
//   },
//   set setterMethod(newName){
//     return this.fName = newName
//   }
// }
// console.log(obj.getterMethod) // Shekmo
// obj.setterMethod = "Ahmed"
// console.log(obj.fName) // Ahmed

// let obj2 = {
//   mName : "Soliman",
//   get(){
//     return "Shekmo"
//   },
//   set(){
//     return "Shemko"
//   }
// }
// console.log(obj2.mName) // Soliman

// let obj3 = {
//   lName : "Hussein"
// }

// let handler = {
//   get(target,prop,reciver){
//     console.log(target)
//     target[prop] =  "get Shekmo"
//   },
//   set(target,prop,reciver){
//     target[prop] = reciver
//   }
// }

// let myProxy = new Proxy(obj3,handler)
// console.log(obj3.lName) // Hussein
// console.log(myProxy.lName) // get Shekmo
// myProxy.lName = "Set Shekmo" // trigger set
// console.log(myProxy.lName) // get Shekmo only trigger get not give you the value after set
// console.log(obj3.lName) // Set Shekmo

// --------------------------------------Proxy------------------------------

/*
The Proxy object allows you to create an object that can be used in place of the original 
object, but which may redefine fundamental Object operations like getting, setting, 
and defining properties. Proxy objects are commonly used to log property accesses, validate, 
format, or sanitize inputs, and so on.
*/

// let obj = {a:"Mohamed",b:"Ahmed",c:"Soliman"}
// let handler = {
//   get : function(target,prop,reciver){
//     // console.log(target) // obj
//     // console.log(prop) // property inside obj
//     // console.log(reciver) // proxy
//     if(prop in target){
//       return target[prop].toUpperCase() // make changes to property using proxy
//     }else{
//       return " No Such Prop in Object"
//     }
//   },
//   set : function(target,prop,reciver){
//     // console.log(target) // obj
//     // console.log(prop) // property inside obj
//     // console.log(reciver) // the new value passed to property
//     if(prop in target){
//       console.log("Editing old property")
//       target[prop] = reciver.toLowerCase()
//     }else{
//       console.log("Creating new property")
//       target[prop] = reciver.toLowerCase()
//     }
//   },
//   ownKeys : function(){
//     return ["ONE"]
//   }
// }
// let proxy = new Proxy(obj,handler)
// // console.log(proxy.a)
// // console.log(proxy.d)
// proxy.a = "MIDO"
// proxy.d = "HUSSEIN"
// console.log(obj)
// console.log(Object.getOwnPropertyNames(proxy)) // trap for handler.ownKeys()

// ---using IIFE to protect original object and not changing it
// let obj = {a:"Mohamed",b:"Ahmed",c:"Soliman"}
// let objIffe = (function(myObj){
//   let handler = {
//     get: function(target , prop, reciver){
//       if(prop in target){
//         console.log("getting old property")
//         // return target[prop].toUpperCase() // make changes to property using proxy
//         return Reflect.get(target,prop,reciver).toUpperCase()
//       }else{
//         return " No Such Prop in Object"
//       }
//     },
//     set: function(target , prop, reciver){
//       if(prop in target){
//         target[prop] = reciver.toLowerCase()
//         console.log("Editing old property",myObj) // here will change property of myObj not original obj
//       }else{
//         target[prop] = reciver.toLowerCase()
//         console.log("Creating new property",myObj) // here will add property to myObj not original obj
//       }
//     }
//   }
//   return new Proxy(myObj,handler)
// })({a:"Mohamed",b:"Ahmed",c:"Soliman"}); // if we pass obj as parameter => original object will be changed
// objIffe.a = "Mido"
// console.log(objIffe.b)
// console.log(obj) // original object will not be changed

// how to validate age using proxy
// let objects = [
//   {id:123,name:"Mohamed",age:33},
//   {id:456,name:"Ahmed",age:-34},
//   {id:789,name:"Soliman",age:135}
// ];
// objects = objects.map(person=> new Proxy(person,{
//   get : function(target,prop,reciver){
//     if(prop in target){
//       if(prop === "age" && target[prop] > 0 && target[prop] < 130){
//         // return target[prop]
//         return Reflect.get(...arguments) // like Reflect.get(target,prop,reciver)
//       }else{
//         throw new RangeError("Age Is Not Valid")
//       }
//     }
//   },
//   set : function(target,prop,reciver){
//     return true
//   }
// }))
// objects.forEach(person=>{
//   try{
//     console.log(person.age)
//   }catch(err){
//     console.log(err.name, err.message)
//   }
// })

// ---proxy with function
// let fContext = {a : 7}
// let sum = function (a,b){
//   return a + b
// }
// let proxyFunc = new Proxy(sum,{
//   apply: function(target,thisArg,args){
//     // console.log(target) // sum function
//     // console.log(thisArg) // fContext => from bind() or call()
//     // console.log(args) // arguments 
//     return sum(thisArg.a,...args) * 10
//   }
// }).bind(fContext) // you can use bind() here or use call() when you call proxyFunc
// console.log(sum(1,2)) // 3
// console.log(proxyFunc(2)) // 90
// console.log(proxyFunc.call(fContext,2)) // 90

// --------------------Hnadler Functions-------------------
/*
Handler functions
This section lists all the handler functions you can define. Handler functions are sometimes called traps, because they trap calls to the underlying target object.
handler.apply()
A trap for a function call.
handler.construct()
A trap for the new operator.
handler.defineProperty()
A trap for Object.defineProperty.
handler.deleteProperty()
A trap for the delete operator.
handler.get()
A trap for getting property values.
handler.getOwnPropertyDescriptor()
A trap for Object.getOwnPropertyDescriptor.
handler.getPrototypeOf()
A trap for Object.getPrototypeOf.
handler.has()
A trap for the in operator.
handler.isExtensible()
A trap for Object.isExtensible.
handler.ownKeys()
A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
handler.preventExtensions()
A trap for Object.preventExtensions.
handler.set()
A trap for setting property values.
handler.setPrototypeOf()
A trap for Object.setPrototypeOf.
*/

// -------------------Reflect Object-----------------
// The Reflect object provides the following static functions which have the same names as the proxy handler methods.
// Used with Proxy and help to write dynamic code (you can control objects by passing them as argument to reflect)
// console.log(Reflect)
// Reflect Object - built-in object that provides methods for interceptable JavaScript operations
// All methods are static
// has no constructor cannot use `new`
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect
// const log = console.log;

// let alex = {
//   name: 'Alex',
//   id: 93,
//   hello: function (a, b) {
//     console.log(`Hello my name is ${this.name}. ${a} ${b}`);
//   },
// };

// log(Reflect.ownKeys(alex));
// log(Reflect.get(alex, 'id'));
// log(Reflect.set(alex, 'id', 94));
// log(Reflect.get(alex, 'id'));
// log(Reflect.has(alex, 'name'));
// Reflect.apply(alex.hello, alex, Reflect.ownKeys(alex));
// Reflect.defineProperty(alex, 'age', { value: 30, enumerable: false });
// log(Reflect.get(alex, 'age'));

/**
Reflect.apply(targetFunc, thisArg, argList); //for functions
Reflect.get(target, key, handler); //handler is Proxy. get the value of a property
Reflect.set(target, key, value, handler); //handler is Proxy. set the value of a property
Reflect.has(target, key); // check if it has a property
Reflect.delete(target, key); //like the delete operator
Reflect.ownKeys(target); // enumerate through the properties
Reflect.defineProperty(target, key, {propertyDescriptor}); //like Object.defineProperty
 */

// ---------------------Destructring with promise and array Methods-----------------
/*
Destructuring allows us to see inside an object
or array when it is being passed to a function.

This can be combined with calls to Array methods
and Promise.then methods to great effect.
*/
// const log = console.log;
// let people = [
//   { id: 1, name: 'Leonard', phd: true, partner: 'Penny' },
//   { id: 2, name: 'Howard', phd: false, partner: 'Bernadette' },
//   { id: 3, name: 'Sheldon', phd: true, partner: 'Amy' },
//   { id: 4, name: 'Raj', phd: true, partner: 'Cinnamon' },
// ];
// let nums = [12, 34, 56, 78, 90];

// let n = nums.map((number) => {
//   log(number);
// });
// let ppl = people.map(({ name: nm, partner: pt }) => {
//   log(nm, '&', pt);
// });

// let url = 'http://jsonplaceholder.typicode.com/users'
// fetch(url)
//   .then((resp) => {
//     if (!resp.ok) throw new Error(resp.statusText);
//     // Error This error means you have resolved the promise (in this case, you use resp.json()) more than once.
//     // console.log(resp.json()) 
//     return resp.json();
//   })
//   .then(([first, {name:secondName}, ...rest]) => {
//     //...rest MUST be the last argument for desctructuring
//     // rest[rest.length-1] would be the last element.
//     log(first);
//     log(secondName);
//   })
//   .catch(log);

// ---------------------Reducer Function--------------------
/*
Context for non-Archer fans
https://www.youtube.com/watch?v=4IUNc6yxp2g
https://www.youtube.com/watch?v=8FYJfEHOuY0
*/
// const log = console.log;

// const reducer = (state, action) => {
//   if (action === 'DARKEN') {
//     return state + 'er';
//   }
//   if (action === 'LIGHTEN') {
//     return state.replace('er', '');
//   }
//   return state;
// };

// let dark = 'dark';
// dark = reducer(dark, 'DARKEN');
// log(dark);
// dark = reducer(dark, 'LIGHTEN');
// log(dark);

// const reducer = (state, action) => {
//   switch (action.type) {
//     case 'DARKEN':
//       if (state.agent === 'Archer' && state.turtleneckType === 'tactical') {
//         return {
//           ...state,
//           turtleneckBlackness: state.turtleneckBlackness + 10,
//         };
//       }
//       if (state.agent !== 'Archer') {
//         return state;
//       }
//     case 'LIGHTEN':
//       return state;
//   }
//   return state;
// };

// let state = {
//   agent: 'Archer',
//   turtleneckType: 'tactical',
//   turtleneckBlackness: 100,
// };
// state = reducer(state, { type: 'DARKEN' });
// state = reducer(state, { type: 'DARKEN' });
// state = reducer(state, { type: 'DARKEN' });
// log(state);

// ----------------------Curring & partial Function & Closure------------------------
/**
 * Currying vs Partial Application
 * Closures
 *   A function which returns a function that
 *   can has access to the returned function's scope.
 *   function example(param){
 *     let a = 123;
 *     return function(otherParam){
 *       //both param and otherParam and a are available here
 *     }
 *   }
 *
 * Partial Application
 *   Uses closures.
 *   Partial application starts with a function. 
 *   We take this function and create a new Function with one or more of its arguments
 *   
 *
 * Currying
 *   The process of taking a multiple argument function and
 *   breaking it up into a series of single argument partially
 *   applied functions.
 */
// const log = console.log;

//  //Simple demo - the things we would want to curry
// function bakeChocolateCupcakeWithVanilla(cakeType, cakeFlavor, icingType) {
//   return `Made a ${cakeFlavour} ${cakeType} with ${icingType} icing.`;
// }
// function bakeVanillaCakeWithLemon(cakeType, cakeFlavor, icingType) {
//   return `Made a ${cakeFlavour} ${cakeType} with ${icingType} icing.`;
// }
//  //curry it
// function bake(cakeType) {
//    //partially applied
//   return function (cakeFlavour) {
//      //partially applied
//     return function (icingType) {
//       return `Made a ${cakeFlavour} ${cakeType} with ${icingType} icing.`;
//     };
//   };
// }
// let bakeCake = bake('cake');
// let bakeCupcake = bake('cupcake');
// let bakeMuffin = bake('muffin');

// let chocCake = bakeCake('chocolate');
// let vanillaCake = bakeCake('vanilla');
// let chocCupcake = bakeCupcake('chocolate');
// let carrotMuffin = bakeMuffin('carrot');

 // log(chocCake('strawberry'));
 // log(chocCake('vanilla'));
 // log(chocCupcake('chocolate'));
 // log(chocCupcake('orange'));

 // log(bake('cake')('chocolate')('vanilla'));
 // log(bake('cupcake')('chocolate')('cherry'));
 // log(bake('muffin')('carrot')('vanilla'));

 //More realistic example
// import fetch from 'node-fetch';

/**
  * Possible resources are posts, comments, albums, photos, todos, and users
  * @param {string} endpoint which resource to get from http://jsonplaceholder.typicode.com/
  * @returns {function} partially applied function
  */
// let jsonPlaceholder = async (endpoint) => {
//   let url = `http://jsonplaceholder.typicode.com/${endpoint}`;
//   let resp = await fetch(url);
//   let data = await resp.json();
//   return (num) => {
//     return data
//       .slice(0, num)
//       .map((item) => {
//         let label = item.name || item.title;
//         return `<p>${endpoint} :: ${label}</p>`;
//       })
//       .join('\n');
//   };
// };

// const sleep = (milliseconds) => {
//   return new Promise((resolve) => setTimeout(resolve, milliseconds));
// };

// async function init() {
//   let posts = await jsonPlaceholder('posts');
//   let users = await jsonPlaceholder('users');
//   await sleep(5000)
//   log(posts(2));
//   log(users(4));
// }
// init()

// ------------------------DOM by Steve Griffith-----------------

// ----------getAttributeNode vs getAttribute-----------
// let div = document.getElementById("hello")
// let idNode = div.getAttributeNode("id")
// let idValue = div.getAttribute("id")
// console.log(idNode.nodeType) // 2
// console.log(idValue) // hello

// ------------childeren vs childNodes vs childElementCount----------
// let div = document.querySelector(".childCount")
// console.log(div.childNodes.length) // 5 will count elements and also txt nodes and carriage return \n
// console.log(div.children.length) // 2 will count only elements
// console.log(div.childElementCount) // 2 will count only elements

// -------------contains------------
// accept node as argument and return boolean
// let div = document.querySelector(".test")
// let txt = div.childNodes[0]
// let txt2 = "test"
// console.log(div.contains(txt)) // true
// console.log(div.contains(txt2)) // Error passing string not node to contains

// ---------insertBefore and replaceChild and cloneNode
// let ul = document.querySelector("ul")
// let two = ul.children[1]
// let three = ul.children[2]
// let addLi = document.createElement("li")
// addLi.textContent = "before Two"
// let replaceli = document.createElement("li")
// replaceli.textContent = "replace three"
// // 1st param is the element we want to add and 2nd param is the element we want to add before
// ul.insertBefore(addLi,two) // this not like two.prepend(addLi) because prepend will add (addLi) inside two element not before it
// // 1st param is new element to replace the old element(2nd param)
// ul.replaceChild(replaceli,three)

// let cloneUl = ul.cloneNode(false)
// let cloneUlAndChilds = ul.cloneNode(true)
// console.log(cloneUl) // clone only ul element without it's childs
// console.log(cloneUlAndChilds) // clone ul and it's childs

// ---------getComputedStyle----------
// let div = document.querySelector(".css")
// let style = window.getComputedStyle(div)
// console.log(style.length)
// console.log(style.item(200))
// console.log(style.getPropertyValue("color"))

// ------------------fetch using a Request and a Headers objects--------------

// //using jsonplaceholder for the data

// const uri = 'http://jsonplaceholder.typicode.com/users';

// //new Request(uri)
// //new Request(uri, options)
// //options - method, headers, body, mode
// //methods:  GET, POST, PUT, DELETE, OPTIONS

// //new Headers()
// // headers.append(name, value)
// // Content-Type, Content-Length, Accept, Accept-Language,
// // X-Requested-With, User-Agent
// let myHeader = new Headers();
// myHeader.append('Accept', 'application/json'); // here we are accepting only json files

// let req = new Request(uri, {
//     // if we use POST the JSON file will be {id:11} because no. of users from uri is 10 
//     // and using POST means add new data to server and add user no. 11
//     method: 'GET', 
//     headers: myHeader,
//     mode: 'cors' // means policy (what you are allowed to do)
// });

// fetch(req) 
//     .then( (response)=>{
//         if(response.ok){
//             return response.json();
//         }else{
//             throw new Error('BAD HTTP stuff');
//         }
//     })
//     .then( (jsonData) =>{
//         console.log(jsonData);
//     })
//     .catch( (err) =>{
//         console.log('ERROR:', err.message);
//     });

// --------------------------------GeoLocation-------------------------
// geolocation.js
// How to use Navigator.geolocation
//
// let G, options, spans;

// document.addEventListener('DOMContentLoaded', init);

// function init(){
//     if(navigator.geolocation){
//         let giveUp = 1000 * 30;  //30 seconds
//         let tooOld = 1000 * 60 * 60;  //one hour
//         options ={
//             // HighendAccurcy => to use GPS but will drain the battery of user’s device ( you can use wifi to get location ) 
//             enableHighAccuracy: true,
//             // Timeout => for how long you need the browser to try to get the location 
//             timeout: giveUp,
//             // MaximumAge => when the browser fetch it will take information that cached from last time like location and in MaximumAge you determin 
//             // For how long the location valid and no need to update it 
//             // For exp. You can but update location every 24 hrs or every 5 mins 
//             maximumAge: tooOld
//         }
//         // Accept 3 parameters => 1st parameter is success Function and 2nd parameter is fail Function  and 3rd parameter is options
//         navigator.geolocation.getCurrentPosition(gotPos, posFail, options);
//     }else{
//         //using an old browser that doesn't support geolocation
//     }
// }

// function gotPos(position){
//     spans = document.querySelectorAll('p span');
//     spans[0].textContent = position.coords.latitude;
//     spans[1].textContent = position.coords.longitude;
//     spans[2].textContent = position.coords.accuracy;
    
//     spans[6].textContent = position.timestamp;
// }

// function posFail(err){
//     // fail function accept err as number => 
//     // 1 : permission to access location denied by browser 
//     // 2 : can not determine the Location 
//     // 3 : take too long to determine the location (after timeout from options object ) 
//     let errors = {
//         1: 'No permission',
//         2: 'Unable to determine',
//         3: 'Took too long'
//     }
//     document.querySelector('h1').textContent = errors[err];
// }

// ---------------------Real World Ajax Fetch to Live HTML and CSS-------------------------

//fetch user data from jsonplaceholder 
//generate a user list on the web page
//add a click event to the body that will
//refresh the list each time with a random 
//number of users

// const uri = 'http://jsonplaceholder.typicode.com/users';

// let req = new Request(uri, {
//     method: 'GET',
//     mode: 'cors'
// });

// fetch(req)
//     .then( (response)=>{
//         if(response.ok){
//             return response.json();
//         }else{
//             throw new Error('BAD HTTP!');
//         }
//     })
//     .then( (jsonData) =>{
//         //console.log(jsonData);
//         let ul = document.querySelector('#users');
//         let df = new DocumentFragment();
//         jsonData.forEach( (user) =>{
//             let li = document.createElement('li');
//             let pn = document.createElement('p');
//             let pue = document.createElement('p');
//             pn.textContent = user.name;
//             pue.textContent = ''.concat(user.username, ' - ', user.email);
//             pn.className = 'name';
//             pue.classList.add('info');
//             li.appendChild(pn);
//             li.appendChild(pue);
//             df.appendChild(li);
//         });
//         ul.appendChild(df);
//     })
//     .catch( (err) =>{
//         console.log('ERROR:', err.message);
//     });

//----------------------Real Life Temp Forcast------------------

// load the sample weather JSON data
// build a grid of temps over the next 24 hours
// blue background in hours where percipitation possibility is higher than 70%

// let uri = 'json/darksky-sample.json';
// let req = new Request(uri, {method:'GET'});
// let container, df;

// document.addEventListener('DOMContentLoaded', init);

// function init(){
//     container = document.getElementById('container');
//     df = new DocumentFragment();
    
//     fetch(req)
//     .then((response)=>{
//         if(response.ok){
//             return response.json();
//         }else{
//             throw new Error('BAD HTTP');
//         }
//     })
//     .then((json)=>{
//         //create the weather grid
//         json.hourly.data.forEach((hour)=>{
//             //to show the temp
//             let div = document.createElement('div');
//             div.classList.add('hour');
//             let timestamp = hour.time;
//             div.id = 'ts_' + timestamp.toString();
//             let temp = parseInt(hour.temperature);
//             div.textContent = temp.toString().concat('\u00B0');
//             div.title = hour.summary;
            
//             //to show the time
//             let span = document.createElement('span');
//             let timmy = new Date(timestamp * 1000);
//             span.textContent = timmy.getHours().toString().concat(":00");
            
//             div.appendChild(span);
//             df.appendChild(div);
//         });
//         container.appendChild(df);
        
//         //highlight the times when it will be raining
//         json.hourly.data.filter((hour)=>{
//             if(hour.precipProbability > 0.5){
//                 return true;
//             }
//             return false;
//         }).map((hour)=>{
//             return hour.time;
//         }).forEach((timestamp)=>{
//             let id = 'ts_'.concat(timestamp);
//             document.getElementById(id).classList.add('precip');
//         });
        
//         //highest temp
//         let highObj = json.hourly.data.reduce((accumulator, hour)=>{
//             if(hour.temperature > accumulator.temp){
//                 return {temp: hour.temperature, time: hour.time};
//             }else{
//                 return accumulator;
//             }
//         }, {temp:-100, time:1000})
//         let id = 'ts_' + highObj.time;
//         document.getElementById(id).classList.add('hot');
//     })
//     .catch((err)=>{
//         console.log( err.message );
//     })
// }

// -----------------------CloneNode with HTML---------------
// const init = function(){
//   let t1, t2, div1, temp, div2, cln
//   t1 = document.getElementById('target1');
//   t2 = document.getElementById('target2');
  
//   temp = document.querySelector('[type="text/html"]');
//   cln = temp.cloneNode(true);
//   div2 = cln.textContent; // String
//   t2.innerHTML = div2; // because of innerHTML property will convert String to HTML elements

//   div1 = document.querySelector(".advertisement");
//   for(let i=0; i<5; i++){
//       // t1.appendChild(div1); // will move the div to target1
//       t1.appendChild(div1.cloneNode(true) ); // will take a copy and put it inside target1 and keep the original
//   }
// }

// document.addEventListener('DOMContentLoaded', init)

//  -------------------------Localhost = 127.0.0.1 = IP Address-----------------
/*
to try your html file on mobile phone:
you can change local host to your IP (you can get your IP from terminal by using ifconfig)
then connect you mobile phone to same wifi then open the link on your phone

or you can use MAMP application but here the phone not should be connected to same wifi
*/

// ---------------------------Vibration-----------------------------------
//check for the different versions of the vibrate api
// navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
// let div = document.getElementById("vibrate")
        
// if (navigator.vibrate) {
//     // vibration API supported
//     div.addEventListener('click', function(ev){
//             console.log('body clicked. Time to shake.');
//             //navigator.vibrate(1000); // miliseconds
//             // navigator.vibrate([500, 300, 100]); // vibarte stop vibrate
//             //navigator.vibrate(0); // stop 
//             navigator.vibrate([125,75,125,275,200,275,125,75,125,275,200,600,200,600]);
//         });
// }

/***
James Bond Theme
navigator.vibrate([200,100,200,275,425,100,200,100,200,275,425,100,75,25, 75,125,75,25,75,125,100,100]);

Super Mario Theme
navigator.vibrate([125,75,125,275,200,275,125,75,125,275,200,600,200,600]);

Darth Vader Theme
navigator.vibrate([500,110,500,110,450,110,200,110,170,40,450,110,200,110,170,40, 500]);
***/


// ------------------Online and Offline Events---------------
// window.addEventListener('online',  changeStatus);
// window.addEventListener('offline', changeStatus);
        
// document.addEventListener('DOMContentLoaded', function(){
// //check for the original starting status
//   if( navigator.onLine){ // navigator has built in property called online
//     changeStatus( {type:'online'} ); // here we are creating fake object whichs has type property to be like ev.type
//   }else{
//     changeStatus( {type:'offline'} );
//   }
// });
        
// function changeStatus(ev){
// //handle the change in status   ev.type online  offline
//   document.getElementById("status").textContent = ev.type.toUpperCase();
//   let img = document.createElement("img");
//   img.src = "https://picsum.photos/g/500/300?image=0&blur";
//   let p = document.querySelector('p.img');
//   p.className = "img";
//   if( ev.type == "online"){
//     p.classList.add('online');
//   }
//   p.textContent = "STATUS IS ".concat(ev.type.toUpperCase() );
// }


// ----------------------Adjacent---------------------
// let span = document.createElement('span');
// span.textContent = 'This is a span Element.';
// let html = '<span>HTML span in a String.</span>';
// let txt = 'This is just some text.'
// let p = document.querySelector('#para');
        
/* because we are dealing with element not just string we cannot insert same element at 2 
different location but it will move it but you have 2 options to solve this problem :
[1] use cloneNode(true) 
[2] use insertAdjacentHTML because it's just string */

// p.insertAdjacentElement('beforebegin', span);   //moved from original location
// p.insertAdjacentElement('afterend', span);
// p.insertAdjacentElement('afterend', span.cloneNode(true));
// document.body.insertAdjacentElement('afterbegin', span); // will be added at the beginning of webpage
// document.body.insertAdjacentElement('afterbegin', span.cloneNode(true)); // will be added at the beginning of webpage
        
// p.insertAdjacentHTML('beforebegin', html);
// p.insertAdjacentHTML('afterend', html);
// p.insertAdjacentText('afterbegin', txt);
// p.insertAdjacentText('beforeend', txt);
        
/*****************************************
let position = 'beforebegin' | 'afterbegin' | 'beforeend' | 'afterend'
Element.insertAdjacentHTML(position, htmlString);
Element.insertAdjacentElement(position, Element);
Element.insertAdjacentText(position, someText);
*****************************************/

// ------------------------Visibility change (move to another tab in browser)---------

//document.hidden  
//document.addEventListener('visibilitychange', myfunc)
//... webkitHidden            msHidden
//... webkitvisibilitychange  msvisibilitychange
// this to check if it supported in different versions of browsers
// let hidden, vChange;
// if( typeof document.hidden !== 'undefined'){
//   hidden = 'hidden';
//   vChange = 'visibilitychange';
// }else if(typeof document.webkitHidden !== 'undefined'){
//   hidden = 'webkitHidden';
//   vChange = 'webkitvisibilitychange';
// }else if(typeof document.msHidden !== 'undefined'){
//   hidden = 'msHidden';
//   vChange = 'msvisibilitychange';
// }else{
// //no support
//   hidden = null;
//   vChange = null;
// }

// if( hidden){
//   document.addEventListener(vChange, function(ev){
//   // like document.hidden but we are using hidden as variable to check will different browsers versions
//   console.log('visibilitychange', document[hidden]); 
//   if(document[hidden]){
//     //page has lost focus
//     //stop the audio or video
//   }else{
//     //page has regained focus
//     //start the audio or video
//   }
//   });
// }

// ----------------------------Upload file to server using Fetch------------------

//fetch using a Request and a Headers objects
// uploading an image along with other POST data
//using jsonplaceholder for the data

// a website to upload file to
// const url = 'https://postman-echo.com/post';

// document.addEventListener('DOMContentLoaded', init);

// function init(){
//     document.getElementById('btnSubmit').addEventListener('click', upload);
// }

// function upload(ev){
//     ev.preventDefault();    //stop the form submitting immediatly and wait to choose the file

//     //create any headers we want
//     let h = new Headers();
//     h.append('Accept', 'application/json'); //what we expect back
//     //bundle the files and data we want to send to the server
//     let fd = new FormData();
//     fd.append('user-id', document.getElementById('user_id').value);
    
//     // input element with type file (see HTML file) will have file inside it as array
//     let myFile = document.getElementById('avatar_img').files[0];
//     fd.append('avatar', myFile, "avatar.png"); // will be the name saved in server not the name of the file you uploaded
//     // $_FILES['avatar']['file_name']  "avatar.png" => this PHP
//     let req = new Request(url, {
//         method: 'POST',
//         headers: h,
//         mode: 'no-cors',
//         body: fd
//     });

//     fetch(req)
//         .then( (response)=>{
//             document.getElementById('output').textContent = "Response received from server";
//         })
//         .catch( (err) =>{
//             console.log('ERROR:', err.message);
//         });
// }


// --------------------Notification API-----------------------
//Notification objects have a close() method. SOME browser automatically close them.
//Notification Events - click, error, close, show
// if( 'Notification' in window){
    
//   if (Notification.permission === 'granted') {
//       // If it's okay let's create a notification
//       doNotify();
//   }else{
//       //notification == denied
//       Notification.requestPermission()
//           .then(function(result) {
//               console.log(result);  //granted || denied
//               if( Notification.permission == 'granted'){ 
//                   doNotify();
//               }
//           })
//           .catch( (err) => {
//               console.log(err);
//           });
//   }

// }
      
// function doNotify(){
//     let title = "The Title";
//     let t = Date.now() + 120000;    //2 mins in future
//     let options = { // not just a object it's options object passed to Notification constructor
//         body: 'Hello from JavaScript!',
//         data: {prop1:123, prop2:"Steve"},
//         lang: 'en-CA',
//         icon: './img/calendar-lg.png',
//         timestamp: t, // this prop to determine when notification appears (maybe not supported)
//         vibrate: [100, 200, 100] // vibration (maybe not supported)
//     }
//     let n = new Notification(title, options);

//     n.addEventListener('show', function(ev){
//         console.log('SHOW', ev.currentTarget.data);
//     });
//     n.addEventListener('close', function(ev){
//         console.log('CLOSE', ev.currentTarget.body); 
//     });
//     setTimeout( n.close.bind(n), 3000); //close notification after 3 seconds
// }
/*************
Note about actions param - used with webworkers/serviceworkers
actions: [
    {action: 'mail', title: 'e-mail', icon: './img/envelope-closed-lg.png'},
    {action: 'blastoff', title: 'Blastoff', icon: './img/rocket-lg.png'}]
*********************/

// ------------------------mouseOver-mouseOut vs mouseEnter-mouseLeave-----------

// Adding addEventListener to child <p> only NO Differences so far..
// document.querySelector('.enter p').addEventListener('mouseenter', entering);
// document.querySelector('.enter p').addEventListener('mouseleave', leaving);
// function entering(ev){
//     ev.currentTarget.style.borderColor = 'gold';
//     console.log('mouseenter p');
// }
// function leaving(ev){
//     ev.currentTarget.style.borderColor = 'black';
//     console.log('mouseleave p');
// }
// document.querySelector('.over p').addEventListener('mouseover', overing);
// document.querySelector('.over p').addEventListener('mouseout', outing);
// function overing(ev){
//     ev.currentTarget.style.borderColor = 'gold';
//     console.log('mouseover p');
// }
// function outing(ev){
//     ev.currentTarget.style.borderColor = 'black';
//     console.log('mouseout p');
// }

// Adding addEventListener to <div> parent also will make the difference
/*
Each time your mouse enters or leaves a child element, 
mouseover and mouseOut are triggered, but not mouseenter and mouseLeave.

=> with mouseOver-mouseOut (not good performance) 
when you move mouse from div to p will be considered as : 
1. moveOut from div
2. moveOver to p
3. moveOver again to div ( because of event bubbling) you can use ev.stopPropagation() to stop bubbling

when you move mouse from p to div will be considered as : 
1. moveOut from p 
2. moveOut from div ( because of event bubbling) you can use ev.stopPropagation() to stop bubbling
3. moveOver to div 
4. moveOut from div ( when me move mouse away)

=> with mouseEnter-mouseLeave (good performance) 
when you move mouse from div to p will be considered as :
1. mouseEnter to p
when you move mouse from p to div will be considered as : 
1 . mouseLeave from P
2. mouseLeave from div ( when me move mouse away)
*/
// document.querySelector('.enter').addEventListener('mouseenter', function(ev){
//     ev.currentTarget.classList.add('blue');
//     console.log('mouseenter div. Add blue.');
// });
// document.querySelector('.enter').addEventListener('mouseleave', function(ev){
//     ev.currentTarget.classList.remove('blue');
//     console.log('mouseleave div. Remove blue.');
// });

// document.querySelector('.over').addEventListener('mouseout', function(ev){
//   ev.stopPropagation()
//     ev.currentTarget.classList.remove('blue');
//     console.log('mouseout div. Remove blue.');
// });
// document.querySelector('.over').addEventListener('mouseover', function(ev){
//   ev.stopPropagation()
//     ev.currentTarget.classList.add('blue');
//     console.log('mouseover div. Add blue.');
//     //, ev.currentTarget.tagName, ev.target.tagName
// });

// -------------------focusin-focusout vs focus-blur----------------
/*
The events focusin and focusout are similar to mouseenter and mouseleave. They DO NOT bubble
The events focus and blur are similar to mouseover and mouseout.They DO bubble.

relatedtarget property will be available when you switch between 2 inputs
*/
// document.querySelector('.in-out input').addEventListener('focusin', goIn);
// document.querySelector('.in-out input').addEventListener('focusout', goOut);
// function goIn(ev){
//     ev.currentTarget.style.color = 'gold';
//     console.log('focusin input left');
//     if(ev.relatedTarget){
//         ev.relatedTarget.style.color = 'red';
//         console.log('Just left relatedTarget', ev.relatedTarget.id)
//     }
// }
// function goOut(ev){
//     ev.currentTarget.style.color = 'black';
//     console.log('focusout input left');
//     if(ev.relatedTarget){
//         console.log('Headed to relatedTarget', ev.relatedTarget.id);
//     }
// }

// document.querySelector('.focus-blur input').addEventListener('focus', doFocus);
// document.querySelector('.focus-blur input').addEventListener('blur', doBlur);
// function doFocus(ev){
//     ev.currentTarget.style.color = 'gold';
//     console.log('focus input right');
//     if(ev.relatedTarget){
//         ev.relatedTarget.style.color = 'red';
//         console.log('Just left relatedTarget', ev.relatedTarget.id)
//     }
// }
// function doBlur(ev){
//     ev.currentTarget.style.color = 'black';
//     console.log('blur input right');
//     if(ev.relatedTarget){
//         console.log('Headed to relatedTarget', ev.relatedTarget.id);
//     }
// }


// -------------------Touch Event-----------------
//touch events - touchstart, touchend, touchmove, touchcancel
//There is NO tap, doubletap, swipe, swipeleft, swiperight, rotate, pinch, or zoom
//You would have to create those events yourself by connecting to the touch events.
//work on devices that are touch capable
//No error on other devices because 'touchstart' is just a name like winlottery
//The event will probably just never happen on my laptop
// document.querySelector('p').addEventListener('touchstart', f);
// document.querySelector('p').addEventListener('touchend', f);
// document.querySelector('p').addEventListener('touchmove', f);

// function f(ev){
//     console.log( ev.touches, ev.type );
// }



// ------------------------------buitin EventHandler-----------------
// let obj = {
//   init: function (){
//       document.querySelector('#btn').addEventListener('click', this);
//       document.querySelector('#btn').addEventListener('focus', this);
//       document.querySelector('#btn').addEventListener('blur', this);
//   },
//   handleEvent: function(ev){ // this is builtin function so should be named handleEvent
//       switch(ev.type){
//           case 'click':
//               this.something(ev);
//               break;
//           case 'focus':
//               this.something(ev);
//               break;
//           case 'blur':
//               this.something(ev);
//               break;
//           case 'explode':
//               break;
//       }
//   },
//   something: function (ev){
//       //gets called by click event list
//       console.log('btn was', ev.type, '-ed.');
//   }
// }

// //get things started
// obj.init();


// --------------------------custom attribute-------------------
/**
dataset property names must:
1. start with "data-"
2. made of lowercase letters and hyphens, underscore, period, colon
In JavaScript reference them with getAttribute() or setAttribute()
OR dataset['property name']
OR dataset.propertyName where camelCase is used by removing the hyphen
NB: underscore, period and colon are left as-is
**/
// let h1 = document.querySelector('h1');
// let p = document.querySelector('p');

// console.log( h1.dataset ); // DomStingMap represent data for custom attributes added to elements.
// console.log( h1.dataset['time'] );
// console.log( h1.dataset.time );
// console.log( h1.getAttribute('data-time'));

// console.log( p.dataset );
// console.log( p.dataset['time-stamp']) // undefined
// console.log( p.dataset['timeStamp']) // at HTML File is time-stamp but we remove hyphen and use CamelCase
// console.log( p.dataset['time:stamp'])
// console.log( p.getAttribute('data-time-stamp'));
// console.log( p.getAttribute('data-time:stamp'));

// p.setAttribute('data-time:stamp', 'Thursday')
// p.dataset.timeStamp = 'Wednesday'; // to use dataset. you should convert time-stamp to camelCase
// p.dataset["time:stamp"] = "Sunday" // with time:stamp you cannot use p.dataset.time:stamp use instead p.dataset["time:stamp"] 
// // you can also catch attribute from CSS File look there

// -------------------------Single Page Application--------------------------
// const app = {
//   pages: [],
//   show: new Event('show'),
//   init: function(){
//       app.pages = document.querySelectorAll('.page');
//       app.pages.forEach((pg)=>{
//           pg.addEventListener('show', app.pageShown);
//       })
      
//       document.querySelectorAll('.nav-link').forEach((link)=>{
//           link.addEventListener('click', app.nav);
//       })
//       history.replaceState({}, 'Home', '#home');
//       window.addEventListener('popstate', app.poppin); // will be triggered when user press on back or forward button or press on link
//   },
//   nav: function(ev){
//       ev.preventDefault(); // wihtout it popstate will be triggered on window.addEventListener('popstate', app.poppin);
//       let currentPage = ev.target.getAttribute('data-target');
//       document.querySelector('.active').classList.remove('active');
//       document.getElementById(currentPage).classList.add('active');
//       console.log(currentPage)
//       history.pushState({}, currentPage, `#${currentPage}`);
//       document.getElementById(currentPage).dispatchEvent(app.show);
//   },
//   pageShown: function(ev){
//       console.log('Page', ev.target.id, 'just shown');
//       let h1 = ev.target.querySelector('h1');
//       h1.classList.add('big')
//       setTimeout((h)=>{
//           h.classList.remove('big');
//       }, 1200, h1);
//   },
//   poppin: function(ev){
//       console.log(location.hash, 'popstate event');
//       let hash = location.hash.replace('#' ,'');
//       document.querySelector('.active').classList.remove('active');
//       document.getElementById(hash).classList.add('active');
//       console.log(hash)
//       document.getElementById(hash).dispatchEvent(app.show);
//   }
// }

// document.addEventListener('DOMContentLoaded', app.init);

// ------------------------------------Modal Window---------------
//

// const showModal = (ev) =>{
//   // ev.preventDefault();
//   let modal = document.querySelector('.modal');
//   modal.classList.remove('off');
//   modal.classList.add('on');
// }

// const showOverlay = (ev) => {
//   // ev.preventDefault();
//   let overlay = document.querySelector('.overlay');
//   overlay.classList.remove('hide');
//   overlay.classList.add('show');
//   showModal(ev)
// }

// const hideModal = (ev) => {
//   let modal = document.querySelector('.modal');
//   modal.classList.remove('on');
//   modal.classList.add('off');
// }

// const hideOverlay = (ev) => {
//   // ev.preventDefault();
//   ev.stopPropagation(); //don't let the click pass through.
//   let overlay = document.querySelector('.overlay');
//   overlay.classList.remove('show');
//   overlay.classList.add('hide');
//   hideModal(ev);
// }

// const init = (ev)=>{
//   document.querySelector('p').addEventListener('click', showOverlay);
  
//   document.querySelector('.overlay').addEventListener('click', hideOverlay);
//   document.querySelector('.close-btn').addEventListener('click', hideOverlay);
// }

// document.addEventListener('DOMContentLoaded', init);


// ------------------------------------SlideShow-----------------------------


/** 
This code would be in an external script 
**/
// (()=>{
//   const slideshow = {
//       items: [],
//       timmy: 0,
//       delay: 3000,
//       init: function(){
//           //check for the slideshow container div
//           if( document.querySelector('.slideshow')){
//               //create the content div
//               let divC = document.createElement('div');
//               divC.className = 'content';
//               document.querySelector('.slideshow').appendChild(divC);
              
//               //load the CSS file for the slideshow ( no need for this we added css style directly to main.css)
//               // let link = document.createElement('link');
//               // link.rel = 'stylesheet';
//               // link.href = './slideshow.css';
//               // document.head.appendChild(link);
              
//               //get the slideshow content
//               let url = 'json/slideshow.json';
//               fetch(url)
//               .then((response)=>{
//                   return response.json();
//               })
//               // data return from last then will be parameter to loadContents function
//               .then(slideshow.loadContents) 
//               .catch((err)=>{
//                   console.log('ERROR:', err);
//               });   
//           }
//       },
//       loadContents: function(data){
//           let df = new DocumentFragment();
//           data.items.forEach((item, idx)=>{
//               //add each item to the slideshow div
//               let div = slideshow.createItem(item, idx);
//               df.appendChild(div);
//           })
//           //add the slideshow items to the page
//           document.querySelector('.slideshow .content').appendChild(df);
//           //make the first one current because querySelector will catch only first match
//           document.querySelector('.slideshow-item').classList.add('current');
//           //save the array of items
//           slideshow.items = document.querySelectorAll('.slideshow-item');
//           //start the slideshow moving
//           slideshow.start();
//       },
//       createItem: function(item, index){
//           let div = document.createElement('div');
//           div.classList.add('slideshow-item');
//           div.setAttribute('data-index', index);
//           let title = document.createElement('h1');
//           title.textContent = item.title;
//           div.appendChild(title);
//           // if you want to add images
//           // let img = document.createElement('img');
//           // img.src = './img/' + item.img;
//           // div.appendChild(img);
//           let p = document.createElement('p');
//           p.textContent = item.msg;
//           div.appendChild(p);
//           return div;
//       },
//       switchItem: function(index, ev){
//           if(ev){ // this if you added any event to those slides
//               ev.preventDefault();
//           }
//           let current = document.querySelector('.current')
//           current.classList.remove('current');
//           current.classList.add('leaving');
//           setTimeout(()=>{
//               current.classList.remove('leaving');
//           }, 800);
//           slideshow.items[index].classList.add('current');
//       },
//       start: function(){
//           slideshow.timmy = setInterval(()=>{
//               let [first, ...rest] = slideshow.items; // destructring
//               slideshow.items = [...rest, first];
//               slideshow.switchItem(0);
//           }, slideshow.delay);
//       }
//   }
//   document.addEventListener('DOMContentLoaded', slideshow.init);
// })();



// ----------------------------HTML Forms and Validation----------------
/*
To link Label Tag to in Input tag at label tag add (for) attribute with the value if input‘s ID
To use default validation from The Browser add attribute required 
To reset input field you can create another input with type=“reset”
*/


// const init = function(){
//   document.getElementById('button-cancel').addEventListener('click', reset);
//   document.getElementById('button-send').addEventListener('click', send);
// }

// const reset = function(ev){
//   // If the button is within a form, the default behavior is submit.
//   // If the button is not within a form, it will do nothing.
//   ev.preventDefault(); // without this clicking this button will submit the form
//   // programmatically we can reset it 
//   // This method does the same thing as clicking the form's <input type="reset"> control.
//   document.getElementById('form-user').reset();
//   //if you want to do anything else...
// }

// const send = function(ev){
//   ev.preventDefault(); 
//   //or the click will travel to the form and the form will submit
//   let fails = validate();
//   //IF we wanted to do some async things then use a Promise with .then and .catch
//   if(fails.length === 0){
//       //good to go
//       document.getElementById('form-user').submit();
//   }else{
//       //there are some errors to display
//       fails.forEach(function(obj){
//           let field = document.getElementById(obj.input);
//           field.parentElement.classList.add('error');
//           field.parentElement.setAttribute('data-errormsg', obj.msg);
//       })
//   }
// }

// const validate = function(ev){
//   //let valid = true;
//   let failures = [];
//   //checkbox (or radio buttons grouped by name)
//   let chk = document.getElementById('input-alive');
//   // .checked .value
//   if(!chk.checked){
//       failures.push({input: 'input-alive', msg: 'Must be alive to submit.'})
//   }

//   //select
//   let select = document.getElementById('input-age');
//   // .selectedIndex  .options  .length   .selectedValue  .value
//   if( select.selectedIndex === 0 ){
//       failures.push({input:'input-age', msg:'Too young'})
//   }

//   //inputs for text, email, tel, color, number...
//   let first = document.getElementById('input-first');
//   let password = document.getElementById('input-password');
//   let email = document.getElementById('input-email');
//   //.value, .defaultValue, length of value
//   if( first.value === ""){
//       failures.push({input:'input-first', msg:'Required Field'})
//   } 
//   if( password.value === "" || password.value.length < 8){
//       failures.push({input:'input-password', msg:'Must be at least 8 chars'})
//   } 
//   if( email.value === ""){
//       failures.push({input:'input-email', msg:'Required Field'})
//   }
  
//   //return an object with details about the failures
//   console.log(failures)
//   return failures;
// }


// document.addEventListener('DOMContentLoaded', init);



// ---------------------Fetch Ajax with photos-----------------------
// let fetch = require('node-fetch');
// let url = 'https://picsum.photos/list';

// fetch(url)
// .then(response=>response.json())
// .then(data=>{
//     console.log(data.length);
//     console.log(data[0].format);
//     console.log(data[0].width);
//     console.log(data[0].height);
//     console.log(data[0].id);
//     console.log(data[0].post_url);
    
//     /*
//     //This code won't work through NodeJS
//     for(let i=0; i<10; i++){
//         let img = document.createElement('img');
//         img.src = data[i].post_url;
//         document.body.appendChild(img);
//     }
//     */
// })
// .catch(err=>{
//     console.log(JSON.stringify(err, null, 2));
// })


// ---------------------Using TheMovieDB.org API v3------------

/*************
SAMPLE URLS

1. To get the config data like image base urls
https://api.themoviedb.org/3/configuration?api_key=<APIKEY>

2. To fetch a list of movies based on a keyword
https://api.themoviedb.org/3/search/movie?api_key=<APIKEY>&query=<keyword>

3. To fetch more details about a movie
https://api.themoviedb.org/3/movie/<movie-id>?api_key=<APIKEY>
*************/
// const APIKEY is inside key.js
// let APIKEY = "b5e3456d5ee40d9b6377846684cd0a83" // register on website to get API Key
// let baseURL = 'https://api.themoviedb.org/3/';
// let configData = null;
// let baseImageURL = null;

// let getConfig = function () {
//     let url = "".concat(baseURL, 'configuration?api_key=', APIKEY); 
//     fetch(url)
//     .then((result)=>{
//         return result.json();
//     })
//     .then((data)=>{
//         baseImageURL = data.images.secure_base_url;
//         configData = data.images;
//         console.log('config:', data);
//         console.log('config fetched');
//         runSearch('godfather')
//     })
//     .catch(function(err){
//         alert(err);
//     });
// }

// let runSearch = function (keyword) {
//     let url = ''.concat(baseURL, 'search/movie?api_key=', APIKEY, '&query=', keyword);
//     fetch(url)
//     .then(result=>result.json())
//     .then((data)=>{
//         //process the returned data
//         // document.getElementById('output').innerHTML = JSON.stringify(data, null, 4);
//         //work with results array...
//         for(let i = 0; i < 4; i++){
//           let output = document.getElementById('output')
//           let movie = document.createElement("div")
//           let img = document.createElement("img")
//           img.src = "".concat(baseImageURL,"w92" ,data.results[i].poster_path)
//           movie.innerHTML = JSON.stringify(data.results[i], ["title","release_date","vote_average"], "#");
//           // movie.innerHTML = `${data.results[i].title} is released at ${data.results[i].release_date} and his Rate is ${data.results[i].vote_average}`
//           output.append(img,movie)
//         }
//       })
// }

// document.addEventListener('DOMContentLoaded', getConfig);
/*******************************
SAMPLE SEARCH RESULTS DATA
{ "vote_count": 2762, 
    "id": 578, 
    "video": false, 
    "vote_average": 7.5, 
    "title": "Jaws", 
    "popularity": 16.273358, 
    "poster_path": "/l1yltvzILaZcx2jYvc5sEMkM7Eh.jpg", 
    "original_language": "en", 
    "original_title": "Jaws", 
    "genre_ids": [ 27, 53, 12 ], 
    "backdrop_path": "/slkPgAt1IQgxZXNrazEcOzhAK8f.jpg", 
    "adult": false, 
    "overview": "An insatiable great white shark terrorizes the townspeople of Amity Island, The police chief, an oceanographer and a grizzled shark hunter seek to destroy the bloodthirsty beast.", 
    "release_date": "1975-06-18" 
}
****************/

// ----------------------------------JSON.parse()----------------------------------
// JSON.parse(txt, reviver function)

// beginning with the most nested properties and proceeding to the original value itself
// let pars = JSON.parse('[{"prop1" : {"prop3" : 3}},{"prop2" : {"prop4" : "Four"}}]',function(key,value){
//   console.log(key , value)
//   /** Output will be
//    * prop3 => // 3 inner most nested property 
//    * prop1 => {} 
//    * 0 => {} // this is element index 0 inside array
//    * prop4 => Four
//    * prop2 => {}
//    * 1 => {} // this is element index 1 inside array
//    * [] // the array itself
//    */
// })

// let pars = JSON.parse('[{"prop1" : {"prop3" : 3}},{"prop2" : {"prop4" : "Four"}}]',function(key,value){
//   return typeof value === "number" ? value * 2 : value
// })
// console.log(pars) //'[{"prop1" : {"prop3" : 6}},{"prop2" : {"prop4" : "Four"}}]' 


// // Restriction =>  JSON.parse() does not allow trailing commas
// // both will throw a SyntaxError
// JSON.parse('[1, 2, 3, 4, ]'); // ERROR
// JSON.parse('{"foo" : 1, }');// ERROR

// // JSON.parse() does not allow single quotes
// // will throw a SyntaxError
// JSON.parse("{'foo': 1}");// ERROR


// ----------------------------------JSON.stringfy()----------------------------------
// JSON.stringfy(value, replacer, space)

/*
The replacer parameter can be either a function or an array.

As a function, it takes two parameters: the key and the value being stringified. 
The object which is provided is the replacer's this parameter.

Initially, the replacer function is called with an empty string as key representing the object being stringified. 
It is then called for each property on the object or array being stringified.
It should return the value that should be added to the JSON string, as follows:

* If you return a Number, String, Boolean, or null, the stringified version of that value is used as the property's value.
* If you return a Function, Symbol, or undefined, the property is not included in the output.
* If you return any other object, the object is recursively stringified, calling the replacer function on each property. */

// -------- [1]Replacer
// function replacer(key, value) {
//   // Filtering out properties
//   console.log(this)
//   if (typeof value === 'string') {
//     return undefined;
//   }
//   return value;
// }

// var foo = {foundation: 'Mozilla', model: 'box', week: 45, transport: 'car', month: 7};
// console.log(JSON.stringify(foo, replacer))
// '{"week":45,"month":7}'

// // If replacer is an array, the array's values indicate the names of the properties 
// // in the object that should be included in the resulting JSON string.
// JSON.stringify(foo, ['week', 'month']);
// // '{"week":45,"month":7}', only keep "week" and "month" properties

// [2] Space
/* The space argument may be used to control spacing in the final string.
* If it is a number, successive levels in the stringification will each be indented by this many space characters (up to 10).
* If it is a string, successive levels will be indented by this string (or the first ten characters of it). */

/*
  {
    "title":"Conference",
    "room": 23 // without toJSON() will return "room":{"number":23}
  }
*/
// -----toJSON() behavior
// toJSON() will work if the object has value this value is object with toJSON() method
/*
If an object being stringified has a property named toJSON whose value is a function, 
then the toJSON() method customizes JSON stringification behavior: 
instead of the object being serialized, the value returned by the toJSON() method 
when called will be serialized. 

JSON.stringify() calls toJSON with one parameter:
* an empty string if JSON.stringify() was directly called on this object 
* property name if nested object (object inside object)
* number of index if (object inside array)
*/

// var obj = {
//   data: 'data',

//   toJSON (key) {
//       if (key){
//         console.log(arguments)
//         return `Now I am a nested object under key '${key}'`;
//       }else{
//         return this;
//       }  
//   }
// };

// console.log(JSON.stringify(obj));
// // '{"data":"data"}'

// let obj1 = {obj} // {obj : {object above}}
// console.log(obj1)
// console.log(JSON.stringify(obj1)); // Shorthand property names (ES2015).
// '{"obj":"Now I am a nested object under key 'obj'"}'

// let arr = [obj] // [{object above}]
// console.log(arr)
// console.log(JSON.stringify(arr));
// // '["Now I am a nested object under key '0'"]'

// String Keyed Array is not enumerable
// let a = ["One","Two"]
// a["three"] = ["Four"]
// console.log(JSON.stringify(a)) // ["One","Two"]
// for( let key in a){
//   console.log(key) // 0 1 three
// }
// for( let value of a){
//   console.log(value) // one two
// }

// let room = {
//   number: 23,
//   // toJSON(key) {
//   //   console.log(arguments)
//   //   return this.number;
//   // }
// };

// let meetup = {
//   title: "Conference",
//   room
// };

// console.log( JSON.stringify(room) ); // 23 without toJSON() will return {"number":23}

// console.log( JSON.stringify(meetup) ); // {"title":"Conference","room":23} without toJSON() will return {"title":"Conference","room":{"number":23}}


// ----------------------Multi Language webPage----------------
// look at CSS and HTML file

// ---------------------HTML Template------------------------
/*
Template tag in HTML file will not be shown unless you append it to document.body
Template tag in HTML file have property called content (this content is document fragment)
let con = document.createElement("template")
console.log(con.content) // empty document fragmet
 */

// let bool = true

// document.addEventListener('DOMContentLoaded', ()=> {
//   if (bool) {
//       //We can use the template element in our HTML
//       let temp = document.getElementById('myTemplate');
//       let content = temp.content;
//       console.log(content); // document fragmet
//       // we used cloneNode because if we are trying to use appendChild to append same element 
//       // will not append another copy will move the element from old location to new location
//       document.body.appendChild(content.cloneNode(true));
//       document.body.appendChild(content.cloneNode(true));
//       document.body.appendChild(content.cloneNode(true));
//       document.body.appendChild(content.cloneNode(true));
//       document.body.appendChild(content.cloneNode(true));
//       document.body.appendChild(content.cloneNode(true));
//       document.body.appendChild(content.cloneNode(true));
      
//   } else {
//       //Use another method (without uing HTML Template), like manually building the elements.
//       console.log('The else is running');
//       let df = document.createDocumentFragment();
//       let div = document.createElement('div');
//       let h2 = document.createElement('h2');
//       let p = document.createElement('p');
//       h2.textContent = 'A Sub Heading';
//       p.textContent = 'Some dynamically created text.';
//       div.className = 'box';
//       h2.className = 'temp';
//       df.appendChild(div);
//       div.appendChild(h2);
//       div.appendChild(p);
//       document.body.appendChild(df);
//   }
// })


// --------------------Validate Empty Form------------------
// All the value from form are a string even in input tag type number will converted to string

// document.addEventListener("DOMContentLoaded",()=>{
//   document.getElementById("btnSubmit").addEventListener("click",processFrom)
// })

// let processFrom = function(ev){
//   ev.preventDefault()

//   console.log(document.getElementById("username").value)
//   console.log(document.getElementById("username").value.trim()) // to remove spaces before submittimg
//   // you can use this to validate that username must be longer than 6 chars
//   console.log(document.getElementById("username").value.trim().length > 6)

//   console.log(document.getElementById("select").value)
//   // you can use this to validate that you can not select 1st choice
//   console.log(document.getElementById("select").selectedIndex > 0)

//   let age = document.getElementById("age")
//   console.log(age.min)
//   console.log(age.max)
//   console.log(age.value)
//   // parseInt will give you NaN if it is an Empty string or string
//   console.log(parseInt(age.value))
//   /* you can use && in validate because if parseInt(age.value) before && is 
//   NaN (or another falsy value) will not continue this line of code
//   and will return false but if parseInt(age.value) before && is 
//   truthy value (number) will continue the line of code and check if 
//   it's > age.min */
//   console.log(parseInt(age.value) && parseInt(age.value) > age.min)
// }
// console.log(parseInt("1")) // 1
// console.log(parseInt("a1")) // NaN
// console.log(parseInt("")) // NaN
// console.log(parseInt("hi")) // NaN

// -------------------Tabbed Navigation with CSS and JS----------------
// let tabs, sections;
        
// let init = function(){
//     //find all the tabs (li.tab)
//     tabs = document.querySelectorAll(".tab"); // NodeList
//     //add click listeners to each one (like tabs.forEach() but we used [].forEach.call to be compatable with old versions of browsers becuase tabs is nodeList not pure array )
//     [].forEach.call(tabs, (tab)=>{
//         //function will be called once
//         //forEach tab li
//         tab.addEventListener('click', switchTab);
//     });
//     //find all the content (section.tab-content)
//     sections = document.querySelectorAll(".tab-content");
// }

// let switchTab = function(ev){
//     let tab = ev.target;
//     //called when a user clicks on a tab
//     let id = tab.id;
//     //take id from tab
//     let actives = document.querySelectorAll('.active'); // NodeList
//     [].forEach.call(actives, (active)=>{
//         active.classList.remove('active');
//     });
//     //loop through the sections
//     [].forEach.call(sections, (section)=>{
//         if( 'section-'+id === section.id){
//             //make the tab active
//             tab.classList.add('active');
//             //make the secton active
//             section.classList.add('active');
//         }
//     });
//     //find the matching id
//     //add the active class to the matching one
// }

// window.addEventListener('DOMContentLoaded', init);


// ------------------Master Details with single web application--------------


// const TODAY = new Date(15116711772000);
// const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
// const DATA = {
//     people: [
//         {person_id: 1, 
//           name: "Megan", 
//           lastAccess:1511150221000, 
//           isMobile:false, 
//           avatar:"😀"},
//         {person_id: 2, 
//           name: "Cara", 
//           lastAccess:1511350001000, 
//           isMobile:false, 
//           avatar:"😡"},
//         {person_id: 3, 
//           name: "Camille", 
//           lastAccess:1511661001000, 
//           isMobile:false, 
//           avatar:"😜"},
//         {person_id: 4, 
//           name: "Bree", 
//           lastAccess:1511670871221, 
//           isMobile:true, 
//           avatar:"😵"}
//     ]
// }

// let init = function(){
//     loadMaster(DATA.people);
// }

// let loadMaster = function(people){
//     let ul = document.querySelector('.master-list');
//     let df = document.createDocumentFragment();
//     people.forEach(person => {
//         let li = document.createElement('li');
//         li.textContent = person.name;
//         li.className = 'person';
//         li.setAttribute('data-key', person.person_id);
//         li.addEventListener('click', showDetails);
//         df.appendChild(li);
//     });
//     ul.appendChild(df);
// }

// let showDetails = function(ev){
//     let person_id = ev.target.getAttribute('data-key');
//     let oldActive = document.querySelector('.active');
//     (oldActive)?oldActive.classList.remove('active'):null;
//     ev.target.classList.add('active');
//     let activePerson;
//     DATA.people.forEach(person=>{
//         if(person.person_id == person_id){
//             activePerson = person;
//         }
//     });
//     let ul = document.querySelector('.detail-list');
//     ul.innerHTML = ""; //clear old list
//     let df = document.createDocumentFragment();
//     for(prop in activePerson){
//         let li = document.createElement('li');
//         li.classList.add(prop);
//         if(prop=='lastAccess'){
//             let timmy = new Date(activePerson[prop]);
//             let str = `${timmy.getDate()} ${MONTHS[timmy.getMonth()]} ${timmy.getFullYear()}`;
//             li.textContent = str;
//         }else{
//             li.textContent = activePerson[prop];
//         }
//         console.log(activePerson[prop]);
//         df.appendChild(li);
//     }
//     ul.appendChild(df);
// }

// document.addEventListener('DOMContentLoaded', init);


// ---------------------getComputedStyle-------------
/*
getComputedStyle(element , psudo-element)

difference between getComputedStyle and element.style.style-name is 
with getComputedStyle you can get every style on the element even the default style added by browser
but with element.style.style-name you can get only style added to CSS file not the default
 */
// document.addEventListener('DOMContentLoaded', function(){
//   let first = document.querySelector('.first');
//   let second = document.querySelector('.second');
//   let third = document.querySelector('.third');
//   // use camelCase with style names
//   let resultOne = getComputedStyle(first).fontSize; // camelCase 
//   let resultOne1 = getComputedStyle(first).getPropertyValue("font-size"); // using hypen
//   console.log(resultOne1) 
//   let resultTwo = getComputedStyle(second,'::before').content;
//   let resultThree = getComputedStyle(third).backgroundColor;
//   let resultThree0 = third.style.color // works only for inline styles (in HTML File)
//   let resultThree1 = getComputedStyle(third).display; // block => this is default css style added by browser
//   let resultThree2 = third.style.display; // will not get default css style

//   let div = document.getElementById('output')
//   div.innerHTML = `${resultOne} ${resultTwo} ${resultThree} ${resultThree0} ${resultThree1} ${resultThree2}`;
// })

// --------------------------Progress Bar(Reading)------------------
// let header = document.querySelector('header');
// let bar = document.querySelector('.bar');

// // change progress bar width when scrolling
// window.addEventListener('scroll', adjustbar);
// // once the page load change progress bar width to number% (percentage of paragrapgh shown on home page without scrolling)
// document.addEventListener('DOMContentLoaded', adjustbar);
// // change progress bar width when resizing webpage
// window.addEventListener('resize', adjustbar);


// function adjustbar(){
//     let pageHeight = document.body.clientHeight; //height of <body>
//     let pageWidth = document.body.clientWidth;  //width of <body>
//     let pageOffset = window.pageYOffset;        //how far has page scrolled
//     let bottom = parseInt(getComputedStyle(header).bottom);
//     //distance from bottom of header to bottom of page (because the when when reach of end of scroll we want to measure the height if last paragraph shown on last home page)
//     let pct = (pageOffset + bottom)/pageHeight;
//     let w = pct * pageWidth;
//     bar.style.width =  w + "px";
//     console.log("resize")
// }

// ----------------------Special charachters in HTML , CSS & Js------------------------

/*
HTML : 
  [1] Decimal => &#165;
  [2] Hexidecimal => &#x00A5;
  [3] abbreviation => &yen;  (some charachters has shortcut)

CSS : 
  [1] Escaping charachter only with Hexidecimal: "\00A5"

JS : 
  [1] Escaping Charachter only with Hexidecimal: "\u00A5"
*/


// ---------------------------Random Color Generator----------------------

// //how to generate Random Colours in JavaScript
// let r, g, b, h, s, l, color, intColor;
// let h1 = document.querySelector('h1');

// //1. #FAB
// r = Math.floor(Math.random() * 16).toString(16);
// g = Math.floor(Math.random() * 16).toString(16);
// b = Math.floor(Math.random() * 16).toString(16);
// color = `#${r}${g}${b}`;
// h1.textContent = color;
// document.body.style.backgroundColor = color;

// // 2. #FFED77
// r = Math.floor(Math.random() * 256).toString(16);
// g = Math.floor(Math.random() * 256).toString(16);
// b = Math.floor(Math.random() * 256).toString(16);
// r = (r.length===2)?r:'0' + r;
// g = (g.length===2)?g:'0' + g;
// b = (b.length===2)?b:'0' + b;
// color = `#${r}${g}${b}`;
// h1.textContent = color;
// document.body.style.backgroundColor = color;

// // 3. hsl(359, 50%, 40%)  hsla(h, s, l, 0.3)
// h = Math.floor(Math.random() * 360).toString();
// s = Math.floor(Math.random() * 101).toString();
// l = Math.floor(Math.random() * 101).toString();
// color = `hsl(${h}, ${s}%, ${l}%)`;
// h1.textContent = color;
// document.body.style.backgroundColor = color;


// // 4. rgb(255, 0, 128)  rgba(r, g, b, 0.3)
// r = Math.floor(Math.random() * 256).toString();
// g = Math.floor(Math.random() * 256).toString();
// b = Math.floor(Math.random() * 256).toString();
// color = `rgb(${r}, ${g}, ${b})`;
// h1.textContent = color;
// document.body.style.backgroundColor = color;

// //5. Faster colours with Bitwise operators
// intColor = Math.floor(Math.random() * Math.pow(2, 24));
// // random value between 0 and 2 to the power of 24
// // 111111110000000011111111
// r = intColor >> 16;
// g = (intColor >> 8) & 255;
// b = intColor & 255;
// color = `rgb(${r}, ${g}, ${b})`;
// h1.textContent = color;
// document.body.style.backgroundColor = color;

// ---------------------------------Circle Graph------------------------
// let info;
        
// document.addEventListener('DOMContentLoaded', ev=>{
//     info = document.querySelector('#main .info');
//     doRotations();
//     let timmy = setInterval(function(){
//         let num = parseInt(info.textContent) + 1;
//         num = (num>100)?0:num;
//         info.textContent = num;
//         doRotations();
//     }, 500)
// });

// function doRotations(){
//   let coverOver = document.querySelector('#main .cover-over50');
//   let coverUnder = document.querySelector('#main .cover-under50');
//   let fillOver = document.querySelector('#main .fill-over50');
//   let infoNum = parseInt(info.textContent);
//   let pct = (infoNum - 50) * 360 / 100;
//   //get the percentage of 360 degrees
//   console.log('num', infoNum, pct, 'deg');
//   if(infoNum > 50){
//       coverOver.style.zIndex = 20;
//       fillOver.style.zIndex = 30;
//       //blue on right on top
//       fillOver.style.transform = 'rotate(180deg)';
//       coverUnder.style.transform = 'rotate(180deg)';
//       //move a grey under the purple
//       coverOver.style.transform = `rotate(${pct}deg)`;
//   }else{
//       coverOver.style.zIndex = 30;
//       fillOver.style.zIndex = 20;
//       //blue on left under grey
//       coverOver.style.transform = 'rotate(0deg)';
//       fillOver.style.transform = 'rotate(0deg)';
//       //rotate a grey to reveal bottom-most purple
//       coverUnder.style.transform = `rotate(${pct}deg)`;
//   }
  
//   //extra code for the demo in the alt section
//   let altCOver = document.querySelector('#alt .cover-over50');
//   let altCUnder = document.querySelector('#alt .cover-under50');
//   let altFOver = document.querySelector('#alt .fill-over50');
//   altCOver.style.transform = coverOver.style.transform;
//   altCUnder.style.transform = coverUnder.style.transform;
//   altFOver.style.transform = fillOver.style.transform;
// }

// -------------------------Star Rating System------------------
// -------My-Version
// let allStars = document.querySelectorAll("i")
// let span = document.querySelector(".stars span")
// allStars.forEach((star,indx) => {
//   star.addEventListener("click", function(){
//   star.classList = "filled fas fa-star"
//     for(let i = 0; i < indx; i++){
//       allStars[i].classList = "filled fas fa-star"
//       span.textContent = `${indx+1}/5`
//     }
//     for(let i = indx+1; i < allStars.length; i++){
//       allStars[i].classList = "far fa-star"
//       span.textContent = `${indx+1}/5`
//     }
//   })
// })
// document.addEventListener('DOMContentLoaded',function(){
//   let initRate = prompt("Please Rate","Write your Rate Here ")
//   // initRate = parseInt(initRate) && parseInt(initRate) > 0 && parseInt(initRate) < 6  ? initRate : 5
//   while( !parseInt(initRate) || parseInt(initRate) <= 0 || parseInt(initRate) >= 6){
//     initRate = prompt("inValid input","Your Range is 1 - 5 ")
//   }
//   allStars[parseInt(initRate) - 1 ].dispatchEvent(new MouseEvent('click'))
// })

// -------Steve version
//initial setup
// document.addEventListener('DOMContentLoaded', function(){
//   let stars = document.querySelectorAll('.star');
//   stars.forEach(function(star){
//       star.addEventListener('click', setRating); 
//   });
  
//   let rating = parseInt(document.querySelector('.stars').getAttribute('data-rating'));
//   let target = stars[rating - 1];
//   target.dispatchEvent(new MouseEvent('click'));
// });

// function setRating(ev){
//   let span = ev.currentTarget;
//   let stars = document.querySelectorAll('.star');
//   let match = false;
//   let num = 0;
//   stars.forEach(function(star, index){
//       if(match){
//           star.classList.remove('rated');
//       }else{
//           star.classList.add('rated');
//       }
//       //are we currently looking at the span that was clicked
//       if(star === span){
//           match = true;
//           num = index + 1;
//       }
//   });
//   document.querySelector('.stars').setAttribute('data-rating', num);
// }

// ------------Private and Public API---------------
// // API for Public info o Github User
// let url1 = "https://api.github.com/users/Mido1971988" 
// // API for list of Public Repos
// let url2 = "https://api.github.com/users/Mido1971988/repos" 
// // API for list of public and private repos(but private Repos needs Authorization with Personal Access Token)
// let url3 = "https://api.github.com/search/repositories?q=user:Mido1971988"  
// // API for list of files inside Repo
// let url4 = "https://api.github.com/repos/Mido1971988/Private-Repo/git/trees/master?recursive=1"
// // API to get file from private Repo return metadata not raw content so you have to decode content first
// let url5 = "https://api.github.com/repos/Mido1971988/Private-Repo/contents/darksky-sample.json"
// // API to get file from public Repo return metadata not raw content so you have to decode content first
// let url6 = "https://api.github.com/repos/Mido1971988/Public-Repo/contents/slideshow.json"


// // -----My Github Public API 

// // fetch(url3)
// //   .then(response => response.json())
// //   .then(data => console.log(data)) // 14 repos because there is 1 repo Private
// //   .catch(err => console.log(err)) 

// // -----My Github Private API
// let request = new Request (url6,{
//   method : "GET",
//   headers : {
//     "Authorization" : "token " +"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", // token or Bearer
//     "content-type": "application/json"
//   },
//   mode : "cors",
//   cache : "default"
// })

// fetch(request)
//   .then(response => (response).json())
//   .then(data => console.log(data))
//   .catch(err => console.log(err))

// fetch(request)
//   .then(response => (response).json())
//   .then(data => console.log(JSON.parse(atob(data.content)))) // atob to decode base64
//   .catch(err => console.log(err))

// -----------------------------search-------------------------------
// -----my Way
// let ul = document.createElement("ul")
// let txt = document.getElementById("txt-search")
// let output = document.getElementById("output")
// output.appendChild(ul)
// let pre = document.getElementById("array").innerHTML.split(",")
// let arr = pre.map(ele => {
//   let newEle = ele.trim().split("")
//   newEle.pop()
//   newEle.shift()
//   return newEle.join("")
// })

// let elements;
// txt.addEventListener("input",function(ev){
//   elements = [];
//   if(ev.target.value.length > 0){
//     arr.forEach(ele => {
//       // match Method (return matched)
//       // let regX = new RegExp(`\^${ev.target.value}\\w{0,}`,"ig")
//       // let matchedEle = ele.match(regX)
//       // test Method (return true or false)
//       let regX = new RegExp(`\^${ev.target.value}`,"ig")
//       let matchedEle = regX.test(ele)
//       if(matchedEle){
//         if(!elements.includes(ele)){
//           elements.push(ele)
//         }
//       }
//     })
//     addToList(elements)
//   }else{
//     ul.textContent = ""
//   }
// })

// function addToList(array){
//   ul.textContent = ""
//   array.forEach(ele =>{
//     let li = document.createElement("li")
//     li.textContent = ele
//     ul.appendChild(li)
//   })
// }

// -----steve way
// const KEY = 'debounce-terms';

// let init = function(){
//     // document.getElementById('txt-search').addEventListener('input', search);
//     document.getElementById('txt-search').addEventListener('input', efficientSearch);
    
//     let terms = ['apple', 'acorn', 'bee', 'beet', 'beef', 'bunny', 'cookie', 
//                   'corn', 'corndog', 'dog', 'dogma', 'echo', 'elephant'];
//     localStorage.setItem(KEY, JSON.stringify(terms));
// }
  
// let search = function(ev){
//     let text = ev.target.value;
//     document.getElementById('output').textContent = `List Matching ${text}`;
//     let ul = document.getElementById('matches');
    
//     //call an asynchronous search to match what has been typed
//     getList(text)
//     .then((list)=>{
//         ul.innerHTML = '';
//         if( list.length == 0){
//             let li = document.createElement('li');
//             li.textContent = "NO MATCHES";
//             ul.appendChild(li);
//         }else{
//             list.forEach(item=>{
//                 let li = document.createElement('li');
//                 li.textContent = item;
//                 ul.appendChild(li);
//             })
//         }
//     })
//     .catch(err=>console.warn(err));
// }


// let getList = function(txt){
//     return new Promise((resolve, reject)=>{
//         //use setTimeout with random value to show what can happen
//         let r = Math.floor(Math.random()*1000);
//         setTimeout((function(){
//             let t = '^' + txt.toString();
//             let pattern = new RegExp(t, 'i'); //starts with t
//             let terms = JSON.parse(localStorage.getItem(KEY));
//             let matches = terms.filter(term => pattern.test(term));
//             resolve(matches);
//         }), r,txt);
//     })
// }

// better version to solve a problem of typing so fast will not garantee that order of results from fetch call will no be correct 
// so use debounce Function to call the function at most once every 300ms not at every time you press the keyboard
// read below to know how debounce Function is works
// let debounce = function(func, wait, immediate) {
//   var timeout;
//   return function() {
//       var context = this, args = arguments;
//       // console.log(context)
//       // console.log(args)
//       var later = function() {
//           timeout = null;
//           if (!immediate) func.apply(context, args);
//       };
//       var callNow = immediate && !timeout;
//       clearTimeout(timeout);
//       timeout = setTimeout(later, wait);
//       if (callNow) func.apply(context, args);
//   };
// };

// let efficientSearch = debounce(function(ev){
//   let text = ev.target.value;
//   document.getElementById('output').textContent = `List Matching ${text}`;
//   let ul = document.getElementById('matches');
  
//   //call an asynchronous search to match what has been typed
//   getList(text)
//   .then((list)=>{
//       ul.innerHTML = '';
//       if( list.length == 0){
//           let li = document.createElement('li');
//           li.textContent = "NO MATCHES";
//           ul.appendChild(li);
//       }else{
//           list.forEach(item=>{
//               let li = document.createElement('li');
//               li.textContent = item;
//               ul.appendChild(li);
//           })
//       }
//   })
//   .catch(err=>console.warn(err));
// }, 300);
// //call the debounced function at most once every 300ms

// document.addEventListener('DOMContentLoaded', init);


// //debounce function - thanks to David Walsh
// //https://davidwalsh.name/javascript-debounce-function
// //who took this from underscore.js


// // Read this to know how debounce function worked above
// let test = document.getElementById("test")
// // declaring function called first
// let first = function(func){
//   return function(){
//     let context = this
//     let args = arguments
//     func.apply(context,args)
//   }
// }
// // trigger function first and pass a function with argument (ev) to it 
// // then save returned value to variable second
// // now variable second is a function because function first 
// // return another function 
// let second = first(function(ev){console.log(ev)}) 
// // now trigger function second which is the function returned from 
// // first function and trigger this function will trigger the function 
// // which is passed to first function as argument this function will
// // take context and arguments from variables context & args whichs
// // assigned when you trigger seconds once event triggered
// test.addEventListener("click",second)

// ---------------------removeEventListener--------------
// // here we are creating div element
// let div = document.createElement("div")
// div.textContent = "TEST"
// // here we adding an Event to div element
// div.addEventListener("click",function(){console.log("test")})
// // here we are just printing the div element to webpage 
// document.body.appendChild(div)
// // here we are removing the div element from webpage not deleting the div element but it will
// // be garbage collected if there is no reference to it
// // but here there is an Event refer to it so it will not be garbage collected that's why it's
// // important to remove EventListener
// document.body.removeChild(div)
// console.log(div) // here div is still here because remove child only remove it from webpage
// div.removeEventListener("click",function(){console.log("test")})
// console.log(div)

// --------------------------Right Click Menu------------------------

// My Way
// let box = document.getElementById("box")
// let menu = document.querySelector("ul")
// let red = document.getElementById("red")
// let gold = document.getElementById("gold")
// let green = document.getElementById("green")

// menu.classList.add("off")

// red.addEventListener("click",function(){
//   box.style.backgroundColor = "red"
//   // we can not use this because add style using JS is inline style and will override the css style file
//   // menu.classList.add("off")
//   hide()
// })
// gold.addEventListener("click",function(){
//   box.style.backgroundColor = "gold"
//   hide()
// })
// green.addEventListener("click",function(){
//   box.style.backgroundColor = "green"
//   hide()
// })

// document.body.addEventListener("click",function(){
//   hide()
// })

// box.addEventListener("contextmenu",function(ev){
//   ev.preventDefault()
//   menu.classList.remove("off")
//   menu.style.left = ev.pageX + "px"
//   menu.style.top = ev.pageY + "px"
// })

// function hide(){
//   menu.style.left = "-200%"
//   menu.style.top = "-200%"
// }

// -------------Steve Way

// let menu = null;
// document.addEventListener('DOMContentLoaded', function(){
//     //make sure the right click menu is hidden
//     menu = document.querySelector('.menu');
//     menu.classList.add('off');
    
//     //add the right click listener to the box
//     let box = document.getElementById('box');
//     box.addEventListener('contextmenu', showmenu);
    
//     //add a listener for leaving the menu and hiding it
//     menu.addEventListener('mouseleave', hidemenu);
    
//     //add the listeners for the menu items
//     addMenuListeners();
// });

// function addMenuListeners(){
//     document.getElementById('red').addEventListener('click', setColour);
//     document.getElementById('gold').addEventListener('click', setColour);
//     document.getElementById('green').addEventListener('click', setColour);
// }

// function setColour(ev){
//     hidemenu();
//     let clr = ev.target.id;
//     document.getElementById('box').style.backgroundColor = clr;
// }

// function showmenu(ev){
//     //stop the real right click menu
//     ev.preventDefault(); 
//     //show the custom menu
//     menu.style.top = `${ev.clientY - 20}px`;
//     menu.style.left = `${ev.clientX - 20}px`;
//     menu.classList.remove('off');
// }

// function hidemenu(ev){
//     menu.classList.add('off');
//     menu.style.top = '-200%';
//     menu.style.left = '-200%';
// }

// -----------------------Error Handling------------------

// window.onerror = function(msg,url,line,col,err){
//   console.log(msg,url,line,col,err)
// }

// same like onerror but here you have ev object so you can ev.preventDefault()
// window.addEventListener("error",function(ev){
//   console.log(ev.message,ev.filename,ev.lineno,ev.colno,ev.error)
//   ev.preventDefault() // will stop throwing Error and stop JS file from running
//   console.log(ev)
// })
// asd

// you can add onerror on img will trigger if img did not loaded
// let img = document.getElementById("bad")
// img.onerror = function(ev){
//   console.log(ev)
// }


// ----------------mediaQuery in JS--------------------
/*
MediaQueryList has propery called matches 
will be true if width more than 601px
will be false if width less than 601px
instead of CSS
*/

// let query = window.matchMedia("(min-width : 601px)")
// let p = document.querySelector("p")

// // but you have to refresh to see the change of color
// if(query.matches){
//   p.style.color = "red"
// }else{
//   p.style.color = "yellow"
// }

// // Using Resize Event :  here no need to refresh 
// window.addEventListener("resize",function(){
//   if(query.matches){
//     p.style.color = "red"
//   }else{
//     p.style.color = "black"
//   }
// })

// // Using ResizeObserver :  here no need to refresh 
// let resizer = new ResizeObserver(changeColor)
// resizer.observe(p)

// function changeColor (entries){
//   // you can get also p from entries
//   let para = entries[0].target
//   if(query.matches){
//     para.style.color = "red" // or p
//   }else{
//     p.style.color = "black" // or para
//   }
// }

// ------------------------------Observers in JS----------------------

/**
 * ResizeObserver
 * MutationObserver
 * IntersectionObserver
******
- all Constructors of 3 types accept callback function as parameters
- all instance of 3 types has method observe() whichs accept html element as parameter
but : 
- instance of MutationObserver accept configuration object as 2nd parameter
- Constructor of IntersectionObserver accept options object as 2nd parameter
******
- callback function of ResizeObserver & IntersectionObserver accept entries : ([ResizeObserverEntry] or array of [IntersectionObserver]) as paramter
- callback function of MutationObserver accept mutationList as paramter
*/

// [1] ResizeObserver : 

// document.addEventListener('DOMContentLoaded', () => {
//   /* window.matchMedia() could be used on load */
//   //ResizeObserver constructor accept callback function as parameter and this function will run once the size of element change  
//   let resizer = new ResizeObserver(handleResize);
//   // observe is prototype method accept the target element as parameter
//   resizer.observe(document.querySelector('.container'));
// });

// function handleResize(entries) {
//   let div = entries[0].target;
//   if (entries[0].contentRect.width > 900) {
//     //add big class
//     div.classList.add('big');
//     addPhoto();
//   } else {
//     //remove big class
//     div.classList.remove('big');
//     removePhoto();
//   }
// }

// function addPhoto() {
//   if (!document.querySelector('.two img')) {
//     let img = document.createElement('img');
//     let rand = Math.floor(Math.random() * 100) + 10;
//     img.src = `https://picsum.photos/g/500/300?image=${rand}`;
//     img.alt = 'Random image';
//     document.querySelector('.two p').appendChild(img);
//   }
// }
// function removePhoto() {
//   let img = document.querySelector('.two img');
//   img?.parentElement.removeChild(img);
//   //old equivalent of the above line
//   //if(img){img.parentElement.removeChild(img);}
// }

// [2] MutationObserver : 
// let observer;
        
// document.addEventListener('DOMContentLoaded', init);

// function init(){
//     let p = document.querySelector('main > p'); //1st p
//     p.addEventListener('click', change);
    
//     let config = {
//         attributes: true, // to track changes in element's attribute 
//         attributeOldValue: true, // to track old element's attribute value
//         attributeFilter: ['data-thing', 'title', 'style'], // to track only these attributes
//         childList: true, // to track element's child including text node
//         subtree: true, // to track deeper element's grandchild
//         characterData: false, 
//         characterDataOldValue: false
//     };
//     // atleast you have to write one of these in config childList, attributes, characterData 
    
//     observer = new MutationObserver(mutated);
//     observer.observe(p, config);
//     // observer.disconnect(); // to stop tracking any mutations
// }


// function mutated(mutationList){
//     console.log( mutationList );
//     for(let mutation of mutationList) {
//         if (mutation.type == 'childList') {
//             console.log('A child node has been added or removed.');
//         }
//         else if (mutation.type == 'attributes') {
//             console.log('The ' + mutation.attributeName + ' attribute was modified.');
//             console.log( mutation.oldValue );
//         }
//     }
//     console.log(observer.takeRecords()) // return an array of all mutationRecords
//     // properties of mutationRecord
//     //target - Element
//     //addNodes - NodeList( list of added nodes)
//     //removedNodes - NodeList ( list of removed nodes)
//     //oldValue 
//     //attributeName
//     //attributeNamespace
//     //previousSibling - Element / textNode
//     //nextSibling - Element / textNode
//     //type 'attributes' or 'childList'
// }
// function change(ev){
//   let p = ev.currentTarget;
  
//   p.textContent = ' this is new content'; // will give mutation record because childList: true
//   p.setAttribute('data-thing', 123); // will give mutation record because attributes: true
//   p.title = 'NEW TITLE' // will give mutation record because childList: true
  
//   let span = document.createElement('span');
//   p.appendChild(span); // will give mutation record because childList: true
//   span.textContent = ' SOME SPAN TEXT'; // will give mutation record because subtree: true
// }

//[3] InterSectionObserver
// document.addEventListener("DOMContentLoaded", () => {
//   let options = {
//     //null means use whole viewport
//     root: null, 
//     // -250px means the observer area the the viewport area -250px form top and bottom and -50px from right and left 
//     rootMargin: "-250px -50px", 
//     // threshold means when though 0.05(5%) of target text 
//     threshold: 0.05
//   };
//   let observer = new IntersectionObserver(beTouching, options);
//   document.querySelectorAll(".container p").forEach(p => {
//     observer.observe(p);
//     //console.log("watching", p.textContent);
//   });
// });
// // we can add observer instance as second parameter and use it for exp. inside function to stop observing by unobserve method
// function beTouching(entries, ob) { 
//   console.log(entries)
//   //entries all 30 paragraphs
//   entries.forEach(entry => {
//     if (entry.isIntersecting) { // isIntersecting property means p enter observer area
//       console.log("intersecting");
//       //console.log(entry.target); // p html element
//       //console.log(entry.time, entry.intersectionRatio);
//       entry.target.classList.add("active");
//       //ob.unobserve(entry.target); // to stop watching p 
//     } else {
//       entry.target.classList.remove("active");
//     }
//   });
// }

// ------------------------Find and Replace-------------------

// -----my Way

// let target = document.querySelector(".target")
// let txt = document.querySelector(".target").textContent.split(" ")
// let input = document.getElementById("find")
// let replace = document.getElementById("replace")
// let button = document.getElementById("btnSearch")
// let reg = /\w+/ig

// button.addEventListener("click",function(ev){
//   ev.preventDefault()
//   let newTxt = txt.map(word => word.toLowerCase().match(reg).join("") === input.value.toLowerCase() ? replace.value : word)
//   target.textContent = newTxt.join(" ")
// })

// ------steve way
// document.addEventListener('DOMContentLoaded', function(){
//   let btn = document.getElementById('btnSearch');
//   btn.addEventListener('click', doFindAndReplace);
// });

// function doFindAndReplace(ev){
//   ev.preventDefault();
  
//   let find = document.getElementById('find').value;
//   let replace = document.getElementById('replace').value;
  
//   let p = document.querySelector('.target');
  
//   // while( p.textContent.indexOf(find) != -1 ){
//   //   //we put it inside while loop because replace method will replace first match only
//   //     p.textContent = p.textContent.replace(find, replace);
//   // }

//   // or instead of while loop you can use replaceAll method
//   p.textContent = p.textContent.replaceAll(find, replace);
// }

// -------------------------------Modifiying text input---------------
// ----------keyup & keypress & keydown & input
// document.addEventListener('DOMContentLoaded', function(){
//   let txt = document.getElementById('txt');
//   // txt.addEventListener('keydown', upThing);  
//   //1st - no charcode. no input value added yet
//   // will trigger function before value of key written to input field 
  
//   // txt.addEventListener('keypress', upThing);  
//   //2nd - charcode. no input value added yet
//   // will trigger function after value of key written to input field but before keyup
//   // that's why no ev.target.value at first time (keydown)
  
//   // txt.addEventListener('keyup', upThing);     
//   //3rd - no charcode. input value added
//   // will trigger function after value of key written to input field and ev.target.value at first time is availabe
  
//   // txt.addEventListener('input', upThing); // best choice
//   //4th - no charcode but input value accessible/mutable
// });

// function upThing(ev){
//   let num = ev.charCode;
//   let letter = String.fromCharCode(num);
//   console.log(ev.type, num, letter, ev.target.value);
//   ev.target.value = ev.target.value.toUpperCase();
// }

// ----------------------------Cors with Fetch---------------------------
/*
- if you want to take response from different server (like MAMP)
you need to create .htaccess file and write 
(Header Set Access-Control-Allow-Origin *) inside the .htaccess file
to accept requests from any server and give it a response then add mode: 'cors' when sending request

- but if you want to take response from same serve 
no need to add .htaccess file and write (Header Set Access-Control-Allow-Origin *)
because its the same server and no need of cross origin policy (only between different servers)

* Note : mode: "no-cors" will return a opaque response
* Note : Live server can not read .htaccess file so use MAMP server better
*/
// let p;
        
// document.addEventListener('DOMContentLoaded', 
//     function(){
//         p = document.querySelector('main>p');
//         p.addEventListener('click', doFetch);
//     });

// function doFetch(ev){
//     let uri = "http://127.0.0.1:5500/json/darksky-sample.json"; // From Same Server
//     // let uri = "http://127.0.0.1:8888/json/darksky-sample.json"; // From MAMP Server
    
//     let h = new Headers();
//     h.append('Accept', 'application/json');
    
//     let req = new Request(uri, {
//         method: 'GET',
//         headers: h,
//         mode: 'cors'
//     });
    
//     fetch(req)
//     .then( (response)=>{
//         if(response.ok){
//             return response.json();
//         }else{
//             console.log(response)
//             throw new Error('BAD HTTP stuff');
//         }
//     })
//     .then( (jsonData) =>{
//         console.log(jsonData);
//         p.textContent = JSON.stringify(jsonData, null, 4);
//     })
//     .catch( (err) =>{
//         console.log('ERROR:', err.message);
//     });
// }


// --------------------------Authentication----------------
/*
Steps to create Password for your website (localHost) : 
[1] open terminal and go to location where you you want to save .htpasswd file at
[2] write on terminal  ( htpasswd -c .htpasswd userName )
[3] will ask you for PassWord and you will repeat the password then file created
[4] write on .htaccess file : 
      AuthType Basic
      AuthName "Write Yor Password"
      AuthUserFile  /Applications/MAMP/user-pass/.htpasswd
      Require valid-user

Steps to create Password for your website : 
[1] open file manager on the server
[2] add .htpasswd outSide the root Document (like www, htdocs or public_html)
[3] add .htaccess to the folder you want to put password on it and write inside .htaccess :
      AuthType Basic
      AuthName "Write Yor Password"
      AuthUserFile  location on server/.htpasswd
      Require valid-user

reference : 
https://websistent.com/password-protect-directories-using-htpasswd/
*/
// let p;
        
// document.addEventListener('DOMContentLoaded', 
//     function(){
//         p = document.querySelector('main>p');
//         p.addEventListener('click', doFetch);
//     });

// function doFetch(ev){
//     // let uri = "http://127.0.0.1:5500/json/darksky-sample.json"; // From Same Server
//     let uri = "http://127.0.0.1:8888/json/darksky-sample.json"; // From MAMP Server
    
//     let h = new Headers();
//     h.append('Accept', 'application/json');
//     let encoded = window.btoa("mido:secret") // to convert it to Base64
//     let auth = "Basic " + encoded // Basic is the type before i used token for github API
//     h.append("Authorization" , auth)
//     console.log(auth) // userName and Password Converted to Base64
//     let req = new Request(uri, {
//         method: 'GET',
//         headers: h,
//         // credentials : "include" // different domain will send cookies with request
//         credentials : "same-origin" // same domain
//     });
    
//     fetch(req)
//     .then( (response)=>{
//         if(response.ok){
//             return response.json();
//         }else{
//             console.log(response)
//             throw new Error('BAD HTTP stuff');
//         }
//     })
//     .then( (jsonData) =>{
//         console.log(jsonData);
//         p.textContent = JSON.stringify(jsonData, null, 4);
//     })
//     .catch( (err) =>{
//         console.log('ERROR:', err.message);
//     });
// }

// ------------------------------------Caching--------------------------
// try this on MAMP server not live server
// const DATATIMEOUT = 60;
        
// function fetchData(){
//     let url = 'http://127.0.0.1:8888/api/data.php';
//     // url = url + '?apikey=abd654e9d6cc52a1297dfee'; // this a simulation not require key you can remove this
//     fetch(url)
//     .then(response=>{
//         return response.json()
//     })
//     .then(data=>{
//         //now we need to check if the data is new ENOUGH
//         let t = data.time;
//         let p = data.people;
//         let output  = document.getElementById('output');
//         let oldtime = localStorage.getItem('westeros-time');
//         if( oldtime ){
//             //we have data
//             let intOldTime = parseInt(oldtime);
//             if( (intOldTime + DATATIMEOUT) < t){
//                 localStorage.setItem('westeros-time', t);
//                 let ps = JSON.stringify(p);
//                 localStorage.setItem('westeros-ppl', ps);
//                 output.textContent = 'List Updated';
//             }else{
//                 //no update required
//                 output.textContent = 'List IS Up to Date';
//             }
            
//         }else{
//             //no data
//             localStorage.setItem('westeros-time', t);
//             let ps = JSON.stringify(p);
//             localStorage.setItem('westeros-ppl', ps);
//             output.textContent = 'List Created';
//         }
//     })
//     .catch(err=>{
//         let output = document.getElementById('output');
//         output.textContent = JSON.stringify(err, null, 2);
//     })
// }

// function init(){
//     let h1 = document.querySelector('h1');
//     h1.addEventListener('click', fetchData);
//         //OR
//     let timmy = setInterval(fetchData, 20000); 
//         //once every 20 seconds
// }

// document.addEventListener('DOMContentLoaded', init);

// ---------------TransitionEnd and AnimationEnd---------------------
// document.addEventListener('DOMContentLoaded', function(){
//   let ps = document.querySelectorAll('p');
//   ps.forEach(p=>{
//       p.addEventListener('transitionend', glow);
//       p.addEventListener('animationend', noglow);
//   })
// });

// function glow(ev){
//   console.log('transitionend');
//   ev.currentTarget.style.animationName = 'glow';
// }

// function noglow(ev){
//   // we have to remove animation name and set it again to make animation works every time not only one time
//   ev.currentTarget.style.animationName = '';
// }

// ----------------------------XML file fetching--------------------
//XMLHttpRequest() - has responseXML property in the response
        
// document.addEventListener('DOMContentLoaded', ()=>{
//   //fetch the data as soon as the page has loaded
//   let url = "/xml/data.xml";
//   fetch(url)
//   .then(response=>response.text()) // like json() It returns a promise that resolves with a String
//   .then(data=>{
//       // console.log(data);  //string
//       let parser = new DOMParser(); //Provides the ability to parse XML or HTML source code from a string into a DOM Document.
//       let xml = parser.parseFromString(data, "application/xml");
//       document.getElementById('output').textContent = data;
//       console.log(xml);
//       buildHouseList(xml);
//       buildSwordList(xml);
//   });
// })

// function buildHouseList(x){
//   let list = document.getElementById('houses');
//   let houses = x.getElementsByTagName('house');
//   for(let i=0; i<houses.length; i++){
//       let li = document.createElement('li');
//       // let house = houses[i].firstChild.nodeValue; // here select firstChild (textNode) so to get value of text node you should use nodeValue property
//       let house = houses[i].textContent; // or you can directly use textContent property of the element 
//       li.textContent = house;
//       list.appendChild(li);
//   }
// }

// function buildSwordList(x){
//   let list = document.getElementById('swords');
//   let swords = x.getElementsByTagName('sword');
//   for(let i=0; i<swords.length; i++){
//       let li = document.createElement('li');
//       let swordName = swords[i].firstChild.nodeValue;
//       let person = swords[i].getAttribute('owner');
//       li.textContent = `${swordName} - ${person}`;
//       list.appendChild(li);
//   }
// }
// -------------------Controlling video by JS----------------------
// let vid;
// document.addEventListener('DOMContentLoaded', init);

// function init(){
//     document.getElementById('btnPlay').addEventListener('click', play);
//     document.getElementById('btnPaws').addEventListener('click', paws);
//     document.getElementById('btnStop').addEventListener('click', stop);
//     document.getElementById('btnRew').addEventListener('click', rew);
//     document.getElementById('btnFF').addEventListener('click', ff);
//     vid = document.getElementById('video');
//     let str = vid.canPlayType("video/mp4"); // maybe - properly - empty string ( can't play)
//     // console.log(str);// maybe
//     vid.volume = 0.9;  //  0 is mute  - 1 is maximum
// }

// function play(ev){
//     vid.play() // return promise because maybe will buffer so needs promise
//     .then(()=>{
//         console.log('video is playing')
//     })
//     .catch((err)=>{
//         console.log( {err} );
//     });
//     //after the video starts to play you can access text tracks
//     let tt = vid.textTracks;
//     let cues = tt[0].cues;
//     let activeCues = tt[0].activeCues;
//     console.log(activeCues)
//     console.log(tt);
//     console.log(`There are ${tt.length} text tracks`);
//     console.log( tt[0] );
//     console.log( cues );
//     console.log( cues.length );
//     console.log( cues[0] );
//     console.log( cues[0].text );
// }
// function paws(ev){
//     vid.pause(); // will not return a promise
//     console.log( vid.currentTime, "of", vid.duration, "seconds played");
//     console.log('video is paused. No Promise here');
// }
// function stop(ev){
//     vid.pause();
//     console.log( vid.currentTime);
//     vid.currentTime = 0;
// }
// function rew(ev){
//     console.log( vid.currentTime);
//     if( ! vid.fastSeek ){
//         vid.currentTime -= 20;
//     }else{
//         vid.fastSeek(-20) // not supported on all browsers
//         .then(()=>{
//             console.log('Video skipped forward 10 seconds')
//         })
//         .catch(err=>{
//             console.log({err});
//         })
//     }
//     console.log( vid.currentTime);
// }
// function ff(ev){
//     console.log( vid.currentTime);
//     if( ! vid.fastSeek ){
//         vid.currentTime += 20;
//     }else{
//         vid.fastSeek(20) // not supported on all browsers
//         .then(()=>{
//             console.log('Video skipped forward 10 seconds')
//         })
//         .catch(err=>{
//             console.log({err});
//         })
//     }
//     console.log( vid.currentTime);
// }

// ------------------------------Permission API--------------------------

// if(navigator.permissions){
//   //browser supports this

//   // method of the Permissions interface returns the state of a user permission on the global scope.
//   // The name of the API whose permissions you want to query
//   navigator.permissions.query({name:'geolocation'})
//   .then(function(permissionStatus) {  
//       console.log('geolocation permission state is ', permissionStatus.state);

//       permissionStatus.onchange = function() {  
//         console.log('geolocation permission state has changed to ', this.state);
//       };
//   });
//   // Indicates whether you want to show a notification for every message or be able to 
//   // send silent push notifications. default is false (userVisibleOnly:false) is not supported in all browsers
//   navigator.permissions.query({name:'push', userVisibleOnly:true})

//   // getCurrentPosition make a Request Asynchronously and accept 2 callback function success or fail
//   navigator.geolocation.getCurrentPosition(ftw, wtf);
//   function ftw(){console.log('yes')}
//   function wtf(){console.log('no')}
  
//   Notification.requestPermission(function(result) {  
//       if (result === 'denied') {  // when click deny
//           console.log('Permission wasn\'t granted. Allow a retry.');  
//           return;  
//       } else if (result === 'default') {   // default means close the prompt question
//           console.log('The permission request was dismissed.');  
//           return;  
//       }  
//       console.log('Permission was granted for notifications');  // when click allow
//   });
// }

// ------------------------------Clipboard---------------
/* if i add contenteditable="true" attribute on HTML element i can change the text from webpage
and if i cut , copy , paste will trigger the events here in JS File */

// ######### Option [1] using copy , cut , paste Built-in Events(clipboardEvents) : (work for safari)

// document.addEventListener('DOMContentLoaded', ()=>{
//     ['cut', 'copy', 'paste'].forEach(function(event) {
//         document.addEventListener(event, function(ev) {
//             console.log(event);   
//             if(ev.type == 'paste'){
//                 console.log(ev.clipboardData.getData('text')); // no need for premissions
//             }
//         });
//     });
// });

// // you can select any text and press btnCopy to copy text to clipboard or 
// // you can add in the webpage input element and take textContent from element
// // then add it to the input element then focus() and select() content on input
// // then copy it from input element to clipboard 
// // (you can not select text on regular element only you can focus and select text inside input element)

// document.getElementById('btnCopy').addEventListener('click', (ev)=>{
//     let pre = document.querySelector('pre');
//     let text = pre.textContent;
//     const input = document.createElement('input');
//     document.body.appendChild(input);
//     input.value = text;
//     input.focus();
//     input.select();
//     input.style.opacity = 0 // to make it hidden
    
//     const result = document.execCommand('copy'); // will trigger copy event on document you can not use dispatchEvent look below
//     if (result === 'unsuccessful') {
//         console.error('Failed to copy text.');
//     }
//     // if you want to use dispatchEvent instead of execCommand you have to create new event using 
//     // Event constructor and write the function of copy event you can not use builtin copy function
//     let copyEvent = new Event("copy");
//     pre.addEventListener("copy", navigator.clipboard.writeText(pre.textContent));
//     pre.dispatchEvent(copyEvent);
// });


// ######### Option [2] using clipboard writeText & readText properties (need Premissions) : 
// return a Promise which is resolved once the clipboard's contents have been updated.
//Over HTTPS only (or localhost)
//Only on active tabs
//Permissions for read and write are required (not work for safari) maybe my safari is old version or problem with premissions
// Get permission to access clipboard

// navigator.permissions.query({
//   name: 'clipboard-read', 
//   name: 'clipboard-write' 
// }).then(permissionStatus => {
//   // Will be 'granted', 'denied' or 'prompt':
//   console.log(permissionStatus.state);

//   // Listen for changes to the permission state
//   permissionStatus.onchange = () => {
//     console.log('Clipboard Permission State:', permissionStatus.state);
//   };
// });


// document.getElementById('btnCopy').addEventListener('click' , function(){
//   let pre = document.querySelector('pre');
//   navigator.clipboard.writeText(pre.textContent)
//   .then(() => {
//       console.log('Copied to clipboard');
//   })
//   .catch(err => {
//       // This can happen if the user denies clipboard permissions:
//       console.error('Could not copy text: ', err);
//   });
//   console.log(navigator.clipboard.readText()) // return Promise Pending 
//   navigator.clipboard.readText().then((clipText)=> console.log(clipText)) // return the Text in ClipBoard
// })

// ##### Clipboard has properties like (readText(), writeText() => for texts & read() , write() => for images)

// ---writeText() => copy text in the clipborad
// let pre = document.querySelector('pre');
//   navigator.clipboard.writeText(pre.textContent)
//   .then(() => {
//       console.log('Copied to clipboard');
//   })
//   .catch(err => {
//       // This can happen if the user denies clipboard permissions:
//       console.error('Could not copy text: ', err);
//   });

// readText() => Retrieve what was in the clipboard
// navigator.clipboard.readText()
// .then(text => {
//     console.log('Content in Clipboard is: ', text);
// })
// .catch(err => {
//     console.error('Failed to read clipboard contents: ', err);
// });

// // you can Add listener for the paste event
// document.addEventListener('paste', ev => {
//     //ev.preventDefault(); //<-- if you don't want the actual paste
    
//     navigator.clipboard.readText().then(text => {
//         console.log('Pasted text: ', text);
//     });
// });

// -----------------------Copy and Paste Events---------------------

// document.addEventListener('DOMContentLoaded', () => {
//   document.addEventListener('copy', doCopy);
//   document.addEventListener('paste', doPaste);
//   document.querySelector('h1').addEventListener('click', autoCopy);
// });

// function doCopy(ev) {
//   //ev is a ClipBoardEvent
//   console.log(ev)
//   // if you didn't preventDefault will copy the text as default without any changes (UPPERCASE)
//   ev.preventDefault();
//   // what has the user selected (return selection object and you can get the text by using toString())
//   // get the actual selected text if you want to make changes to it
//   let selection = document.getSelection();
//   selection = selection.toString().toUpperCase();
//   console.log(selection); //UPPERCASE
//   // setData method for copy event and getData method for paste event
//   ev.clipboardData.setData('text/plain', selection);

//   // or you can use navigator.clipboard.writeText()
//   navigator.clipboard.writeText(selection)
// }

// function doPaste(ev) {
//   // ev.clipboardData - is a DataTransfer object
//   let data = ev.clipboardData.getData('text/plain');
//   let txtNode = document.createTextNode(data)
//   //data is the content we copied above
//   console.log(data);

//   // or you can use navigator.clipboard.readText()
//   navigator.clipboard.readText().then(text => {
//     console.log('Pasted text: ', text);
//   });

//   // to know which element i selected to do the paste (one of two <p> that has attribute contenteditable="true") 
//   // selection object has property called parentElement 
//   // if you just click on the element text will be "" if you select text the text will be selected text
//   let selection = document.getSelection();
//   // to make a sure that is a valid selection
//   if (!selection.rangeCount) return false;
//   //remove the old content that was selected (its the default behaviour of browser to remove
//   // selected text and paste the new text above but because we preventDefault we disable 
//   // this default behavior and we need to delete selected text manually)
//   selection.deleteFromDocument();
//   //inserts before the selected area (you can add text node or element node and add css to this element(red color for exp.))
//   selection.getRangeAt(0).insertNode(txtNode);
//   // selection.getRangeAt(0).insertNode(span);
// }

// function autoCopy(ev) {
//   let h1 = ev.target;
//   let select = document.getSelection();
//   // remove all ranges to create a new one (selecting multiple ranges not supported in all browsers)
//   select.removeAllRanges();
//   let range = document.createRange();
//   // select the h1.firstChild => text node
//   range.selectNode(h1.firstChild); 
//   //highlight the whole selection
//   select.addRange(range);
//   console.log(range)
//   console.log(select)
//   //then tell the browser to do a copy ( this will trigger the doCopy function )
//   document.execCommand('copy');
// }

// -----------------------------------Scrolling------------------------
// let h1 = document.querySelector('h1');
// h1.addEventListener('click', (ev)=>{
//     //scrollBy(x, y) scrollTo(x, y)
//     //scrollX(x) scrollY(y)
//     //onscroll
//     console.group();
//     //top of the visible screen
//     console.log('client', ev.clientX, ev.clientY);    
//     //top of the document(webpage)
//     console.log('page', ev.pageX, ev.pageY);
//     // top & left location of click event inside element h1
//     console.log('offsetX&Y', ev.offsetX, ev.offsetY);
//     // top & left location of h1 element at the page ( will not affected by scrolling)
//     console.log('offset', h1.offsetLeft, h1.offsetTop);
//     // top & left location of browser itself related to laptop screen ( will not affected by scrolling)
//     console.log('screen window', window.screenX, window.screenY);
//     // top & left location of click event related to laptop screen
//     console.log('screen ev', ev.screenX, ev.screenY);
//     console.groupEnd();
//     window.scrollBy(0, 600); //document.querySelector('main').classList.toggle('up')
// });


// window.addEventListener('scroll', (ev)=>{
//     console.group();
//     console.log('client', ev.clientX, ev.clientY); // not work with scrolling work only with click event
//     console.log('page', ev.pageX, ev.pageY); // not work with scrolling work only with click event
//     console.log('offsetX&Y', ev.offsetX, ev.offsetY);// not work with scrolling work only with click event
//     console.log('offset', h1.offsetLeft, h1.offsetTop);
//     console.log('screen window', window.screenX, window.screenY);
//     console.log('screen ev', ev.screenX, ev.screenY); // not work with scrolling work only with click event
//     console.groupEnd();
    
//     setTimeout( ()=>{
//         window.scrollTo(0,0);
//     }, 2000);
// })

// ------------------------International Number and Currency Formatting----------------
// let number = 123456.789;
        
// console.group('numbers');
// console.log(new Intl.NumberFormat('en-CA', { style: 'decimal'}).format(number));
// console.log(new Intl.NumberFormat('fr-CA', { style: 'decimal'}).format(number));
// console.groupEnd('numbers');

// console.group('currency');
// console.log(new Intl.NumberFormat('en-CA', { style: 'currency', currency: 'CAD', useGrouping: true }).format(number));
// // expected output: "$123,456.79"


// let num = new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' })
// num.format(number);


// console.log(new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(number));
// // expected output: "£123,456.79"

// console.log(new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(number));
// // expected output: "123.456,79 €"

// // the Japanese yen doesn't use a minor unit
// console.log(new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(number));
// // expected output: "￥123,457"
// console.groupEnd('currency');

// // limit to three significant digits
// console.log(new Intl.NumberFormat('en-IN', { maximumSignificantDigits: 3 }).format(number));
// // expected output: "1,23,000"

// ---------------------------International Localized Time & Date-------------
// let today = new Date();
        
// let us = new Intl.DateTimeFormat('en-US').format(today);
// let ca = new Intl.DateTimeFormat('en-CA').format(today);
// let gb = new Intl.DateTimeFormat('en-GB').format(today);
// let de = new Intl.DateTimeFormat('de-DE').format(today);
// let ar = new Intl.DateTimeFormat('ar').format(today);
// let xx = new Intl.DateTimeFormat('ar', 'sv').format(today);
// let sv = new Intl.DateTimeFormat('sv', 'ar').format(today);
// document.querySelector('p[lang=en-US]').textContent = us;
// document.querySelector('p[lang=sv-SV]').textContent = sv;

// console.log(us);
// console.log(ca);
// console.log(gb);
// console.log(de);
// console.log(ar);
// console.log(xx);
// console.log(sv);

// // Beware that the timezone returned by toISOString is always zero UTC offset, 
// // whereas in toLocaleDateString it is the user agent's timezone.
// console.log("#############")
// const d = new Date() // today, now

// // Timezone zero UTC offset
// console.log(d.toISOString().slice(0, 10)) // YYYY-MM-DD

// // Timezone of User Agent
// console.log(d.toLocaleDateString('en-CA')) // YYYY-MM-DD
// console.log(d.toLocaleDateString('en-US')) // M/D/YYYY
// console.log(d.toLocaleDateString('de-DE')) // D.M.YYYY
// console.log(d.toLocaleDateString('pt-PT')) // DD/MM/YYYY

// --------------------Internationalization & Localization of Strings--------
// let languageCodes = ['sv','en','fr','dk','de','cn','ru', 'el', 'no'];
// console.log( Intl.Collator.supportedLocalesOf(languageCodes) ); // return an Array of supported languages

// // if you did not add an argument to Intl.Collator() will take default language of my computer which is en
// console.log(new Intl.Collator().compare('a', 'z')); // -1 because UTF value of a less than UTF of z
// console.log(new Intl.Collator().compare('z', 'a')); // 1 because UTF value of z bigger than UTF of a
// console.log(new Intl.Collator('en').compare('a', 'z'));

// console.group('sv');
// console.log(new Intl.Collator('sv').compare('ä', 'z'));
// console.log(new Intl.Collator('sv').compare('ä', 'a'));

// console.log(new Intl.Collator('sv', {
//     sensitivity: "variant", // base (a = A & a = ä) / case (a = A & a != ä) / variant (a != A & a != ä)
//     ignorePunctuation: true, // to ignore Punctuations like (, . / " ")
//     numeric: true, // to compare as numbers not strings
//     caseFirst: false // "upper" to make uppercase at first always / "lower" to make lowercase at first always / false is the default
// }).compare('10', '2'));

// console.log(new Intl.Collator('sv').compare('å', 'ä'));
// console.log(new Intl.Collator('sv').compare('å', 'å'));
// console.groupEnd('sv');

// console.log(new Intl.Collator('de').compare('ß', 's'));

// console.log(new Intl.Collator('dk').compare('å', 'z'));
// console.log(new Intl.Collator('dk').compare('æ', 'z'));

// ------------------------------Audio in JS---------------------------

// document.addEventListener('DOMContentLoaded', init);
// // we are creating an object with audio files names when the sound works we will change the value
// // of it from null to it's name that will help us to check if the sound already work now and
// // we trigger the event to work it again will pause the old sound and start the sound from start
// // to avoid sound work twice at same time
// const SOUNDS = {
//     'clear-throat':null,
//     'doorbell':null,
//     'static':null
// };
// // you can create a button for exp. to ask the user he needs sounds to work or not (true user allows sound to work)
// let allowSound = true; 

// function init(){
//     let p1 = document.querySelector('p[data-file]');
//     let p2 = document.querySelector('p:nth-of-type(2)');
//     let p3 = document.querySelector('p:last-of-type');
//     p1.addEventListener('click', play);
//     p2.addEventListener('mouseover', play);
//     p3.addEventListener('dblclick', play);
// }

// function play(ev){
//     let p = ev.currentTarget;
//     ev.preventDefault();
    
//     let fn = p.getAttribute('data-file');
//     let src = './media/' + fn + '.mp3';
//     if( SOUNDS[fn] ){
//         SOUNDS[fn].pause();
//         SOUNDS[fn] = null;
//     }
//     console.log(src);
    
//     // you can create audio element or select it from HTML 
//     //let audio = document.getElementById("a"); // [1] selecting the audio element
//     let audio = document.createElement('audio'); // [2] creating the audio element
//     //audio.removeAttribute('controls');
//     //document.body.appendChild(audio); // you should not add the audio element to page it will work anyway
//     audio.src = src;
//     audio.volume = 0.2;
//     //change the starting position in the file
//     //audio.currentTime = 0.8;
//     if(allowSound){
//         SOUNDS[fn] = audio;
//         audio.setAttribute('data-file', fn);
//         audio.play();
//     }
    
    

//     // Event list for <audio> and <video>
//     // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events

//     //listen for the event that ends sound
//     audio.addEventListener('playing', goAudio);
//     audio.addEventListener('ended', doneAudio);
// }

// function goAudio(ev){
//     console.log(ev.target.src, 'has started playing');
// }

// function doneAudio(ev){
//     console.log(ev.target.src, 'has finished playing');
//     let fn = ev.target.getAttribute('data-file');
//     SOUNDS[fn] = null;
// }

// ---------------------------CSS Variables------------------
// document.addEventListener('DOMContentLoaded', ()=>{
//   let html = document.documentElement; // HTML element which is :root in CSS File
//   let body = document.body; // body element
//   html.style.setProperty('--COLOR', '#bada55'); // will override variable in CSS File
// })

// ------------------open and close TAB from JS--------------
// you can open an html File or URL

// let openH2 = document.getElementById("open");
// openH2.addEventListener('click', (ev)=>{
//     //window.open(url, windowName, [windowFeatures]);
//     //https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features
//     let options = 'statusbar=no,height=300,width=600';
//     // let options = ""; // if you want to open a new TAB you cannot add height=300,width=600
    
//     // [1] open different html file
//     // _blank or Fred or any other name => open a new TAB or new Window depend on options
//     // _self => open at same TAB even if you added height & width in options
//     //let ref = window.open('new.html', 'Fred', options); 
//     //let ref = window.open('new.html', '_self', options); 
//     // [2] open URL
//     let ref = window.open('https://www.google.com/', '_blank', options); 
    
    
//     let closeH2 = document.getElementById('close');
//     closeH2.style.cursor = 'pointer';
//     closeH2.addEventListener('click', (ev)=>{
//         ref.close();    
//     });
// });

// you can open a different html file you can add this script to open 
// document.addEventListener('DOMContentLoaded', ()=>{
//   console.log(window.opener); // this will refer to the html file that opened the new html file
//   console.log(window.opener.location.href)
//   //put the focus back on the opener
//   window.opener.focus();
// })

// ---------------------Capturing Media (Works also on Mobile Devices)-----------
/* 
- if you add capture attribute to input element (type ="file") will open camera on mobile Phones
- if you want to choose from gallery on mobile Phones you should remove capture attribute
- if you want to upload chosen files you should add enctype="multipart/form-data" attribute to form element 
- accept="audio/*" isn't actually supported on iOS " but audio/mp3 works fine
- accept="image/*" and accept="video/*" are supported on iOS "
- to capture record on ios see next tutorials

*/
// document.addEventListener('DOMContentLoaded', (ev)=>{
//   let form = document.getElementById('myform');
//   //get the captured media file
//   let input = document.getElementById('capture');
  
//   input.addEventListener('change', (ev)=>{
//       console.dir( input.files[0] );
//       if(input.files[0].type.indexOf("image/") > -1){
//           let pImg = document.getElementById('img');
//           let img = document.createElement("img")
//           img.src = window.URL.createObjectURL(input.files[0]);
//           pImg.appendChild(img)
//       }
//       else if(input.files[0].type.indexOf("audio/") > -1 ){
//           let pAudio = document.getElementById('audio');
//           let audio = document.createElement("audio")
//           audio.src = window.URL.createObjectURL(input.files[0]);
//           audio.setAttribute("controls","")
//           pAudio.appendChild(audio)
//       }
//       else if(input.files[0].type.indexOf("video/") > -1 ){
//           let pVideo = document.getElementById('video');
//           let video = document.createElement('video');
//           video.src=window.URL.createObjectURL(input.files[0]);
//           video.setAttribute("controls","")
//           pVideo.appendChild(video)
//       }
      
      
//   })
  
// })

// ---------------MediaCapture, MediaRecorder and Streams API--------------
/*
Steps : 
[1] Create Video Stream Using getUserMedia Method
[2] Record the Stream Using MediaRecorder Constructor
[3] show it to the user and download it or upload it on the server 

getUserMedia returns a Promise

resolve - returns a MediaStream Object

reject returns one of the following errors : 
AbortError - generic unknown cause
NotAllowedError (SecurityError) - user rejected permissions
NotFoundError - missing media track
NotReadableError - user permissions given but hardware/OS error
OverconstrainedError - constraint video settings preventing
TypeError - audio: false, video: false

note : we need to use chunks incase of using timeInterval with mediaRecorder.start(200)
because we need an array to hold small videos reach  200 miliseconds 

navigator.mediaDevices.getUserMedia + MediaRecorder create WEBM files without 
duration metadata.
This library appends missing metadata section right to the file blob.
https://github.com/yusitnikov/fix-webm-duration

*/

// (((((Options Object contains audio and video options ))))) => will be passed as argument to getUserMedia Method 

// let options = { 
//   audio: true, // to allow or not allow audio
//   video: {  
//       facingMode: "user", // means front camera
//       width: { min: 640, ideal: 1280, max: 1920 },
//       height: { min: 480, ideal: 720, max: 1080 } 
//   } 
// }; 
// exp. of other options
// // width: 1280, height: 720  -- preference only
// // facingMode: {exact: "user"}
// // facingMode: "environment"

// ----Step 1 => Create Video Stream Using getUserMedia : will return a Promise when resolve returns a MediaStream Object ( Video Stream) 

// navigator.mediaDevices.getUserMedia(options)
// .then(function(mediaStreamObj) {

//   // if you want you can show Video Stream to the User 
//   // let video = document.querySelector('video');
//   // if ("srcObject" in video) { 
//   //   // new browser video element has srcObject property
//   //   video.srcObject = mediaStreamObj;
//   // } else {
//   //     //old version does not have srcObject 
//   //     video.src = window.URL.createObjectURL(mediaStreamObj);
//   // }
  
//   // video.onloadedmetadata = function(ev) {
//   //     //show in the video element what is being captured by the webcam
//   //     video.play();
//   // };
  
//   
//   // ---Step 2 => Record the Stream Using MediaRecorder Constructor : accept video stream as argument
//   let start = document.getElementById('btnStart');
//   let stop = document.getElementById('btnStop');
//   let vidSave = document.getElementById('vid2');
//   let mediaRecorder = new MediaRecorder(mediaStreamObj);
//   let chunks = [];
//   let singleBlob;
  
//   start.addEventListener('click', (ev)=>{
//       if(mediaRecorder.state === "inactive"){
//         mediaRecorder.start();
//         console.log(mediaRecorder.state);
//       }
//   })
//   stop.addEventListener('click', (ev)=>{
//       if(mediaRecorder.state === "recording" ){
//         mediaRecorder.stop();
//         console.log(mediaRecorder.state);
//       }
//   });
//   mediaRecorder.ondataavailable = function(ev) {
//     chunks.push(ev.data); // ev.data here is blob
//     singleBlob = ev.data
//   }

//   mediaRecorder.onstop = (ev)=>{
//     // incase of using mediaRecorder.start(200) with time Interval we need to create chunks array  
//     // because we want array contains small videos each one is 200 miliseconds
//     // let blob = new Blob(chunks, { 'type' : 'video/mp4;' }); 
//     // incase of single video recorded 
//       let blob = singleBlob
//       let videoURL = window.URL.createObjectURL(blob);
//       vidSave.src = videoURL;
//   }
// })
// .catch(function(err) { 
//   console.log(err.name, err.message); 
// });



// //----only use this if getUserMedia not included in realy older browsers 
// if (navigator.mediaDevices === undefined) {
//   navigator.mediaDevices = {}; // adding  mediaDevices as a object inside navigator 
//   navigator.mediaDevices.getUserMedia = function(options) { //adding getUserMedia property
//       let getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia; // prefixes
//       if (!getUserMedia) {
//           return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
//       }
//       return new Promise(function(resolve, reject) {
//           getUserMedia.call(navigator, options, resolve, reject);
//       });
//   }
// }

// ----------------------Record only Audio---------------
/*
Steps : 
[1] Create Video Stream Using getUserMedia Method
[2] Record the Stream Using MediaRecorder Constructor
[3] show it to the user and download it or upload it on the server 
*/

// works on mobile phone also but should on https not http

// let options = { 
//   audio: true, 
//   video: false
// };

// navigator.mediaDevices.getUserMedia(options)
// .then(function(mediaStreamObj) { 
//   let start = document.getElementById('btnStart');
//   let stop = document.getElementById('btnStop');
//   let output = document.getElementById("output")
//   let mediaRecorder = new MediaRecorder(mediaStreamObj);
//   let singleBlob;
  
//   start.addEventListener('click', (ev)=>{
//       if(mediaRecorder.state === "inactive"){
//         mediaRecorder.start();
//       }
//   })
//   stop.addEventListener('click', (ev)=>{
//       if(mediaRecorder.state === "recording" ){
//         mediaRecorder.stop();
//       }
//   });
//   mediaRecorder.ondataavailable = function(ev) { 
//     singleBlob = ev.data
//   }

//   mediaRecorder.onstop = (ev)=>{
//       let videoURL = window.URL.createObjectURL(singleBlob);
//       let videoEl = document.createElement("audio") 
//       videoEl.setAttribute("controls","")
//       videoEl.src = videoURL;
//       output.appendChild(videoEl)
//   }
// })
// .catch(function(err) { 
//   console.log(err.name, err.message); 
// });

// ----------------------Screen Capture API----------------
/*
Steps : 
[1] Create Video Stream Using get getDisplayMedia Method
[2] Record the Stream Using MediaRecorder Constructor
[3] show it to the user and download it or upload it on the server 
 */
// let options = {
//   video : {
//     MediaSource : "screen",
//     width: 640,
//     height: 480 
//   },
//   audio : true
// }

// navigator.mediaDevices.getDisplayMedia(options)
// .then(function(mediaStreamObj){
//   let start = document.getElementById('btnStart');
//   let stop = document.getElementById('btnStop');
//   let output = document.getElementById("output")
//   let mediaRecorder = new MediaRecorder(mediaStreamObj);

//   start.addEventListener('click', (ev)=>{
//     if(mediaRecorder.state === "inactive"){
//       mediaRecorder.start();
//     }
//   })
//   stop.addEventListener('click', (ev)=>{
//       if(mediaRecorder.state === "recording" ){
//         mediaRecorder.stop();
//       }
//   });
//   mediaRecorder.ondataavailable = function(ev) { 
//     singleBlob = ev.data
//   }

//   mediaRecorder.onstop = (ev)=>{
//       let videoURL = window.URL.createObjectURL(singleBlob);
//       let videoEl = document.createElement("video") 
//       videoEl.setAttribute("controls","")
//       videoEl.src = videoURL;
//       output.appendChild(videoEl)
//   }
// })
// .catch(function(err) { 
//   console.log(err.name, err.message); 
// });


// ------------------Screen Capture API with Audio-----------------
// let start = document.getElementById('btnStart');
// let stop = document.getElementById('btnStop');
// let output = document.getElementById("output")
// let singleBlob;

// async function recordScreen() { 
//   const mimeType = 'video/webm';  
//   const displayStream = await navigator.mediaDevices.getDisplayMedia({video: true, audio: true}); 
//   const voiceStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); 
//   // merge displayStream and voiceStream
//   let tracks = [...displayStream.getTracks(), ...voiceStream.getAudioTracks()] 
//   const stream = new MediaStream(tracks); 
//   handleRecord(stream, mimeType) 
// }
// recordScreen()

// const handleRecord = function (stream, mimeType) {  
//   console.log(arguments)   
//   // let recordedChunks = [];      
//   const mediaRecorder = new MediaRecorder(stream);
//   start.addEventListener('click', (ev)=>{
//     if(mediaRecorder.state === "inactive"){
//       mediaRecorder.start();
//     }
//   })
//   stop.addEventListener('click', (ev)=>{
//       if(mediaRecorder.state === "recording" ){
//         mediaRecorder.stop();
//       }
//   });    
//   mediaRecorder.ondataavailable = function (e) {     
//     if (e.data.size > 0) {       
//       // recordedChunks.push(e.data); 
//       singleBlob = e.data
//       console.log(singleBlob)
//     }        
//   };   
//   mediaRecorder.onstop = function () {     
//     // const blob = new Blob(recordedChunks, {       type: mimeType     }); 
//     let videoURL = window.URL.createObjectURL(singleBlob);
//     let videoEl = document.createElement("video") 
//     videoEl.setAttribute("controls","")
//     videoEl.src = videoURL;
//     output.appendChild(videoEl)
//     // recordedChunks = []   
//   };
//   // mediaRecorder.start(200) // need to use recordedChunks instead of single blob
// };


// -----------------------Performance API---------------
/*
- performance.now() better than date.now() because it's more accurate with date.now() the smaller 
number you can get is 1 milisecond but with performance.now() you can get 0.00005 milisecond

-performance.mark("name of mark ") like performance.now() but you don't have to assign
performance.now() to variables and substract to get difference between 2 performance.now()
just make 2 performance.mark() and give each one an unique name then use performance.measure()
to get a PerformanceMeasure Object which has a lot of properties like startTime of first performance.mark()
and duration property (difference between 2 performance.mark()) 

-performance.getEntries() => array of all performance and you can get specific one by name or type
 */
// let pNow1 = performance.now()
// performance.mark("start")

// for(let i =0; i< 10000; i++){}

// let pNow2 = performance.now()
// performance.mark("end")
// console.log(pNow2 - pNow1)
// console.log(performance.measure("result", "start","end").duration)
// console.log(performance.getEntries()) 
// console.log(performance.getEntriesByName("start")) 
// console.log(performance.getEntriesByType("measure")) 

// -----------------------CSS Attibute selector-------------
/******
[data-beatle] - has attribute
[data-beatle = "john"] - exact => match only data-beatle = "john"
[data-beatle *= "o"]  -contains o => match anything contains "o" data-beatle = "john" or data-beatle = "toni"
[data-beatle ~= "john"]  - space separated => match data-beatle = "hi john depp"
[data-beatle |= "john"]  - hyphen separated, 1st value => match data-beatle = "john-depp"
[data-beatle ^= "john"]  - starts with => match data-beatle = "john depp"
[data-beatle $= "john"]  - ends with => match data-beatle = "hi john"

main [data-beatle |="john"]{
  color: gold;
}
a[href^="https://"]{
  all anchors with href that begins with https:// 
  padding: 2rem;
}
a[href$= ".pdf"]{
  all anchors that link to pdfs
  color: red;
}

and you can use this selectors with querySelector : 
let a = document.querySelector('a[href^="https://"]') //match all <a> with href attribute that start with "https://"
a.style.fontSize = '3rem';
***/

// ------------------------------CSS :target-------------------------
/*
<a> with href="#id" when you click on it the page will scroll to the element which has this is
and you can select this element by :target(look at CSS File)
here we are trying to style :target element and style also <a> with JS Code
 */
// window.addEventListener('load', setCurr);
// window.addEventListener('hashchange', setCurr);

// function setCurr(ev){
//     let p, a, id;
//     //:target not available until...
//     p = document.querySelector(':target'); 
//     console.log(ev.type, p);
//     if(p){
//         id = `a[href="#${p.id}"]`;
//         //console.log(id)
//         document.querySelectorAll('.current').forEach( anchor =>{
//             anchor.classList.remove('current');
//         })
//         a = document.querySelector(id);
//         a.classList.add('current');
//     }
// }

// ------------------------------Web Workers--------------------------
/*
JS is Single threaded but with web worker you can create another js File which has a another 
Thread and work separetly and you can from main.js trigger  functions or fetch calls 
or anything else and get back the result from web worker file to main.js

Steps : 
[1] create worker instance
[2] add Event Listener ("message")
[3] send message to web-work.js file => worker.postMessage()

* difference between JS Asynchronous and Web Workers :
- JavaScript is single-threaded (1 thread => 1 CPU)
- Webworkers enable real parallelism (multiple threads on multiple CPU’s)
but Web Worker has no access to DOM but you have access to navigator object , location Object ,.....
 */
// let output = document.getElementById('output');
// let worker;

// document.addEventListener('DOMContentLoaded', init);

// function init(){
//     // [1]create worker instance
//     worker = new Worker('webWorkers/web-work.js');
//     // [2] add Event Listener and callback Function will trigger when web-work message us back
//     worker.addEventListener('message', workerMessaged);
//     worker.addEventListener('error', workerError);
    
//     // [3]send message to web-work.js file
//     // worker.postMessage('Get Started');
    
//     document.body.addEventListener('click', ()=>{
//         //send another message to the worker
//         // worker.postMessage('Other');
//         worker.postMessage("fetch");
//     })
// }

// function workerMessaged(ev){
//     let data = ev.data;
//     // output.textContent += data + '\n'
//     output.textContent += JSON.stringify(data, null, 2) + '\n';
// }

// function workerError(err){
//     console.log(err.message, err.filename);
// }

// ---------------------Orientation API-------------------

// let orn = getOrientation();
// let out = document.getElementById('output');
// out.textContent = orn;
// // screen.orientation is not supported in ios but window.orientation is supported

// // here we mix between screen.orientation and window.orientation to be supported in both ios and desktop
// function getOrientation() {
//   let _orn;
//   if(window.orientation === 0 || window.orientation === 90 || window.orientation === -90 || window.orientation === 180){
//     _orn = window.orientation; // ios => up 0 - down 180 - left 90 - right -90
//   }else if(screen.msOrientation || screen.orientation || screen.mozOrientation){
//     _orn = (screen.msOrientation || screen.orientation || screen.mozOrientation).type; // desktop
//   }
//   switch(_orn){
//       case 0:
//       case 'portrait-primary':
//         window.alert("portrait-primary")
//         break
//       case 180:
//       case 'portrait-secondary':
//         window.alert("portrait-secondary")
//           break;
//       case -90:
//       case 'landscape-primary':
//         window.alert("landscape-primary")
//           break;
//       case 90:
//       case 'landscape-secondary':
//         window.alert("landscape-secondary")
//           break;
//       case undefined:
//         window.alert("not supported")
//           break;
//       default:
//           //something unknown
//   }
//   return _orn;
// }

// window.addEventListener('orientationchange', (ev)=>{
//     orn = getOrientation();
//     out.textContent = orn;
//     console.dir(ev)
// })

// ---------------------------LocalStorage Shopping Cart--------------------
// 2 challenges for you 
// [1] add delete btn to items in cart 
// [2]update total price when incrementing items in cart

// const CART = {
//   KEY: 'bkasjbdfkjasdkfjhaksdfjskd',
//   contents: [],
//   init(){
//       //check localStorage and initialize the contents of CART.contents
//       let _contents = localStorage.getItem(CART.KEY);
//       if(_contents){
//           CART.contents = JSON.parse(_contents);
//       }else{
//           //dummy test data
//           CART.contents = [
//               {id:1, title:'Apple', qty:5, itemPrice: 0.85},
//               {id:2, title:'Banana', qty:3, itemPrice: 0.35},
//               {id:3, title:'Cherry', qty:8, itemPrice: 0.05}
//           ];
//           CART.sync();
//       }
//   },
//   async sync(){
//       let _cart = JSON.stringify(CART.contents);
//       // localStorage.setItem and getItem 99% act synchronous but 1% (when data very big and bad processor will act as asynchronous)
//       await localStorage.setItem(CART.KEY, _cart); 
//   },
//   find(id){
//       //find an item in the cart by it's id
//       let match = CART.contents.filter(item=>{
//           if(item.id == id)
//               return true;
//       });
//       if(match && match[0])
//           return match[0];
//   },
//   add(id){
//       //add a new item to the cart
//       //check that it is not in the cart already
//       if(CART.find(id)){
//           CART.increase(id, 1);
//       }else{
//           let arr = PRODUCTS.filter(product=>{
//               if(product.id == id){
//                   return true;
//               }
//           });
//           if(arr && arr[0]){
//               let obj = {
//                   id: arr[0].id,
//                   title: arr[0].title,
//                   qty: 1,
//                   itemPrice: arr[0].price
//               };
//               CART.contents.push(obj);
//               //update localStorage
//               CART.sync();
//           }else{
//               //product id does not exist in products data
//               console.error('Invalid Product');
//           }
//       }
//   },
//   increase(id, qty=1){
//       //increase the quantity of an item in the cart
//       CART.contents = CART.contents.map(item=>{
//           if(item.id === id)
//               item.qty = item.qty + qty;
//           return item;
//       });
//       //update localStorage
//       CART.sync()
//   },
//   reduce(id, qty=1){
//       //reduce the quantity of an item in the cart
//       CART.contents = CART.contents.map(item=>{
//           if(item.id === id)
//               item.qty = item.qty - qty;
//           return item;
//       });
//       CART.contents.forEach(async item=>{
//           if(item.id === id && item.qty === 0)
//               await CART.remove(id);
//       });
//       //update localStorage
//       CART.sync()
//   },
//   remove(id){
//       //remove an item entirely from CART.contents based on its id
//       CART.contents = CART.contents.filter(item=>{
//           if(item.id !== id)
//               return true;
//       });
//       //update localStorage
//       CART.sync()
//   },
//   empty(){
//       //empty whole cart
//       CART.contents = [];
//       //update localStorage
//       CART.sync()
//   },
//   sort(field='title'){
//       //sort by field - title, price
//       //return a sorted shallow copy of the CART.contents array
//       let sorted = CART.contents.sort( (a, b)=>{
//           if(a[field] > b[field]){
//               return 1;
//           }else if(a[field] < a[field]){
//               return -1;
//           }else{
//               return 0;
//           }
//       });
//       return sorted;
//       //NO impact on localStorage
//   },
//   logContents(prefix){
//       console.log(prefix, CART.contents)
//   }
// };

// let PRODUCTS = [];

// document.addEventListener('DOMContentLoaded', ()=>{
//   //when the page is ready
//   getProducts( showProducts, errorMessage );
//   //get the cart items from localStorage
//   CART.init();
//   //load the cart items
//   showCart();
// });

// function showCart(){
//   let cartSection = document.getElementById('cart');
//   cart.innerHTML = '';
//   let s = CART.sort('qty');
//   s.forEach( item =>{
//       let cartitem = document.createElement('div');
//       cartitem.className = 'cart-item';
      
//       let title = document.createElement('h3');
//       title.textContent = item.title;
//       title.className = 'title'
//       cartitem.appendChild(title);
      
//       let controls = document.createElement('div');
//       controls.className = 'controls';
//       cartitem.appendChild(controls);
      
//       let plus = document.createElement('span');
//       plus.textContent = '+';
//       plus.setAttribute('data-id', item.id)
//       controls.appendChild(plus);
//       plus.addEventListener('click', incrementCart)
      
//       let qty = document.createElement('span');
//       qty.textContent = item.qty;
//       controls.appendChild(qty);
      
//       let minus = document.createElement('span');
//       minus.textContent = '-';
//       minus.setAttribute('data-id', item.id)
//       controls.appendChild(minus);
//       minus.addEventListener('click', decrementCart)
      
//       let price = document.createElement('div');
//       price.className = 'price';
//       let cost = new Intl.NumberFormat('en-CA', 
//                       {style: 'currency', currency:'CAD'}).format(item.qty * item.itemPrice);
//       price.textContent = cost;
//       cartitem.appendChild(price);
      
//       cartSection.appendChild(cartitem);
//   })
// }

// function incrementCart(ev){
//   ev.preventDefault();
//   let id = parseInt(ev.target.getAttribute('data-id'));
//   CART.increase(id, 1);
//   let controls = ev.target.parentElement;
//   let qty = controls.querySelector('span:nth-child(2)');
//   let item = CART.find(id);
//   if(item){
//       qty.textContent = item.qty;
//   }else{
//       document.getElementById('cart').removeChild(controls.parentElement);
//   }
// }

// function decrementCart(ev){
//   ev.preventDefault();
//   let id = parseInt(ev.target.getAttribute('data-id'));
//   CART.reduce(id, 1);
//   let controls = ev.target.parentElement;
//   let qty = controls.querySelector('span:nth-child(2)');
//   let item = CART.find(id);
//   if(item){
//       qty.textContent = item.qty;
//   }else{
//       document.getElementById('cart').removeChild(controls.parentElement);
//   }
// }

// function getProducts(success, failure){
//   //request the list of products from the "server"
//   const URL = "https://prof3ssorst3v3.github.io/media-sample-files/products.json";
//   fetch(URL, {
//       method: 'GET',
//       mode: 'cors'
//   })
//   .then(response=>response.json())
//   .then(showProducts)
//   .catch(err=>{
//       errorMessage(err.message);
//   });
// }

// function showProducts( products ){
//   PRODUCTS = products;
//   //take data.products and display inside <section id="products">
//   let imgPath = 'https://prof3ssorst3v3.github.io/media-sample-files/';
//   let productSection = document.getElementById('products');
//   productSection.innerHTML = "";
//   products.forEach(product=>{
//       let card = document.createElement('div');
//       card.className = 'card';
//       //add the image to the card
//       let img = document.createElement('img');
//       img.alt = product.title;
//       img.src = imgPath + product.img;
//       card.appendChild(img);
//       //add the price
//       let price = document.createElement('p');
//       let cost = new Intl.NumberFormat('en-CA', 
//                               {style:'currency', currency:'CAD'}).format(product.price);
//       price.textContent = cost;
//       price.className = 'price';
//       card.appendChild(price);
      
//       //add the title to the card
//       let title = document.createElement('h2');
//       title.textContent = product.title;
//       card.appendChild(title);
//       //add the description to the card
//       let desc = document.createElement('p');
//       desc.textContent = product.desc;
//       card.appendChild(desc);
//       //add the button to the card
//       let btn = document.createElement('button');
//       btn.className = 'btn';
//       btn.textContent = 'Add Item';
//       btn.setAttribute('data-id', product.id);
//       btn.addEventListener('click', addItem);
//       card.appendChild(btn);
//       //add the card to the section
//       productSection.appendChild(card);
//   })
// }

// function addItem(ev){
//   ev.preventDefault();
//   let id = parseInt(ev.target.getAttribute('data-id'));
//   console.log('add to cart item', id);
//   CART.add(id, 1);
//   showCart();
// }

// function errorMessage(err){
//   //display the error message to the user
//   console.error(err);
// }

// -------------------------FullScreen API---------------------------

// List of prefixed versions of props
// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API#Prefixing
// onwebkitfullscreenchange-onfullscreenchange-onmozfullscreenchange-MSFullscreenChange

// let h1 = document.querySelector('h1');
// let vid = document.querySelector('#vid');
// let aud = document.querySelector('#aud');

// h1.addEventListener('click', goBig);
// vid.addEventListener('click', goBig);
// aud.addEventListener('click', goBig);

// h1.addEventListener('dblclick', goHome);
// vid.addEventListener('dblclick', goHome);
// aud.addEventListener('dblclick', goHome);

// // incase of user used esc btn instead of double click to trigger goHome function
// document.addEventListener('webkitfullscreenchange', toggleFull);

// function goBig(ev){
//     let element = ev.currentTarget;
//     // console.dir(element);
//     if(! document.webkitFullscreenElement){
//         if(element.webkitRequestFullscreen){
//             element.webkitRequestFullscreen();
//             element.classList.add('big');
//         }else{
//             console.log('element cannot be fullscreened');
//         }
//     }else{
//         console.log(document.webkitFullscreenElement, 'is the full screen element');
//     }
// }

// function goHome(ev){
//     let element = ev.target;
//     // console.log(element)
//     element.classList.remove('big');
//     if( document.webkitFullscreenEnabled){
//         document.webkitExitFullscreen();
//     }   
// }

// function toggleFull(ev){
//     let element = document.webkitFullscreenElement;
//     if(element){
//         element.classList.add('big');
//         console.log('big class added')
//     }else{
//         //remove it from the first element with it
//         element = document.querySelector('h1.big, audio.big, video.big');
//         console.log(element)
//         element?.classList.remove('big');
//         //when people use esc instead of dblclick
//     }
// }

// ----------------------------------Canvas------------------------------
/* 
The HTML <canvas> element is used to draw graphics, on the fly, via JavaScript.
The <canvas> element is only a container for graphics. You must use JavaScript to actually draw the graphics.
Canvas has several methods for drawing paths, boxes, circles, text, and adding images.

- default display css style of canvas element is inline
- it's better to add width and height in JS File no CSS File because in CSS 
  will strectch the image and will destroy aspect ratio
*/

// ---------intro to Canvas
// let canvas, ctx;
        
// document.addEventListener('DOMContentLoaded', (ev)=>{
//   canvas = document.getElementById('canvas');
//   ctx = canvas.getContext('2d'); //webgl, webgl2
//   canvas.width = 600;
//   canvas.height = 400;s
  
//   drawEllipse();
//   drawRect();
// });

// you have 2 options to draw 
// [1] define position and width and height using ctx.rect then use ctx.fill() and ctx.stroke() Methods
// [2] use directly ctx.fillRect(position and width and height) and ctx.strokeRect(position and width and height) in one step

// const drawRect = function(){
//   //define the stroke
//   ctx.strokeStyle = `red`;
//   ctx.lineWidth = 10; // width of line used as border 
  
//   //define the fill
//   ctx.fillStyle = `skyblue`;
//   ctx.beginPath();
//   // [1] option 1 using ctx.rect , ctx.fill and ctx.stroke
//   //position x,position y (positions related to canvas element), width, height  
//   ctx.rect(300, 100, 100, 50);  
//   ctx.fill(); // to fill the shape with color defined in ctx.fillStyle
//   ctx.stroke(); // to add border with color defined in ctx.strokeStyle
  
//   // [2] option 2 using ctx.fillRect and ctx.strokeRect
//   // ctx.fillRect(300, 100, 100, 50);
//   // ctx.strokeRect(300, 100, 100, 50);
  
//   //delete a rect => ctx.clearRect(x, y, width, height)
//   // ctx.clearRect(300, 100, 100, 50)
// }

// const drawEllipse = function(){
//   // it's important to write ctx.beginPath() if not the darw line will start from
//   // last circle like when you draw circle and you want to draw another circle you
//   // are not move you hand up and draw 2nd circle then will be there a line between 2 circles
//  // difference between ellipse and arc is ellipse has radiusX, radiusY so you can draw 
//  // oval shape and circle but arc only has radius so you can only draw perfect circle

//   ctx.beginPath();
//   //ctx.arc(x, y, radius, startAngle, endAngle, anticlock);
//   ctx.arc(450, 300, 50, 0, (Math.PI * 1.5), false);
//   ctx.fill();
//   ctx.stroke();

//   ctx.beginPath();
//   //ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlock);
//   ctx.ellipse(200, 200, 100, 50, 0, 0, (Math.PI*2), false);
//   ctx.fill();
//   ctx.stroke();
  
  
// }

// -------Canvas Text
// let canvas, ctx, f,txt;
// let oldTxt=""
        
// window.addEventListener('load', (ev)=>{
//   canvas = document.getElementById('canvas');
//   ctx = canvas.getContext('2d'); 
//   canvas.width = 600;
//   canvas.height = 400;
  
//   drawText();
//   document.getElementById('msg').addEventListener('input', drawText);
  
//   // instead of importing front in CSS File using import @import url()
//   // f = new FontFace('Allerta Stencil', 'url(https://fonts.gstatic.com/s/allertastencil/v8/HTx0L209KT-LmIE9N7OR6eiycOe1_Db29XP-vA.woff2)');
//   // f.load()
//   // .then(function(fnt) {
//   //     console.log(`loaded ${fnt.family}`);
//   // })
//   // .catch(err=>{
//   //     //error loading the font
//   //     console.error('Failed to load the google font');
//   // });
// });

// const drawText = function(){
//   // normal, italic, bold
//   // px pt cm in rem em
//   // any installed or imported font
//   let fontFamily = 'Allerta Stencil';
//   // we imported font in CSS File using import @import url()
//   ctx.font = `normal 20px xyz, ${fontFamily}, Helvetica, Arial, monospace`;
//   ctx.fillStyle = 'cornflowerblue';
//   ctx.strokeStyle = 'red';
//   //textAlign center, left, right, end, start (end, start depends on direction ltr or rtl)
//   ctx.textAlign = 'start';
//   //textBaseline top, hanging, middle, bottom,ideographic, alphabetic
//   ctx.textBaseline = 'alphabetic';
//   //direction ltr, rtl, inherit
//   ctx.direction = 'ltr';
  
//   txt = document.getElementById('msg').value;
//   if( txt === '' ){
//     txt = 'Please give me a message.';
//     oldTxt = txt
//   }

//   let w1 = ctx.measureText(oldTxt).width; 
//   let w2 = ctx.measureText(txt).width;
//   if(w2 > w1){
//     oldTxt = txt
//   }
//   // returns an object that contains the width of the specified text, in pixels.
//   ctx.clearRect(50, 110, w1, -30);
//   // difference between strokeText and fillText is stroke is border and fill is the fill inside charachters in words
//   ctx.strokeText(txt, 50, 100);
//   ctx.fillText(txt, 50, 100);
  
  
//   ctx.fillStyle = '#999';
//   ctx.font = 'italic 20px Arial';
//   let m = `Message is ${w1}px wide`;
//   ctx.clearRect(50, 310, 500, -30);
//   ctx.fillText(m, 50, 300);
// }

// -------Canvas Lines and Curves
/* you can use lineTo() to draw straight line but if you want to draw curved line
you have to use quadraticCurveTo or bezierCurveTo and using midpoints to make 
line curved toward this midpoint

[1] lineTo(endX , endY) accept only 2 param x & y of endpoint
[2] quadraticCurveTo() accept 4 params x & y of midpoint and x & y of endpoint
[3] bezierCurveTo() accept 6 params x & y of 2 midpoints and x & y of endpoint
*/
// let ctx;
// let midx, midy, midx1, midy1, midx2, midy2;

// document.addEventListener('DOMContentLoaded', (ev)=>{
//     let canvas = document.getElementById('canvas');
//     ctx = canvas.getContext('2d'); 
//     canvas.width = 600;
//     canvas.height = 400;

//     canvas.addEventListener('mousedown', start);
//     // canvas.addEventListener('mouseup', end);
//     //canvas.addEventListener('mouseup', endQC);
//     canvas.addEventListener('mouseup', endBC);
    
//     // shape and thickness of line
//     ctx.lineCap = 'square'; //butt, round
//     ctx.lineWidth = 10; // thickness of the line

//     // midpoints positions
//     midx = canvas.width/2;
//     midy = canvas.height/2;
    
//     midx1 = canvas.width/4;
//     midy1 = canvas.height/4;

//     midx2 = canvas.width - midx1;
//     midy2 = canvas.height - midy1;
    
//     // to draw circles of midpoint (just to show them only for demonestration)
//     ctx.lineWidth = 5;
//     ctx.beginPath();
//     ctx.arc(midx, midy, 5, 0, 2 * Math.PI, false);
//     ctx.strokeStyle = 'red';
//     ctx.stroke();
//     ctx.closePath()
    
//     ctx.beginPath();
//     ctx.arc(midx1, midy1, 5, 0, 2 * Math.PI, false);
//     ctx.strokeStyle = 'orange';
//     ctx.stroke();
//     ctx.closePath()
    
//     ctx.beginPath();
//     ctx.arc(midx2, midy2, 5, 0, 2 * Math.PI, false);
//     ctx.strokeStyle = 'skyblue';
//     ctx.stroke();
//     ctx.closePath()

//     // this how to draw triangle 
//     ctx.beginPath()
//     ctx.moveTo(0,50)
//     ctx.lineTo(50,0)
//     ctx.lineTo(100,50)
//     ctx.lineTo(0,50)
//     ctx.fill()
//     ctx.closePath()
// });

// let start = function(ev){
//     ctx.beginPath();
//     ctx.strokeStyle = '#bada55';
//     console.log('from', ev.offsetX, ev.offsetY);
//     ctx.moveTo(ev.offsetX, ev.offsetY);
// }
// let end = function(ev){
//     //using lineTo(x, y)
//     console.log('to', ev.offsetX, ev.offsetY);
//     ctx.lineTo(ev.offsetX, ev.offsetY); // draw line to this position
//     ctx.stroke();
//     ctx.closePath()
// }
// let endQC = function(ev){
//     //using quadraticCurveTo(midx, midy, endx, endy)
//     console.log('to', ev.offsetX, ev.offsetY);
//     let endx = ev.offsetX;
//     let endy = ev.offsetY;
//     ctx.quadraticCurveTo(midx, midy, endx, endy);
//     ctx.stroke();
//     ctx.closePath()
// }
// let endBC = function(ev){
//     //using bezierCurveTo(midx1, midy1, midx2, midy2, endx, endy)
//     console.log('to', ev.offsetX, ev.offsetY);
//     let endx = ev.offsetX;
//     let endy = ev.offsetY;
//     ctx.bezierCurveTo(midx1, midy1, midx2, midy2, endx, endy);
//     ctx.stroke();
//     ctx.closePath()
// }

// -------Canvas images
// let ctx;
        
// document.addEventListener('DOMContentLoaded', (ev)=>{
//     let canvas = document.getElementById('canvas');
//     ctx = canvas.getContext('2d'); 
//     canvas.width = 600;
//     canvas.height = 400;
    
//     let imgObj = new Image();
//     imgObj.src = './videos/archer-bob.jpeg';

//     imgObj.onload = function() {
//         let w = canvas.width;
//         let nw = imgObj.naturalWidth;   //1350
//         let nh = imgObj.naturalHeight;  //900
//         let aspect = nw / nh; // aspect ratio
//         let h = w / aspect;
//         canvas.height = h;
//         // 0,0 image position inside canvas |  w , h width and height of image
//         ctx.drawImage(imgObj, 0, 0, w, h); 
        
//         // you can crop part of image 350 , 180 posiotion of cropped part inside image
//         // 100, 100 width and height of cropped part 
//         // 0,0 image position inside canvas |  w , h width and height of image
//         // ctx.drawImage(imgObj, 350, 180, 100, 100 , 0 , 0 , w, h);
//     };

//     canvas.addEventListener('click', greyscale);
//     // canvas.addEventListener('click', colorChannel);
// });

// const greyscale = function(ev){
//     imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
//     let arr = imgData.data;
//     // i+4 because each color is one data and each pixel has 4 colors(red,blue,green,alpha) => 4 data
//     for(let i=0; i<arr.length; i=i+4){ 
//         let ttl = arr[i] + arr[i+1] + arr[i+2];
//         let avg = parseInt(ttl/3);
//         // if you set red , blue and green same value you will get grey shade
//         arr[i] = avg;   //red
//         arr[i+1] = avg; //green
//         arr[i+2] = avg; //blue
//     }
//     imgData.data = arr;
//     ctx.putImageData(imgData, 0, 0);
// }

// const colorChannel = function(ev){
//     imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
//     let arr = imgData.data;
//     for(let i=0; i<arr.length; i=i+4){
//         //you can change value of each color and you know largest value for color is 256
//         arr[i] = 0;     //R
//         // arr[i+1] = 0;   //G
//         // arr[i+2] = 0;   //B
//     }
//     imgData.data = arr;
//     ctx.putImageData(imgData, 0, 0);
    
//     let img = canvas.toDataURL('image/jpeg', 1.0); // 1.0 means full resolution
//     console.log(img); // base64
//     document.querySelector('img').src = img;
// }

// -------Canvas Graph
// let data = [
//   {name:'Targaryen', troops:90200, color:"blue"},
//   {name:'Tully', troops:15000, color:"green"},
//   {name:'Stark', troops:50500, color:"red"},
//   {name:'Lannister', troops:120800,color:"cornflowerblue"},
//   {name:'Mormont', troops:16000,color:"pink"}
// ];

// // you can use random hex color or use colors in data object
// const randomHexColorCode = () => {
//   return "#" + Math.random().toString(16).slice(2, 8)
// };

// document.addEventListener('DOMContentLoaded', ()=>{
//   let canvas = document.getElementById('c');
//   let ctx = canvas.getContext('2d');
//   canvas.width = 800;
//   canvas.height = 600;
//   let total = data.reduce( (ttl, house) => {
//       return ttl + house.troops
//   }, 0);
//   let startAngle = 0; 
//   let radius = 100;
//   // centering the graph inside canvas element
//   let cx = canvas.width/2;
//   let cy = canvas.height/2;
  
//   data.forEach( house => {
//       //set the styles before beginPath
//       // ctx.fillStyle = randomHexColorCode(); // using random hex color
//       ctx.fillStyle = house.color
//       ctx.lineWidth = 1;
//       ctx.strokeStyle = '#333';
//       ctx.beginPath();

//       // draw the pie wedges
//       let endAngle = ((house.troops / total) * Math.PI * 2) + startAngle;
//       ctx.moveTo(cx, cy);
//       ctx.arc(cx, cy, radius, startAngle, endAngle, false);
//       ctx.lineTo(cx, cy);
//       ctx.fill();
//       ctx.stroke();
//       ctx.closePath();
      
//       // add the labels
//       ctx.beginPath();
//       ctx.font = '20px Helvetica, Calibri';
//       ctx.textAlign = 'center';
//       ctx.fillStyle = 'rebeccapurple';
//       // midpoint between the two angles
//       // 1.5 * radius is the length of the Hypotenuse
//       let theta = (startAngle + endAngle) / 2;
//       let deltaY = Math.sin(theta) * 1.5 * radius;
//       let deltaX = Math.cos(theta) * 1.5 * radius;
//       /***
//       SOH  - sin(angle) = opposite / hypotenuse
//                         = opposite / 1px
//       CAH  - cos(angle) = adjacent / hypotenuse
//                         = adjacent / 1px
//       TOA
      
//       ***/
//       ctx.fillText(house.name, deltaX+cx, deltaY+cy);
//       ctx.closePath();

//       // change startAngle every loop to make sure next element start from the end of last element
//       startAngle = endAngle;
//   })
// });

// --------canvas tansform
// let ctx;

// document.addEventListener('DOMContentLoaded', ()=>{
//     let canvas = document.getElementById('canvas');
//     ctx = canvas.getContext('2d');
//     canvas.width = 600;
//     canvas.height = 800;
//     ctx.fillStyle = 'cornflowerblue';
//     ctx.strokeStyle = '#ccc';
//     ctx.lineWidth = 2;
//     ctx.textAlign = 'start';
//     ctx.font = 'normal 30px Arial';
//     drawGrid(100);

//     let x = 100;
//     let y = 100;
//     ctx.save();  //creates a save point
//     ctx.beginPath();
//     // now starting point(0,0) is 200 x direction and 200 y direction
//     ctx.translate(200, 200); 
//     ctx.fillText('translate', 10, 30);
//     ctx.fill();
//     ctx.closePath();
//     ctx.restore(); //go back to the last save point

//     // without ctx.save() and ctx.restore();
//     // ctx.translate(200, 200); still make starting point(0,0) is 200 x direction and 200 y direction
//     // with ctx.save() and ctx.restore(); 
//     // we are deactivating ctx.translate(200, 200); and starting point return to (0,0)
//     ctx.save();
//     ctx.beginPath();
//     ctx.arc(0, 0, 10, 0, Math.PI*2); // to draw circle at starting point(0,0)
//     ctx.rotate(Math.PI/4);        //3.14 radians 180 deg
//     ctx.fillText('rotate', 300, 0);
//     ctx.fill();
//     ctx.closePath();
//     ctx.restore();

//     ctx.beginPath();
//     ctx.translate(100, 500);
//     ctx.scale(1, -1); // x and y directions
//     ctx.fillText('scale', x, y);
//     ctx.fill();
//     ctx.closePath();

    
// });

// function drawGrid(gap){
//     ctx.beginPath();
//     for(x=gap; x<canvas.width; x=x+gap){
//         ctx.moveTo(x, 0);
//         ctx.lineTo(x, canvas.height);
//     }
//     for(let y=gap; y<canvas.height; y=y+gap){
//         ctx.moveTo(0, y);
//         ctx.lineTo(canvas.height, y);
//     }
//     ctx.stroke();
//     ctx.closePath();
// }

// ---------canvas video frames grab and image upload
// const grabScreen = () =>{
//   let player = document.getElementById('player')
//   let canvas = document.getElementById('canvas');
//   let ctx = canvas.getContext('2d');
//   canvas.width = player.videoWidth;
//   canvas.height = player.videoHeight;
//   //grab a frame from the video
//   ctx.drawImage(player, 0, 0);
//   //convert to grayscale image
//   //ONLY WORKS IF image is not tainted by CORS
//   let imgdata = ctx.getImageData(0,0, canvas.width, canvas.height);
//   let len = imgdata.data.length;
//   for(let i=0; i<len; i=i+4){
//       let red = imgdata.data[i];
//       let green = imgdata.data[i+1];
//       let blue = imgdata.data[i+2];
//       //let lum = .2126 * red + .7152 * green + .0722 * blue;
//       let lum = (red + green + blue)/3;
//       imgdata.data[i] = lum;
//       imgdata.data[i+1] = lum;
//       imgdata.data[i+2] = lum;
//   }
//   //update what is displayed on the canvas.
//   ctx.putImageData(imgdata, 0, 0);
//   //export as image file to be uploaded or saved
  
//   let blob = canvas.toBlob((blob) => {
//       //this code runs AFTER the Blob is extracted
//       let fd = new FormData();
//       fd.append('field-name', blob, 'image-filename.png');    
//       let req = new Request('https://jsonplaceholder.typicode.com/posts', {
//           method: 'POST',
//           body: fd
//       })
//       fetch(req)
//       .then(response=>response.json())
//       .then(data=>{
//           console.log('response from server after uploading the image');
//       })
//       .catch(err=>{
//           console.log(err.message);
//       });
      
//       //load the blob into the image tag
//       let img = document.createElement('img');
//       let url = URL.createObjectURL(blob);
//       img.addEventListener('load', (ev)=>{
//           console.log('image from createObjectURL loaded');
//           //player.pause();  //stop the video playing if desired
//           //let vid = document.createElement('video');
//           //vid.poster = url;
//           //document.body.appendChild(vid);
          
//           //clear memory used to create object url
//           //this will make it impossible to download the image with a right click
//           //window.URL.revokeObjectURL(url);
//       })
//       img.src = url; //use the canvas binary png blob
//       document.getElementById('image').appendChild(img);
  
//   }, 'image/png'); //create binary png from canvas contents
  
// }

// MEDIA EVENTS
// https://developer.mozilla.org/en-US/docs/Web/Events#Media_events

// document.addEventListener('DOMContentLoaded', ()=>{
//   let player = document.getElementById('player');
//   // // canplay event means this video can be played
//   player.addEventListener('canplay', (ev)=>{
//     console.log('canplay', ev.target.videoWidth, ev.target.videoHeight);
//     console.log(ev.target.clientWidth, ev.target.clientHeight);
//     console.log(ev.target.currentSrc, ev.target.duration, ev.target.currentTime);
//     player.addEventListener('click', (ev)=>{
//         //click the video to grab a screenshot and display in the canvas
//         grabScreen();
//     })
//   });
  
//   player.addEventListener('canplaythrough', (ev)=>{
//       // canplaythrough event means this video buffered enough to start playing
//       //this is our own autoplay
//       console.log('Enough loaded to play through whole video');
//       player.play();
//   });
  
//   player.addEventListener('load', (ev)=>{
//       //video has loaded entirely
//       console.log('video loaded');
//   });
  
//   player.addEventListener('error', (err)=>{
//       console.log('Failed to load video', err.message);
//   })
// })

// ------canvas images
// let canvas, ctx, img1, img2, img3;
// let images = [];

// document.addEventListener("DOMContentLoaded", () => {
//   canvas = document.getElementById("canvas");
//   ctx = canvas.getContext("2d");
//   canvas.width = 1200;
//   canvas.height = 600;
//   img1 = document.createElement("img");
//   img2 = document.createElement("img");
//   img3 = document.createElement("img");
//   img1.addEventListener("load", trackLoads);
//   img2.addEventListener("load", trackLoads);
//   img3.addEventListener("load", trackLoads);
//   img1.src = "./videos/archer-bob.jpeg";
//   img2.src = "./videos/archer-bob.jpeg";
//   img3.src = "./videos/archer-bob.jpeg";
// });

// function trackLoads(ev) {
//   let imgObj = {
//     sw: ev.target.naturalWidth,
//     sh: ev.target.naturalHeight * (3 / 4),
//     img: ev.target
//   };
//   images.push(imgObj);

//   console.log(imgObj);
//   if (images.length === 3) {
//     addThumbnails();
//   }
// }

// function addThumbnails() {
//   //image has been loaded to the document.
//   //add 12 copies of the images to the canvas 4 columns x 3 rows
//   //each thumbnail will be 300px wide by 200px high
//   //calculate the part of the image to use as the thumbnail
//   let dx = 0;
//   let dy = 0;
//   let imgCount = 0;
//   for (let r = 0; r < 3; r++) {
//     for (let c = 0; c < 4; c++) {
//       dx = c * 300; // 0, 300, 600, 900
//       dy = r * 200; // 0, 200, 400
//       let imgObj = images[Math.floor(imgCount % 3)]; //0, 1, 2
//       imgCount++;
//       // image 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3
//       ctx.drawImage(
//         imgObj.img,
//         0,
//         0,
//         imgObj.sw,
//         imgObj.sh,
//         dx,
//         dy,
//         300,
//         200
//       );
//       // ctx.drawImage( source, sx, sy, sw, sh, dx, dy, dw, dh)
//     }
//   }
// }

// ----------------Extracting Colour Values from Pixel Coordinates-------------
// // this only a demo to understand how calculation of next tutorial
// let grid = document.querySelector('.grid');
// let cols = grid.getAttribute('data-cols');
// let rows = grid.getAttribute('data-rows');
// //display the grid info in the paragraph below the grid
// document.getElementById('cols').textContent = cols;
// document.getElementById('rows').textContent = rows;
// //size the grid
// grid.style.width = `${cols * 100 + 2}px`;
// grid.style.height = `${rows * 100 + 2}px`;
// //build the grid based on data-rows and data-cols attributes
// for (let r = 0; r < rows; r++) {
//   for (let c = 0; c < cols; c++) {
//     let div = document.createElement('div');
//     div.className = 'pixel';
//     div.setAttribute('data-coord', `${c}, ${r}`);
//     grid.append(div);
//   }
// }
// //listen for mouse movement over the grid
// document.querySelector('.grid').addEventListener('mousemove', getPixel);

// function getPixel(ev) {
//   let pixel = ev.target;
//   //remove the old highlight class
//   document.querySelector('.highlight')?.classList.remove('highlight');
//   //add the highlist class to the current pixel div
//   pixel.classList.add('highlight');
//   let p1 = document.getElementById('coords');
//   let p2 = document.getElementById('pixelPos');
//   let p3 = document.getElementById('arrayPos');
//   let p4 = document.getElementById('arraySize');

//   let coords = pixel.getAttribute('data-coord');
//   p1.textContent = `Selected pixel (${coords})`;

//   let pixelPos = coords.split(', ');
//   let col = Number(pixelPos[0]);
//   let row = Number(pixelPos[1]);
//   let pixelIndex = cols * row + col;
//   p2.innerHTML = `Pixel INDEX<br/>Total columns * row + column<br/>${cols} * ${row} + ${col} = ${pixelIndex}`;

//   let arrayPos = pixelIndex * 4;
//   p3.innerHTML = `Pixel [r,g,b,a] values in array positions<br/>[ ${arrayPos}, ${
//     arrayPos + 1
//   }, ${arrayPos + 2}, ${arrayPos + 3} ]`;

//   p4.innerHTML = `In the grid there are ${
//     rows * cols
//   } pixels.<br/>In the Array there are ${rows * cols * 4} elements.`;
// }

// ----------------Colour Extraction Tool using Canvas--------------
// const APP = {
//   canvas: null,
//   ctx: null,
//   data: [],
//   img: null,
//   init() {
//     APP.canvas = document.querySelector('main canvas');
//     APP.ctx = APP.canvas.getContext('2d');
//     APP.canvas.width = 900;
//     APP.canvas.style.width = 900;
//     APP.canvas.height = 600;
//     APP.canvas.style.height = 600;
//     // we will not append img element to the page it will be saved im the memory then use it on drawImage method to draw it inside canvas element
//     APP.img = document.createElement('img');
//     APP.img.src = APP.canvas.getAttribute('data-src');
//     //once the image is loaded, add it to the canvas
//     APP.img.onload = (ev) => {
//       APP.ctx.drawImage(APP.img, 0, 0);
//       //call the context.getImageData method to get the array of [r,g,b,a] values
//       let imgDataObj = APP.ctx.getImageData(
//         0,
//         0,
//         APP.canvas.width,
//         APP.canvas.height
//       );
//       APP.data = imgDataObj.data; //data prop is an array
//       // console.log(APP.data.length, 900 * 600 * 4); //  has 2,160,000 elements
//       APP.canvas.addEventListener('mousemove', APP.getPixel);
//       APP.canvas.addEventListener('click', APP.addBox);
//     };
//   },
//   getPixel(ev) {
//     //as the mouse moves around the image
//     // let canvas = ev.target;
//     let cols = APP.canvas.width;
//     // let rows = canvas.height;
//     let { offsetX, offsetY } = ev;
//     //call the method to get the r,g,b,a values for current pixel
//     let c = APP.getPixelColor(cols, offsetY, offsetX);
//     //build a colour string for css
//     let clr = `rgb(${c.red}, ${c.green}, ${c.blue})`; //${c.alpha / 255}
//     document.getElementById('pixelColor').style.backgroundColor = clr;
//     //save the string to use elsewhere
//     APP.pixel = clr;
//     //now get the average of the surrounding pixel colours
//     APP.getAverage(ev);
//   },
//   getAverage(ev) {
//     //create a 41px by 41px average colour square
//     //replace everything in the canvas with the original image
//     // let canvas = ev.target;
//     let cols = APP.canvas.width;
//     let rows = APP.canvas.height;
//     //remove the current contents of the canvas to draw the image and box again
//     APP.ctx.clearRect(0, 0, cols, rows);
//     //add the image from memory
//     APP.ctx.drawImage(APP.img, 0, 0);
//     let { offsetX, offsetY } = ev;
//     const inset = 20;
//     //inset by 20px as our workable range(to stop the box from exiting the canvas element)
//     offsetX = Math.min(offsetX, cols - inset);
//     offsetX = Math.max(inset, offsetX);
//     offsetY = Math.min(offsetY, rows - inset);
//     offsetY = Math.max(offsetY, inset);
//     //create a 41 x 41 pixel square for the average
//     let reds = 0; //total for all the red values in the 41x41 square
//     let greens = 0;
//     let blues = 0;
//     //for anything in the range (x-20, y-20) to (x+20, y+20)
//     for (let x = -1 * inset; x <= inset; x++) {
//       for (let y = -1 * inset; y <= inset; y++) {
//         let c = APP.getPixelColor(cols, offsetY + y, offsetX + x);
//         reds += c.red;
//         greens += c.green;
//         blues += c.blue;
//       }
//     }
//     let nums = 41 * 41; //total number of pixels in the box
//     let red = Math.round(reds / nums);
//     let green = Math.round(greens / nums);
//     let blue = Math.round(blues / nums);
//     //create a colour string for the average colour
//     let clr = `rgb(${red}, ${green}, ${blue})`;
//     //now draw an overlaying square of that colour
//     //make the square twice as big as the sample area
//     APP.ctx.fillStyle = clr;
//     APP.ctx.strokeStyle = '#FFFFFF';
//     APP.ctx.strokeWidth = 2;
//     //save the average colour for later
//     APP.average = clr;
//     APP.ctx.strokeRect(offsetX - inset, offsetY - inset, 41, 41);
//     APP.ctx.fillRect(offsetX - inset, offsetY - inset, 41, 41);
//   },
//   getPixelColor(cols, x, y) {
//     //see grid.html as reference for this algorithm
//     let pixel = cols * x + y;
//     let arrayPos = pixel * 4;
//     return {
//       red: APP.data[arrayPos],
//       green: APP.data[arrayPos + 1],
//       blue: APP.data[arrayPos + 2],
//       alpha: APP.data[arrayPos + 3],
//     };
//   },
//   addBox(ev) {
//     //user clicked. Let's add boxes below with the pixel and the average
//     let colours = document.querySelector('.colours');
//     let pixel = document.createElement('span');
//     pixel.className = 'box';
//     pixel.setAttribute('data-label', 'Exact pixel');
//     pixel.setAttribute('data-color', APP.pixel);

//     let average = document.createElement('span');
//     average.className = 'box';
//     average.setAttribute('data-label', 'Average');
//     average.setAttribute('data-color', APP.average);

//     pixel.style.backgroundColor = APP.pixel;
//     average.style.backgroundColor = APP.average;
//     colours.append(pixel, average);
//   },
// };

// document.addEventListener('DOMContentLoaded', APP.init);

// ------------------Debugger keyword------------
// https://youtu.be/fs8PwQAx_Tw

// let x = 1;
// const doClick = (ev)=>{
//     x = 4;
//     debugger;
//     console.log('the debugger is enabled');
//     x = 7;
// };

// document.addEventListener('DOMContentLoaded', ()=>{
//     document.body.addEventListener('click', doClick);
// });


// ------------------forms in js--------------------
/*
- if there is a button inside a form once you click it will submit the form even if the button 
type is not submit
- you can add value attribute to input element in HTML File and this will be default value 
of this input field and you can write anything inside input field to change it
- to clear form you can use reset() method
*/
// let movies = [];
// // example {id:1592304983049, title: 'Deadpool', year: 2015}
// const addMovie = (ev)=>{
//     ev.preventDefault();  //to stop the form submitting
//     let movie = {
//         id: Date.now(),
//         title: document.getElementById('title').value,
//         year: document.getElementById('yr').value
//     }
//     movies.push(movie);
//     document.forms[0].reset(); // to clear the form for the next entries
//     //document.querySelector('form').reset();

//     //for display purposes only
//     console.warn('added' , {movies} );
//     let pre = document.querySelector('#msg pre');
//     pre.textContent = '\n' + JSON.stringify(movies, '\t', 2);

//     //saving to localStorage
//     localStorage.setItem('MyMovieList', JSON.stringify(movies) );
// }
// document.addEventListener('DOMContentLoaded', ()=>{
//     document.getElementById('btn').addEventListener('click', addMovie);
// });

// ----------------------MultiLingual----------------
//language data... could come from an external js/json file
// let langdata = {
//   "languages": {
//       "en": {
//           "strings": {
//               "btn-yes": "yes",
//               "btn-no": "no"
//           }
//       },
//       "fr": {
//           "strings": {
//               "btn-yes": "oui",
//               "btn-no": "non"
//           }
//       },
//       "de": {
//           "strings": {
//               "btn-yes": "ja",
//               "btn-no": "nein"
//           }
//       }
//   }
// }
// //apply the language values to the content
// document.addEventListener('DOMContentLoaded', () => {
//   //skip the lang value in the HTML tag for this example
//   let zones = document.querySelectorAll('html [lang]');
//   applyStrings(zones);

//   let lang = findLocaleMatch();
//   let container = document.querySelector(`html [lang*=${lang}]`); // *= contains (CSS Attibute selector)
//   container.className = 'lang-match';
// });

// function applyStrings(containers) {
//   containers.forEach(container => {
//       //find all the elements that have data-key
//       let locale = container.getAttribute('lang');
//       //console.log('looking inside of ', locale);
//       container.querySelectorAll(`[data-key]`).forEach(element => {
//           let key = element.getAttribute('data-key');
//           //console.log(element);
//           //console.log(key);
//           let lang = locale.substr(0, 2); //first 2 characters
//           if (key) {
//               element.textContent = langdata.languages[lang].strings[key];
//           }
//       });
//   })
// }

// function findLocaleMatch() {
//   let keys = Object.keys(langdata.languages); //from our data
//   let locales = Intl.getCanonicalLocales(keys); //from our data validated (to check if it is valid language like en .. xy will thorw error)
//   let lang = navigator.language; //from browser 
//   let locale = Intl.getCanonicalLocales(lang); //from browser validated
//   console.log('browser language', lang);
//   console.log('locales from data file', locale);

//   //find the match for locale inside locales
//   let langMatch = document.documentElement.getAttribute('lang'); //default
//   locales = locales.filter(l => locale == l);
//   langMatch = (locales.length > 0) ? locales[0] : langMatch;
//   return langMatch;
// }

// --------------------Google Map API  (needs KEY)-----------------------
// let map;
// document.addEventListener("DOMContentLoaded", () => {
//     let s = document.createElement("script");
//     document.head.appendChild(s);
//     s.addEventListener("load", () => {
//         //script has loaded
//         console.log("script has loaded");
//         // accept 2 arguments (the element that you will put the map inside it , options object)
//         map = new google.maps.Map(document.getElementById("map"), {
//             center: {
//                 lat: 45.3496711,
//                 lng: -75.7569551
//             },
//             zoom: 16, // zoom from 1 to 70
//             mapTypeId: google.maps.MapTypeId.ROADMAP // type of map Road or satellite 
//         });
//     });
//     // he created a js file with MAPKEY and added to HTML File <script src="./keys.js"></script> 
//     s.src = `https://maps.googleapis.com/maps/api/js?key=${MAPKEY}`; 
// });

// ---------------------Google MAP controls (needs KEY)---------------
// let map;
// document.addEventListener("DOMContentLoaded", () => {
//   let s = document.createElement("script");
//   document.head.appendChild(s);
//   s.addEventListener("load", () => {
//       //script has loaded
//       console.log("script has loaded. About to load the map");
//       map = new google.maps.Map(document.getElementById("map"), {
//           center: {
//               lat: 45.4496711,
//               lng: -75.6569551
//           },
//           zoom: 15,
//           mapTypeId: google.maps.MapTypeId.ROADMAP,
//           restriction: { // the area where user is allowed to move inside
//               latLngBounds: {
//                   north: 50.00,
//                   south: 40.00,
//                   west: -100.00,
//                   east: -60.00,
//               }
//           },
//           minZoom: 10,
//           maxZoom: 17,
//           disableDoubleClickZoom: false,
//           clickableIcons: false,
//           disableDefaultUI: true, //set of default controls when map loads => we can disable it and add what we want of controls
//           zoomControl: true,
//           zoomControlOptions: {
//               position: google.maps.ControlPosition.RIGHT_CENTER
//           },
//           mapTypeControl: true, // to choose map type (roadmap, hybrid, satelite)
//           mapTypeControlOptions: {
//               style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
//               mapTypeIds: ["roadmap", "terrain", "satellite"],
//               position: google.maps.ControlPosition.LEFT_TOP
//           },
//           fullscreenControl: true,
//           fullscreenControlOptions: {
//               position: google.maps.ControlPosition.RIGHT_TOP
//           },
//           scaleControl: false,
//           streetViewControl: true,
//           streetViewControlOptions: {
//               position: google.maps.ControlPosition.RIGHT_BOTTOM
//           },
//           rotateControl: true
//       });
//   });
//   s.src = `https://maps.googleapis.com/maps/api/js?key=${MAPKEY}`;
// });


// ------------------Google Maps Events and markers (needs KEY)--------------------
// let app = {
//   map: null,
//   currentMarker: null,
//   defaultPos: {
//     coords: {
//       latitude: 45.555,
//       longitude: -75.555
//     }
//   }, //default location to use if geolocation fails
//   init: function() {
//     // deviceready on mobile -- on web use  DOMContentLoaded
//     document.addEventListener("deviceready", app.ready);
//   },
//   ready: function() {
//     //load the google map script
//     let s = document.createElement("script");
//     document.head.appendChild(s);
//     s.addEventListener("load", app.mapScriptReady);
//     s.src = `https://maps.googleapis.com/maps/api/js?key=${MAPKEY}`;
//   },
//   mapScriptReady: function() {
//     //script has loaded. Now get the location
//     if (navigator.geolocation) {
//       let options = {
//         enableHighAccuracy: true,
//         timeout: 20000,
//         maximumAge: 1000 * 60 * 60
//       };
//       navigator.geolocation.getCurrentPosition(
//         app.gotPosition,
//         app.failPosition,
//         options
//       );
//     } else {
//       //not supported
//       //pass default location to gotPosition
//       app.gotPosition(app.defaultPos);
//     }
//   },
//   gotPosition: function(position) {
//     console.log("gotPosition", position.coords);
//     //build the map - we have deviceready, google script, and geolocation coords
//     app.map = new google.maps.Map(document.getElementById("map"), {
//       zoom: 12,
//       center: {
//         lat: position.coords.latitude,
//         lng: position.coords.longitude
//       },
//       disableDoubleClickZoom: true
//     });
//     //add map event listeners
//     app.addMapListeners();
//   },
//   addMapListeners: function() {
//     console.log("addMapListeners");
//     //add double click listener to the map object
//     app.map.addListener("dblclick", app.addMarker);
//   },
//   addMarker: function(ev) {
//     console.log("addMarker", ev);
//     let marker = new google.maps.Marker({
//       map: app.map,
//       draggable: false,
//       position: {
//         lat: ev.latLng.lat(),
//         lng: ev.latLng.lng()
//       }
//     });
//     //add click listener to Marker
//     marker.addListener("click", app.markerClick);
//     //add double click listener to Marker
//     marker.addListener("dblclick", app.markerDblClick);
//   },
//   markerClick: function(ev) {
//     console.log("Click", ev);
//     console.log(this);
//     let marker = this; // to use the marker locally
//     app.currentMarker = marker; //to use the marker globally
//     app.map.panTo(marker.getPosition());
//   },
//   markerDblClick: function(ev) {
//     console.log("Double Click", ev);
//     console.log(this);
//     let marker = this; //to use the marker locally
//     //app.currentMarker = marker; //to use the marker globally
//     //remove the marker from the map
//     marker.setMap(null);
//     app.currentMarker = null;
//   },
//   failPosition: function(err) {
//     console.log("failPosition", err);
//     //failed to get the user's location for whatever reason
//     app.gotPosition(app.defaultPos);
//   }
// };

// app.init();

/**
 * google.maps.Marker object can listen to:
 * click
 * dblclick
 * mouseup
 * mousedown
 * mousemove
 * mousecancel... and more
 * See: https: //developers.google.com/maps/documentation/javascript/reference/#Marker
 */


// ------------------------formData-----------------------
/*
- formData is iterable
- formData accept HTMLFormElement as parameter
- when you append data will be added inside formData as array so you can say formData is an object of arrays
- you can append (name , value ) or you can append blob and then send it to the server

The special thing about FormData is that network methods, such as fetch, 
can accept a FormData object as a body. It’s encoded and sent out with 
Content-Type: multipart/form-data.
From the server point of view, that looks like a usual form submission.
*/

// document.addEventListener('DOMContentLoaded', () => {
//   let fd = new FormData();
//   fd.append('name', 'Bubba');
//   fd.append('id', 1234);
//   fd.append('created_dt', Date.now());
//   console.log(Array.from(fd));

//   for (let obj of fd) {
//       console.log(obj)
//   }
//   for (let [key,value] of fd) {
//       console.log(key,value)
//   }
//   document.querySelector('#output pre').textContent = JSON.stringify(Array.from(fd), '\t', 2);
//   // let url = 'http://www.example.com/';
//   // let req = new Request({
//   //     url: url,
//   //     body: fd
//   // })
//   // fetch(req)
//   // .then(response => response.json() )
//   // .then( data => {})
//   // .catch( err => {})

// });

// ---------------Use the FormData API to access form values in JavaScript------------- 
// function handleSubmit(event) {
//   event.preventDefault();

//   const data = new FormData(event.target);

//   const value = data.get('email');

//   console.log({ value });
// }

// const form = document.querySelector('form');
// form.addEventListener('submit', handleSubmit);

// -------------Get multi-select values like checkboxes as JSON with the FormData API----------
// function handleSubmit(event) {
//   event.preventDefault();
//   const data = new FormData(event.target);

//   // The entries() method returns a new Array iterator object 
//   let dataIte = data.entries()
//   for(let [key,value] of dataIte){
//     console.log(key,value)
//   }
//   // The Object.fromEntries(iterable) method transforms a list of key-value pairs into an object.
//   const value = Object.fromEntries(data);

//   console.log(value.topics) // will return last value only if you choose multiple choices
//   value.topics = data.getAll("topics");
//   console.log(value.topics) // will return array of all choices
//   console.log({ value });
// }

// const form = document.querySelector("form");
// form.addEventListener("submit", handleSubmit);

// ------------------clientX - clientY - pageX - pageY - offsetX - offsetY------------
/*
- clientX ,  clientY => distance from visible area from page to the click
- pageX , pageY => distnace from page to the click (not only the visible) so without scrolling client and page will be the same
- screenX, screenY => distnace from screen of computer(not the browser) to the click
- offsetX, offsetY => distnace from element edge to the click 
 */
// document.addEventListener('DOMContentLoaded', () => {
//   document.addEventListener('click', f);
// });

// function f(ev) {
//   console.log(ev.target.tagName, 'clicked');
//   console.log('clientX', ev.clientX);
//   console.log('pageX', ev.pageX);
//   console.log('screenX', ev.screenX);
//   console.log('offsetX', ev.offsetX);
//   console.log('clientY', ev.clientY);
//   console.log('pageY', ev.pageY);
//   console.log('screenY', ev.screenY);
//   console.log('offsetY', ev.offsetY);

// }


// -------------------Parent Element in DOM-----------
// //walking up the DOM looking for a specific element
// document.addEventListener('DOMContentLoaded', () => {
//   let spans = document.querySelectorAll('span');
//   spans.forEach(span => {
//       span.addEventListener('click', findElement);
//   });
// });


// function findElement(ev) {
//   ev.preventDefault(); //to stop the link navigating
//   let toFind = 'div'; // name of the tag we want to find.
//   //this could also be a reference to another element
//   //could be an id
//   //could be a className

//   let currentElement = ev.target;
//   while (toFind !== currentElement.tagName.toLowerCase() &&
//       currentElement.tagName.toLowerCase() !== 'html') {
//       console.log('NOT', currentElement.tagName);
//       currentElement = currentElement.parentElement;
//   }
//   console.log('STOPPED AT ', currentElement)
// }


// ---------------insertBefore and insertAdjacentElement------------   
/*
- difference between prepend and insertBefore:
prepend will always insert new element node at the beginnig of target element(always before 1st child)
insertBefore will insert new element node before specific child which you decide at 2nd param(use can insert it before 2nd child)

- difference between insertBefore and insertAdjacentElement :
insertAdjacentElement you have 4 options => 'beforebegin', 'afterbegin', 'beforeend', 'afterend'
so you cannot insert the new element before specific child
 */

// https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentElement
// parentNode.insertBefore(newNode, referenceNode);

// https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore
// targetElement.insertAdjacentElement(position, NewElement);
// let count = 0;
// document.addEventListener('DOMContentLoaded', () => {
//   document.body.addEventListener('click', (ev) => {
//       let main = document.querySelector('main');
//       let originalPara = main.querySelector('.original');
//       let secondChild = main.querySelector(".second")
//       let p = document.createElement('p');
//       count++;
//       p.textContent = `This is paragraph ${count} created by insertBefore.`;
//       // main.insertBefore(p, originalPara);
//       main.insertBefore(p, secondChild); // with insertBefore you can choose to insert it before 2nd child
//       // main.prepend(p) // with prepend you cannot prepend it before 2nd child always before 1st child
//       // main.appendChild(p);// after originalPara as the last element in main
//   });

//   document.body.addEventListener('dblclick', (ev) => {
//       let main = document.querySelector('main');
//       let p = document.createElement('p');
//       p.textContent = 'This is paragraph created by insertAdjacentElement.';
//       main.insertAdjacentElement('afterend', p);
//       // 'beforebegin', 'afterbegin', 'beforeend', 'afterend'
//   });

// });

//------------------------------------Cookies---------------------------
/*  Cookies vs LocalStorage 
- Cookies are primarily for reading server-side 
- local storage can only be read by the client-side
- I recommend using Cookie for sensitive data and Local Storage for non-sensitive data.

----Cookies : 
* is accessible by JavaScript so Cookie's data can be stolen by XSS attack
(Cross Site Scripting attack) but setting HttpOnly flag to Cookie prevents the access 
by JavaScript so Cookie's data is protected from XSS attack.

* is vulnerable to CSRF(Cross Site Request Forgery) but setting SameSite flag with Lax 
to Cookie mitigates CSRF and setting SameSite flag with Strict to Cookie prevents CSRF.

* Storage 4kb

* cookies are sent with every HTTP

* Cookies Has expiration date.

----LocalStorage: 
* is accessible by JavaScript so Local Storage's data can be stolen by XSS attack
(Cross Site Scripting attack) then, as logn as I researched, there are no easy preventions 
for Local Storage from XSS attack.

* is not vulnerable to CSRF(Cross Site Request Forgery).

* Storage 5mb

* Local storage Is not sent with every HTTP request If the server needs stored 
client information you purposely have to send it.

* LocalStorage does not Has expiration date.

*/
// document.addEventListener('DOMContentLoaded', () => {

//   document.body.addEventListener('click', (ev) => {
//       //display the current cookie and display it in the output div
//       if (document.cookie) {
//           document.getElementById('output').textContent = document.cookie;
//           //this will output all the key=value pairs
//       } else {
//           document.getElementById('output').textContent = 'No cookies currently';
//       }
//       console.log(document.cookie.split(';'));
//   });

//   //you can only one cookie at a time
//   document.getElementById('btnAdd').addEventListener('click', (ev) => {
//       //set a cookie 
//       let key = 'score';
//        // we use encodeURIComponent incase of using special charachters inside value
//       let value = encodeURIComponent('8745683465');
//       let thirty = 60 * 60 * 24 * 30;
//       document.cookie = `${key}=${value};path=/;max-age=${thirty};`;
//       // theme=gold;   score=102923873;  trackingid=AB3453453DF;
//       /**
//       ;path= absolute path. current path by default.
//       ;domain=sub.example.com current domain by default.
//       => max-age and expires used to set expiry date to allow the browser to delete the cookie
//       ;max-age= seconds  60*60*24*30  30 days 
//       ;expires= UTC date. end of current session by default  
//       ;secure=true 
//       ;same-site=Strict | Lax => strict means only request accepted from same domain
//       **/
//   });

//   // to delete cookie you have to set same path of cookie and set expiry to old date
//   document.getElementById('btnDel').addEventListener('click', (ev) => {
//       //delete a cookie
//       let key = 'theme';
//       document.cookie = `${key}=;path=/;expires=Thu, 01 Jan 1970T00:00:00Z;`;
//   });

//   document.getElementById('btnFind').addEventListener('click', (ev) => {
//       //find if a cookie exist
//       let key = 'score';
//       let val = '';
//       if (document.cookie.split(';').filter(item => item.trim().startsWith(`${key}=`))
//           .length) {
//           //cookie that starts with key= exists
//           document.getElementById('output').textContent = `${key} key is found`;
//       } else {
//           document.getElementById('output').textContent = `${key} key is NOT found`;
//       }
//       ev.stopPropagation(); // to prevent event bubbling and not to trigger event that check document.cookie
//   });
// });

// --------------------------How to Fetch HTML--------------------


// document.addEventListener("DOMContentLoaded", () => {
//   document.body.addEventListener("click", getData);
// });

// function getData(ev) {
//   ev.preventDefault();
//   // const url = "http://127.0.0.1:1234/api/requestHTML.js";
//   const url = "./html/snippet.html";
//   let req = new Request(url, {
//     method: "GET"
//   });

//   fetch(req)
//     .then(response => response.text())
//     .then(text => {
//       console.log(text)
//       let main = document.querySelector("main");
//       //text will be the text contents of the file.
//       //Version 1
//       // main.innerHTML = text; // bad performance

//       //Version 2 (using method parseFromString from DOMParser object to change text(string) to document(contain elements))
//       //new document created
//       // let doc = new DOMParser().parseFromString(text, "text/html");
//       // console.dir(doc);
//       // let div = doc.body.firstElementChild; //the div from our file
//       // main.appendChild(div);

//       //Version 3(create document fargment from text not whole document like version 2 that's why we do not need let div = doc.body.firstElementChild)
//       let frag = document.createRange().createContextualFragment(text);
//       // console.log(frag); //creates a document fragment
//       main.appendChild(frag);
//     })
//     .catch(err => {
//       console.warn("Fetch Failed:", err.message);
//     });
// }

// ------------------Infinite Scroll | Lazy Load using IntersectionObserver API-------
// const URL ="https://gist.githubusercontent.com/prof3ssorSt3v3/1944e7ba7ffb62fe771c51764f7977a4/raw/c58a342ab149fbbb9bb19c94e278d64702833270/infinite.json";
// document.addEventListener("DOMContentLoaded", () => {
// //set up the IntersectionObserver to load more images if the footer is visible.
// //URL - https://gist.githubusercontent.com/prof3ssorSt3v3/1944e7ba7ffb62fe771c51764f7977a4/raw/c58a342ab149fbbb9bb19c94e278d64702833270/infinite.json
// let options = {
//   root: null,
//   rootMargins: "0px",
//   threshold: 0.5
// };
// const observer = new IntersectionObserver(handleIntersect, options);
// observer.observe(document.querySelector("footer"));
// //an initial load of some data
// getData();
// });
// function handleIntersect(entries) {
// if (entries[0].isIntersecting) {
//   console.warn("something is intersecting with the viewport");
//   getData();
// }
// }
// function getData() {
// let main = document.querySelector("main");
// console.log("fetch some JSON data");
// fetch(URL)
//   .then(response => response.json())
//   .then(data => {
//     // data.items[].img, data.items[].name
//     data.items.forEach(item => {
//       let fig = document.createElement("figure");
//       let fc = document.createElement("figcaption");
//       let img = document.createElement("img");
//       img.src = item.img;
//       img.alt = item.name;
//       fc.textContent = item.name;
//       fig.appendChild(img);
//       fig.appendChild(fc);
//       main.appendChild(fig);
//     });
//   });
// }

// ----------------closest and matches and querySelector-------------
/*
- querySelector => return first match
- matches => return boolean if this element match these selectors
- closest => return match element if not match search in parent chain but not brothers (if didn't find maych return null)
*/
// document.addEventListener("DOMContentLoaded", () => {
//   let target1 = document.querySelector(".para");
//   let target2 = document.querySelector("#second");
//   target1.addEventListener("click", clicked);
//   target2.addEventListener("click", clicked);
// });
// function clicked(ev) {
//   ev.preventDefault();
//   msg(ev.target + " " + ev.target.closest("#first"));
//   let obj = ev.target.closest("#first");
//   if (obj) {
//     //not null
//     obj.classList.add("active");
//   }
//   if (ev.target.matches("body main p#first")) {
//     //like if (ev.target === document.querySelector("#first")) {
//     msg("MATCHES", true);
//   } else {
//     msg("DOES NOT MATCHS", true);
//   }
// }
// function msg(txt, append = false) {
//   let out = document.querySelector(".output");
//   if (append) {
//     out.textContent = txt + " First Paragraph";
//   } else {
//     out.textContent = txt  + " First Paragraph";
//   }
// }

// -------------------Defer and Async attributes inside script tag--------------------------
/*
[1] Defer : 
The defer attribute tells the browser not to wait for the script. 
Instead, the browser will continue to process the HTML, build DOM. 
The script loads “in the background”, and then runs when the DOM is fully built.

DOMContentLoaded event handler waits for the deferred script. 
It only triggers when the script is downloaded and executed.

Deferred scripts keep their relative order, just like regular scripts.
Let’s say, we have two deferred scripts: the long.js and then small.js:
<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script

Browsers scan the page for scripts and download them in parallel, to improve performance. 
So in the example above both scripts download in parallel. The small.js probably finishes first.
…But the defer attribute, besides telling the browser “not to block”, 
ensures that the relative order is kept. 
So even though small.js loads first, it still waits and runs after long.js executes.

The defer attribute is only for external scripts
The defer attribute is ignored if the <script> tag has no src.

[2] Async: 
Async scripts are independent of other scripts and DOM.
Async scripts does not keep their relative order.

DOMContentLoaded and async scripts don’t wait for each other:
* 		DOMContentLoaded may happen both before an async script (if an async script finishes loading after the page is complete)
* 		…or after an async script (if an async script is short or was in HTTP-cache)

Here’s an example similar to what we’ve seen with defer: two scripts long.js and small.js, but now with async instead of defer.
They don’t wait for each other. Whatever loads first (probably small.js) – runs first

[3] Dynamic Script : 
let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js";
document.body.append(script); // (*)
The script starts loading as soon as it’s appended to the document (*).
Dynamic scripts behave as “async” by default.
That is:
* 		They don’t wait for anything, nothing waits for them.
* 		The script that loads first – runs first (“load-first” order).
This can be changed if we explicitly set script.async=false. 
Then scripts will be executed in the document order, just like defer.
In this example, loadScript(src) function adds a script and also sets async to false.
So long.js always runs first (as it’s added first)


function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  script.async = false;
  document.body.append(script);
}

// long.js runs first because of async=false
loadScript("/article/script-async-defer/long.js");
loadScript("/article/script-async-defer/small.js");
Without script.async=false, scripts would execute in default, load-first order (the small.js probably first).
*/

// ------------------------Content-Security-Policy--------------------
/*
<meta http-equiv="Content-Security-Policy" 
content="default-src 'self' data: gap: 'unsafe-eval' ws: ; 
style-src 'self' 'unsafe-inline'; 
script-src https: *.example.com ;
script-src 'sha256-zDSuWEvMbUxpisGOj30WQX1RQac766zuqm2VKdc6sGA=';" // using SHA (Secure Hash Algorithm)
media-src 'none'; 
font-src *;
connect-src *;
img-src 'self' data: content:;">
<!--
Also
base-uri /abc/; - limit to content in this folder  v2
form-action ; - limit where forms can be sent  v2

VALUES
'self' - anything from the same origin
data: - data-uri (base64 images)
gap: - phonegap and cordova used by plugins on iOS
ws: - web sockets
* - anything except data: and blobs
filesystem: - access things on the local filesystem
blob: - allow Binary Large OBjects
mediastream: - allow streamed media
content: - used by Cordova
'none' - prevent anything in the category
https: - anything over https://
*.example.com - anything from any subdomain of example.com
'unsafe-inline' - allow inline source elements like style attribute, onclick, or script tags 
'unsafe-eval' - allow javascript eval( ). 
--></meta>
*/

// ----------------XSS and integrity attribute on script Tag----------------------
/*
to get SHA-256 open terminal and go to location of file and then type 
( openssl dgst -sha256 -binary main.js | openssl base64 -A )
*/
// document.getElementById('btn').addEventListener('click', (ev)=>{
//     ev.preventDefault();
//     //this is the simulated response
//     let url = 'http://127.0.0.1:5500/json/nefarious.json';
//     fetch(url)
//     .then(response => response.json() )
//     .then( data => {
//         let p = document.createElement('p');
//         let content = decodeURIComponent(data.content);
//         console.log(content);
//         p.innerHTML = content;
//         document.getElementById('output').appendChild(p);
//     })
//     console.log(document.cookie)
// })


// ----------------------SVG(Scalable Vector Graphics)----------------------------
/*
* viewBox: 0 0 means position of viewbox / 250 250 means width 250px height250px => it's like box of zoom
* Circle : r = radius / cx & cy =  position of the center of the circle 
          fill = color of cirlce / stroke = color of border / stroke-width = width of border
* rect   : rx & ry = round of corners / x & y = position of the start(point left 0 top 0) of the rectangle
* line   : x1 , y1 = position of starting point of the line /  x2 , y2 = position of ending point of the line

in HTML :
<svg width="250" height="250" class="svg" viewBox="0 0 250 250">
  <circle r ="120" cx="125" cy="125" fill="none" stroke="red" stroke-width="10"/>
  <circle r ="70" cx="125" cy="125" fill="none" stroke="red" stroke-width="10"/>
  <rect rx="15" ry="15" x="25" y="25" height="200" width="200" fill="blue"/>
  <line x1="10" y1="125" x2="225" y2="225" stroke="green" stroke-width="20"/>
</svg>
*/

// --------------------touch event--------------------
/*
- we have three important properties of touch event : 
[1] touches : array of total touches inside whole screen
[2] targetTouches : array of total touches inside target
[3] changedTouches : array of new finger touch and cause the event and always length will be one 
    because it's too difficult to add two fingers at same time 1 milisecond difference will consider 2 different touches
they are touch list and don't have forEach method that's why he used spread operator

To better understand what might be in these lists, let’s go over some examples quickly. They vary according to the following rules:
* When I put a finger down, all three lists will have the same information. It will be in changedTouches because putting the finger down is what caused the event
* When I put a second finger down, touches will have two items, one for each finger. targetTouches will have two items only if the finger was placed in the same node as the first finger. changedTouches will have the information related to the second finger, because it’s what caused the event
* If I put two fingers down at exactly the same time, it’s possible to have two items in changedTouches, one for each finger
* If I move my fingers, the only list that will change is changedTouches and will contain information related to as many fingers as have moved (at least one).
* When I lift a finger, it will be removed from touches, targetTouches and will appear in changedTouches since it’s what caused the event
* Removing my last finger will leave touches and targetTouches empty, and changedTouches will contain information for the last finger

- add in css File touch-action:none; because browser has a built in events
like pull-down to refresh , two fingers to zoom in and click also out ,.... etc.
and you should disable all of this 
or you can add ev.preventDefault() to specific element will not work on document should be on specific element

- touchcancel : if for some reason ( bad connection, bad screen , 
or move from browser to another) so you can cancel the fucntion of touch 
because touchup didn't work
*/
// let topHalf = document.getElementById("top-half")

// // topHalf.addEventListener("touchstart", e => {
// //   e.preventDefault();
// //   console.log("touches", e.touches.length)
// //   console.log("targetTouches", e.targetTouches.length)
// //   console.log("Changed", e.changedTouches.length)
  
// // })
// let counter = -1;
// document.addEventListener("touchstart",e => {
//   // e.preventDefault(); //will not work should be on specific element
  
//   // here we can not use touches list because when i touch with finger and 
//   // hold then touch with 2nd finger if we use touches list will add 
//   // two dots at 2nd time triggring the function but with changedTouches
//   // the list will be only the 2nd finger touch
//   [...e.changedTouches].forEach(touch => {
//     counter++
//     const dot = document.createElement("div")
//     dot.classList.add("dot")
//     dot.style.top = `${e.touches[counter].clientY}px`
//     dot.style.left = `${e.touches[counter].clientX}px`
//     dot.id = touch.identifier
//     document.body.append(dot)
//   })
// })


// // we used here touches instead of changedTouches because touches list is not
// // empty because we move while still holding
// document.addEventListener("touchmove",e => {
//   [...e.touches].forEach(touch => {
//     const dot = document.getElementById(touch.identifier)
//     dot.style.top = `${touch.clientY}px`
//     dot.style.left = `${touch.clientX}px`
//   })
// })

// // here we should use changedTouches because it's the only list that has information
// // of last touch after removing your finger 
// document.addEventListener("touchend",e => {
//   [...e.changedTouches].forEach(touch => {
//     const dot = document.getElementById(touch.identifier)
//     dot.remove()
//     counter--
//   })
// })

// document.addEventListener("touchcancel", e => {
//   [...e.changedTouches].forEach(touch => {
//     const dot = document.getElementById(touch.identifier)
//     dot.remove()
//   })
// })

// -----------------------------------Pointer Event----------------------------
/*
-Pointer Event is combination of touch and click event 

- They are designed to create a single DOM event model to handle pointing 
input devices such as a mouse, pen/stylus or touch (such as one or more fingers).

- The touch-action CSS property is used to specify whether or not the 
browser should apply its default (native) touch behavior 
(such as zooming or panning) to a region

* auto means the browser is free to apply its default touch behavior

* none disables the browser's default touch behavior for the region => like ev.preventDefault()

* pan-x and pan-y, mean that touches that begin on the specified region are only for horizontal and vertical scrolling

* manipulation means the browser may consider touches that begin on the element are only for scrolling and zooming.


- setPointerCapture : 
This can be used to ensure that an element continues to receive pointer 
events even if the pointer device's contact moves off the element (for example by scrolling).
no need for setPointerCapture in mobile (has PointerCapture by default )
if you will use it then add if statment stop at 100% percentage if you did not add this
the timeline will continue to increase after mouse moving oustide the browser because 
we are capture all pointer events at whole screen
The browser does  releasePointerCapture  automatically when a pointerup 
or pointercancel event occurs.

- getBoundingClientRect : 
The getBoundingClientRect() method returns the size of an element and 
its position relative to the viewport.
The getBoundingClientRect() method returns a DOMRect object with eight 
properties: left, top, right, bottom, x, y, width, height.
*/

// const video = document.querySelector(".video")
// const timeline = document.querySelector(".timeline")
// let handle = document.querySelector(".handle")

// // // -----touch screen adn add dots 

// video.addEventListener("pointerdown", e => {
//   console.log("hi")
//   const dot = document.createElement("div")
//   dot.classList.add("dot")
//   dot.id = e.pointerId
//   positionDot(e, dot)
//   document.body.append(dot)
// })

// video.addEventListener("pointerup",e =>{
//   const dot = document.getElementById(e.pointerId)
//   if (dot == null) return 
//   dot.remove()
// })

// video.addEventListener("pointermove",e =>{
//   const dot = document.getElementById(e.pointerId)
//   if (dot == null) return 
//   positionDot(e, dot)
// })

// function positionDot(e, dot){
//   dot.style.width = `${e.width}px`
//   dot.style.height = `${e.height}px`
//   dot.style.left = `${e.pageX}px`
//   dot.style.top = `${e.pageY}px`
// }

// // ---moving timeline by touch and move
// timeline.addEventListener("pointerdown", e=>{
//   setTimelinePositon(e)
//   handle.setPointerCapture(e.pointerId) 
//   handle.addEventListener("pointermove",setTimelinePositon)
//   handle.addEventListener("pointerup",()=>{
//     handle.removeEventListener("pointermove",setTimelinePositon)
//     handle.releasePointerCapture(e.pointerId) // automatic browser do it
//   },{once : true}) // to trigger function only one time
// })


// function setTimelinePositon(e){
//   const rect = timeline.getBoundingClientRect()
//   let percentage = e.clientX / rect.width * 100
//   if(percentage <= 100){ // to stop at 100%
//     timeline.style.setProperty("--handle-position",`${percentage}%`)
//   }
// }

// ----another exp for pointer (slide Me)
// function beginSliding(e) {
//   slider.onpointermove = slide;
//   slider.setPointerCapture(e.pointerId);
// }

// function stopSliding(e) {
//   slider.onpointermove = null;
//   slider.releasePointerCapture(e.pointerId);
// }

// function slide(e) {
//   console.log(e.clientX)
//   let sliderPos = e.clientX - 70 // 70 is half of 140 (width of slider button)
//   let percentage = sliderPos /  parseInt(getComputedStyle(document.body).getPropertyValue("width")) * 100
//   if(percentage <= 100 && percentage >= 0){ // to stop at 100%
//     slider.style.transform = `translate(${sliderPos}px)`;
//   }
// }

// const slider = document.getElementById('slider');

// slider.onpointerdown = beginSliding;
// slider.onpointerup = stopSliding;


// ---- use of pointer-events: none; or pointer-events: all; in CSS File
/* 
pointer-events: auto; 
for every thing => none, auto, all
for SVG only => visiblePainted, visible, painted, visibleStroke, visibleFill, fill, stroke 

pointer-events: none; => prevent all click or touch event on that element
but the event still bubble up so will prevent only for this element so the 
click event will work on parent (if parent has event listener ) even if they 
has pointer-events: none;
*/

// let container = document.querySelector(".container")
// let child = document.querySelector(".child")
// let grand = document.querySelector(".grand")

// container.addEventListener("click",function(e){
//   console.log(e.currentTarget)
// })
// child.addEventListener("click",function(e){
//   console.log(e.currentTarget)
// })
// grand.addEventListener("click",function(e){
//   console.log(e.currentTarget)
// })

// ------ my exp. slide to unlock and password
// let btn = document.getElementById("btn")
// let slide = document.getElementById("slide")
// let lock = document.getElementById("lock")

// btn.addEventListener("pointerdown",function(e){
//   moveBtn(e)
//   btn.setPointerCapture(e.pointerId)
//   btn.addEventListener("pointermove",moveBtn)
//   btn.addEventListener("pointerup",function(e){
//     btn.removeEventListener("pointermove",moveBtn)
//     btn.releasePointerCapture(e.pointerId)
//   })
// })

// function moveBtn(e){
//   let slideWidth = slide.getBoundingClientRect().width
//   let slideLeft = slide.getBoundingClientRect().left
//   btn.style.left = `${e.clientX - slideLeft - 45}px`
//   if((e.clientX - slideLeft + 70) > (slideLeft + slideWidth)){
//     lock.style.display = "none"
//   }
// }

// let nums = document.querySelectorAll("#pass div")
// let arr = []

// nums.forEach(num => {
//   num.addEventListener("pointerdown", e => {
//     let numValue = +num.id.match(/\d/ig)
//     arr.push(numValue)
//   })
// })

// -----------------------intl.ListFormat----------------
// const main = document.querySelector("main");
// let staff = [
//   "Pam",
//   "Michael",
//   "Dwight",
//   "Toby",
//   "Phyliss",
//   "Jim",
//   "Stanley"
// ];
// let stuff = ["5 au", "7 mm", "16 mg", "42 km", "24 ml"];
// /**
//  * style :
//   - long  => look at conjunction
//   - short => comma between items inside array / and look at conjunction
//   - narrow => a space between items inside array
//  * type = 
//   - conjunction => will add before last item & (incase of short) or and (incase of long) or nothing (incase of narrow)
//   - disjunction => will add before (or) last item 
//   - unit (will ignore long)
//  **/
// // accept two optional parameters : language format and options object
// const formatter = new Intl.ListFormat("en", {
//   style: "short",
//   type: "disjunction"
// }); //
// main.innerHTML += "<p>" + formatter.format(staff) + "</p>";

// --------------TextNode splitText() normalize() Methods-------------

/*
splitText() method of textNode => split the textnode and accept position of splitting as parameter
normalize() method of any node => search for splitted textnodes and merge then together
*/

// document.addEventListener("DOMContentLoaded", () => {
//   let ps = document.querySelectorAll("p");
//   ps.forEach(p => {
//     document.addEventListener("click", clicked);
//     document.addEventListener("dblclick", fix);
//   });
// });
// function clicked(ev) {
//   console.log("hi")
//   let p = ev.target;
//   let txt = p.firstChild;
//   // console.log(
//   //   txt instanceof Text,
//   //   txt instanceof Node,
//   //   txt instanceof Element
//   // );
//   let len = txt.length;
//   let rand = Math.floor(Math.random() * len);
//   //console.log(len, rand);
//   txt.splitText(rand); // you will not see the difference on webpage but you can see the splitted text when you inspect on that element
// }
// function fix(ev) {
//   let p = ev.target;
//   p.normalize();
// }


// ------------------------elementFromPoint , elementsFromPoint , caretPositionFromPoint----------
/*
elementFromPoint => clicked element only
elementsFromPoint => clicked element and it's parents in parent chain
caretPositionFromPoint => object has 2 properties (offsetNode , offset)
  - offsetNode => textNode
  - offset => position inside textNode

-all of them accept two parameters x,y positions
*/
// document.addEventListener("DOMContentLoaded", () => {
//   let elems = document.querySelectorAll("main p, header h1");
//   elems.forEach(el => {
//     el.addEventListener("click", clicked);
//   });
// });
// function clicked(ev) {
//   console.log(ev.clientX, ev.x, ev.pageX, ev.screenX); //clientX and x are the same
//   console.log(ev.clientY, ev.y, ev.pageY, ev.screenY); //clientY and y are the same

//   clearHighlight();

//   let elem = document.elementFromPoint(ev.x, ev.y);
//   console.log(elem) // p => clicked element only
//   elem.classList.add("clicked");

//   let elems = document.elementsFromPoint(ev.x, ev.y);
//   console.log(elems) // [p , main , body , html] => clicked element and it's parents in parent chain 
//   elems.forEach(el => {
//     el.classList.add("clicked");
//   });
  
//   let caretPosition = document.caretPositionFromPoint(ev.x, ev.y); //Firefox and Safari only
//   let el = caretPosition.offsetNode; // textNode
//   if (el.nodeType == 3) { // 3 means textNode so we need to get it's parent to add class
//     el = el.parentElement;
//   }
//   el.classList.add("clicked");
//   console.log(caretPosition.offset); 
// }

// function clearHighlight() {
//   let clickedElements = document.querySelectorAll(".clicked");
//   clickedElements.forEach(el => {
//     el.classList.remove("clicked");
//   });
// }

// -------------------Injecting Strings into DOM as HTML------------
/**
  - [1] innerHTML => method only for html element and will convert string to html element
  - [2] new DocumentFragment() => will not convert string to html it will append it as string
    you have to append html element to document fragment not just string
  - [3] new DOMParser() => accepts 2 parameters 1st param is string 2nd param is mime type
    but return a document element (whole HTML Document) not just one element node
  - [4] range.createContextualFragment() => you have to select range first 
    you can leave range empty .createRange() or  choose postion of range like 
    range.setStart(main, 1); 1 means start from child no.1
    range.setEnd(main, 2); 2 means end to child no. 2
  - [5] insertAdjacentHTML(position, htmlString); =>  
    positions options => 'beforebegin' | 'afterbegin' | 'beforeend' | 'afterend'
 */


// let main = document.querySelector("main");

// let strHTML1 = '<p>1. This is the <a href="#">String</a> with HTML.</p>';
// let strHTML2 = '<p>2. This is the <a href="#">String</a> with HTML.</p>';
// let strHTML3 = '<p>3. This is the <a href="#">String</a> with HTML.</p>';
// let strHTML4 = '<p>4. This is the <a href="#">String</a> with HTML.</p>';
// let strHTML5 = '<p>5. This is the <a href="#">String</a> with HTML.</p>';
// let strHTML6 = '<p>6. This is the <a href="#">String</a> with HTML.</p>';

// //version 1 - innerHTML
// main.innerHTML = strHTML1;

// //version 2a - document.createDocumentFragment()
// //version 2b - new DocumentFragment()
// let frag = new DocumentFragment();
// frag.append(strHTML2); // will not be appended to webpage
// // will keep it as the same string
// // innerHTML not available on a document fragment
// // need to create actual DOM nodes to append...
// // so we can do pattern matching on the string can create the nodes
// // or use the DOMParser below to convert and then append
// //console.log(frag);
// //GREAT INSIDE A LOOP. DO THE APPEND AFTER THE LOOP
// //main.appendChild(frag);

// //version 3 - new DomParser()
// let parser = new DOMParser();
// let doc = parser.parseFromString(strHTML3, "text/html");
// //doc.documentElement - whole HTML Document
// console.log(doc.documentElement);
// main.appendChild(doc.body.firstChild);

// //version 4a - range.createContextualFragment()
// let frag2 = document.createRange().createContextualFragment(strHTML4);
// main.appendChild(frag2);

// //version 4b - range.createContextualFragment()
// let range = document.createRange();
// range.setStart(main, 1); //after the one added with innerHTML
// range.setEnd(main, 2);
// let frag3 = range.createContextualFragment(strHTML5);
// range.insertNode(frag3);

// //version 5 - insertAdjacentHTML()
// main.insertAdjacentHTML("afterbegin", strHTML6);

// --------------------------Google Maps GeoCoding-------------------------
// const KEY = "AIzaSyD8LFh53VddzDevOC6A5Jhln9KgpmpoExg"; // i need a different KEY
// const LAT = 50.1;
// const LNG = -97.3;
// let url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${LAT},${LNG}&key=${KEY}`;
// fetch(url)
// .then(response => response.json())
// .then(data => {
//   console.log(data);
//   let parts = data.results[0].address_components;
//   document.body.insertAdjacentHTML(
//     "beforeend",
//     `<p>Formatted: ${data.results[0].formatted_address}</p>`
//   );
//   parts.forEach(part => {
//     if (part.types.includes("country")) {
//       //we found "country" inside the data.results[0].address_components[x].types array
//       document.body.insertAdjacentHTML(
//         "beforeend",
//         `<p>COUNTRY: ${part.long_name}</p>`
//       );
//     }
//     if (part.types.includes("administrative_area_level_1")) {
//       document.body.insertAdjacentHTML(
//         "beforeend",
//         `<p>PROVINCE: ${part.long_name}</p>`
//       );
//     }
//     if (part.types.includes("administrative_area_level_3")) {
//       document.body.insertAdjacentHTML(
//         "beforeend",
//         `<p>LEVEL 3: ${part.long_name}</p>`
//       );
//     }
//   });
// })
// .catch(err => console.warn(err.message));

// -------------------Combining async await with fetch--------------------

// (async function f() {
//   let badurl = "http://";
//   let goodurl = "http://jsonplaceholder.typicode.com/users";
//   let rand = Math.round(Math.random())
//   let url = rand ? badurl : goodurl;
//   // here we use await before fetch and this will return response object 
//   // and used another await because .json() also asynchrnous and return promise so we need await to get data
//   let data = await (await fetch(url).catch(handleErr)).json();
//   if (data.code && data.code == 400) {
//     //problem
//     return;
//   }
//   console.log(data);
// })();

// function handleErr(err) {
//   // we need to return a reponse object because we are using .json() which works only on response objects
//   let resp = new Response(
//     JSON.stringify({
//       code: 400,
//       message: "Stupid network Error"
//     })
//   );
//   return resp;
// }

// -------------------------MatchMedia-------------
// return mediaQueryList and has property called matches (true or false)
// document.addEventListener("DOMContentLoaded",init)
// window.addEventListener("resize", init) // to make dynamic 

// function init(){
//   let query = window.matchMedia("(min-width: 601px)")
//   if(query.matches){
//     document.querySelector("h1").style.display = "block"
//     document.querySelector("h1").style.color = "red"
//   }else{
//     document.querySelector("h1").style.display = "none"
//   }
// }

// ------------------------Animated Hamburger menu-------------

// let ISEXPANDED = true;

// document.addEventListener("DOMContentLoaded", () => {
//   //handle click event
//   let body = document.body
//   let burger = document.querySelector(".burger");
//   burger.addEventListener("click", ev => {
//     console.log("toggle expanded on header");
//     body.classList.toggle(
//       "expanded"
//     ); /* showing the menu and the X */
//   });

//   //handle media query when the page loads for the default state onload
//   let query = window.matchMedia("(min-width:700px)");
//   if (query.matches) {
//     body.classList.add("expanded");
//     ISEXPANDED = true;
//   } else {
//     body.classList.remove("expanded");
//     ISEXPANDED = false;
//   }

//   // to handle as the page size change you have two options : [1] ResizeObserver or [2] resize event

//   // // using [1] ResizeObserver
//   const resizeObserver = new ResizeObserver(entries => {
//     for (let entry of entries) {
//       if (entry.contentRect.width > 700 && !ISEXPANDED) {
//         body.classList.add("expanded");
//         ISEXPANDED = true;
//       } else if (entry.contentRect.width < 700 && ISEXPANDED) {
//         body.classList.remove("expanded");
//         ISEXPANDED = false;
//       }
//     }
//   });
//   resizeObserver.observe(body);

//   // // using [2] Resize event ( resize event works on window object not body)
//   // window.addEventListener("resize", function(){
//   //   let query = window.matchMedia("(min-width:700px)");
//   //   if (query.matches) {
//   //     body.classList.add("expanded");
//   //     ISEXPANDED = true;
//   //   } else {
//   //     body.classList.remove("expanded");
//   //     ISEXPANDED = false;
//   //   }
//   // })
// });


// -------------------encodeURI vs encodeURIComponent-----------------
/**
encodeURI => keep URI as it is and can be used as href
encodeURIComponent => encode URI to send it to server with Base-64 data

encodeURIComponent - encodes all characters except:
  A-Z a-z 0-9 - _ . ! ~ * ' ( )
Encode everything. When you want to send some data that is encoded. 
Useful for Base-64 data A-Z a-z 0-9 + /

encodeURI - encodes  all characters except the previous list AND
  ; , / ? : @ & = + $ #
Keeps the URL as a usable URL.

Sample text
http://user@pass:www.example.com:5000/path/file?name=value&name2=value2#someId

😀 😁 😂 🤣 😃 😄 😅

try this to on encodeURI and encodeURIComponent https://domain.com/path to a document.pdf
**/
// document.addEventListener("DOMContentLoaded", () => {
//   document
//     .getElementById("btnEncode")
//     .addEventListener("click", doEncode);
//   document
//     .getElementById("btnDecode")
//     .addEventListener("click", doDecode);
// });
// function doEncode() {
//   let txt = document.getElementById("start").value;
//   let areaEncoded = document.getElementById("encoded");
//   let areaEncodedComp = document.getElementById("encodedComp");
//   areaEncoded.value = encodeURI(txt);
//   areaEncodedComp.value = encodeURIComponent(txt);

//   let lnk = document.getElementById("lnk");
//   lnk.href = encodeURI(txt);
// }
// function doDecode() {
//   let txt = document.getElementById("start").value;
//   let areaEncoded = document.getElementById("encoded");
//   let areaEncodedComp = document.getElementById("encodedComp");
//   areaEncoded.value = decodeURI(txt);
//   areaEncodedComp.value = decodeURIComponent(txt);
// }


// ------------------------------Scroll Methods-----------------------------
/*
scrollTo => Move the top left point to the provided coordinates.
scrollBy => Move the top left point of the element by the horizontal and vertical values provided.
scrollIntoView => The Boolean indicates whether or not to align top of element to top of the screen.

- scrollTo & scrollBy only for scrollable element (only the page it self document.documentElement)
- scrollIntoView for any element

- Options object version not supported in IE, Edge, or Safari:
Element.scrollIntoView({
    behaviour: "smooth" 
    block: "start",
    inline: "nearest"
});
* block and inline can effect flex direction! be carefull
=> block => vertical alignment 
=> online => horizontal alignment
values of block or inline => "start", "nearest", "center", or "end"
* start => align top of block to top of the page
* center => align center of block to center of the page
* end => align end of block to end of the page
* nearest => align nearest edge of block to nearest edge of the page

*/
// let to = document.getElementById('scroll-to');
// let by = document.getElementById('scroll-by');
// let into = document.getElementById('scroll-into-view');
// to.addEventListener('click', (ev)=>{
//   document.documentElement.scrollTo(0, 250); // to position 0, 250
// });
// by.addEventListener('click', (ev)=>{
//   document.documentElement.scrollBy(0, 100); //250px down from current position
// });
// into.addEventListener('click', (ev)=>{
//   by.scrollIntoView(true); //show the scroll-by element into view if false depend on browser(safari) will scroll to the top of page
//   // by.scrollIntoView({
//   //   behavior: 'smooth',
//   //   block: 'center',
//   //   inline: "start"
//   // })
// });

// -----------------------------Shrinking Header--------------------

// document.addEventListener("DOMContentLoaded", () => {
//   window.addEventListener("scroll", debounce(rollup));
// });


// function rollup(ev) {
//   // console.log(window.scrollY);
//   if (window.scrollY > 60) {
//     document.body.classList.add("up");
//   } else {
//     document.body.classList.remove("up");
//   }
// }

// //use debounce for better performance
// const debounce = func => {
//   let timer;
//   return event => {
//     if (timer) {
//       clearTimeout(timer);
//     }
//     //100ms is the current delay being used
//     timer = setTimeout(func, 100, event);
//   };
// };


// --------------------Removing Elements and optional chaining----------------
/*
the concept of removal basically means breaking the relationship between a child 
and its parent. It's just a detachment.

remove only needs a reference to the child. 
removeChild needs a reference both to the parent and the child. The result is identical.

after removing element it is not removed from the memory and you can append it again
if you want to remove it from memory you can do this : element = null;

The closest() method searches up the DOM tree for elements which matches a specified CSS selector.
The closest() method starts at the element itself, then the anchestors (parent, grandparent, ...) until a match is found.
The closest() method returns null() if no match is found.

*/
// document.addEventListener('DOMContentLoaded', () => {
//   document.querySelector('main').addEventListener('click', removePara);
// });
// function removePara(ev) {
//   //remove the paragraph that was clicked.
//   //get the correct element
//   console.log(ev.target, ev.currentTarget);
//   // (main, p.para, span ) vs main
//   // target was the first element clicked
//   // currentTarget is the element that owns the eventListener
//   let main = ev.currentTarget;
//   let p = ev.target.closest('.para');
//   console.log(p)
//   p?.parentElement.removeChild(p); // optional chaining
//   // if (p) {
//   //   main.removeChild(p);
//   // }
//   //p?.remove(); // optional chaining
//   // if (p) {
//   //   p.remove();
//   // }
// }

// ------------------------------------Using FormData to ParseForms--------------------------
// do not forget to add name attribute (in HTML )to each input if not no data will sent to server
// document.addEventListener('DOMContentLoaded', () => {
//   document
//     .getElementById('myForm')
//     .addEventListener('submit', handleForm);
// });

// function handleForm(ev) {
//   ev.preventDefault(); //stop the page reloading
//   //console.dir(ev.target);
//   let myForm = ev.target;
//   let fd = new FormData(myForm);

//   //add more things that were not in the form
//   fd.append('api-key', 'myApiKey');

//   //look at all the contents
//   for (let key of fd.keys()) {
//     console.log(key, fd.get(key));
//   }
//   let json = convertFD2JSON(fd);

//   //send the request with the formdata
//   let url = 'http://localhost:1234/';

//   let req = new Request(url, {
//     // body : fd,
//     body: json, // if you want to send it as json
//     method: 'POST',
//     mode: 'cors'
//   });
//   //console.log(req);
//   fetch(req)
//     .then((res) => res.json())
//     .then((data) => {
//       console.log('Response from server');
//       console.log(data);
//     })
//     .catch(console.warn);
// }

// function convertFD2JSON(formData) {
//   let obj = {};
//   for (let key of formData.keys()) {
//     obj[key] = formData.get(key);
//   }
//   return JSON.stringify(obj);
// }

// ---------------------------------Ternary operator------------------------
// //FALSEY - 0, null, undefined, false, "", NaN

// //basic
// let age = 42;
// //age < 50 ? console.log('ok zoomer') : console.log('ok boomer');

// //assignment
// let num = Math.floor(Math.random() * 20);
// let result = num % 2 == 0 ? 'even' : 'odd';
// //console.log(result, num);

// //nested
// let salary = 60_000; //numeric separator: https://www.youtube.com/watch?v=IU9_26x5N5A
// let taxrate = salary <= 20_000 ? 0 : salary > 100_000 ? 30 : 20;
// console.log(taxrate);

// //html
// let side = document.querySelector('.side');
// side = side ? side : document.body;
// side.className = 'hey';

// -----------------------------URL object----------------------
/*
URL properties
hash - The part that starts with `#` and refers to an id
hostname - the domain part without the http://
host - Same as hostname plus port number
href - the full url. Same as using .toString() method
origin - Same as host prefixed with the protocol
password - https://username:password@www.example.com
pathname - after the domain. Folder and file name
port - :80  :443
protocol - http or https usually
search - Begins with `?`. The query string
searchParams - An object built from the parsed query string
username - https://username:password@www.example.com
*/
// document.addEventListener('DOMContentLoaded', () => {
//   let a = document.getElementById('link');
//   let img = a.querySelector('img');
//   let aHref = a.href;
//   let imgHref = img.src;
//   console.log(typeof aHref, aHref);
//   console.log(typeof imgHref, imgHref);

//   let aURL = new URL(aHref);
//   // let iURL = new URL(imgHref);
//   console.log(aURL);
//   // console.log(iURL);

//   aURL.searchParams.forEach((val, name) => {
//     console.log(name, '::', val);
//   });

//   let val = aURL.searchParams.get('ikwid');
//   console.log(val);
// });

// ------------------------event options object------------------
/*
- passive: <boolean> 
Every time you scroll by touching the screen or the wheel of your mouse, 
the browser needs to check that your code won’t cancel the default actions (even if you didn't add ev.preventDefault()). 
This means it’ll wait a certain amount of time, just in case, resulting in poor performance.
By marking a touch or wheel listener as passive : true, 
the developer is promising the handler won't call preventDefault to disable scrolling


* document.body is by default passive:true so if you add touch event to it with ev.preventDefault()
will warn you ([Intervention] Unable to preventDefault inside passive event listener targer being treated as passive)

* false => with ev.preventDefault() and touch event to disable 
default behaviour of browser like zoom or scroll or drag down to refreash 

* true => with ev.preventDefault() and touch event will warn you (Unable to preventDefault inside passive event listener invocation) 
used to improve performance 

* doesn't work with pointer event beacuse ev.preventDefault() not working with pointer events
because Pointer events will receive a pointercancel event when the browser starts 
handling a touch gesture.
use instead touch-action inside CSS File

- once: <boolean> true => triggered only one time then remove the event listener
- capture: <boolean> false(default) => bubble up / true => bubble down

*/
// document.addEventListener('DOMContentLoaded', () => {
//   //add listeners  - useCapture
//   document
//     .querySelector('main p')
//     .addEventListener('click', f1, { capture: false, once: true });

//   document.body.addEventListener('touchstart', f2, {
//     capture: false,
//     // passive: false,
//   });

//   document
//     .querySelector('p:nth-child(2)')
//     .addEventListener('touchstart', f3, {
//       capture: false,
//       // passive: false,
//     });
// });

// function f1(ev) {
//   let num = Math.random().toString(16).substr(2, 6);
//   console.log(num);
//   ev.target.style.backgroundColor = `#${num}`;
// }

// function f2(ev) {
//   ev.preventDefault();
//   console.log('touchstart on body');
// }

// function f3(ev) {
//   ev.preventDefault();
//   console.log('touchstart on p 2');
// }

// -------------------------------------dark mode----------------------
/*
- look at css media queries
- window.matchMedia("(prefers-color-scheme:light)").addEventListener("change",function(){})
  window.matchMedia("(prefers-color-scheme:dark)").addEventListener("change",function(){})
  both will trigger at same time it does not matter which mode or changing to which mode 
  so i add only 1 addEventListener and add checkMode() function to check the mode

  The prefers-color-scheme CSS media feature is used to detect if a user has requested 
  light or dark color themes. A user indicates their preference through an operating system 
  setting (e.g. light or dark mode) or a user agent setting.
*/

// let h2 = document.createElement("h2");
// document.querySelector("header").appendChild(h2);

// window.matchMedia("(prefers-color-scheme:light)").addEventListener("change",function(){
//   checkMode()
// })

// checkMode()

// function changeToLight(){
//   document.querySelector("h1").textContent = "Browser Light Mode";
//   h2.textContent = "Come to the darkside";
// }
// function changeToDark(){
//   document.querySelector("h1").textContent = "Browser dark Mode";
//   h2.textContent = "Come to the lightside";
// }

// function checkMode(){
//   let light = window.matchMedia("(prefers-color-scheme:light)").matches 
//   let mode = light ? "light" : "dark"
//   if(mode === "light"){
//     changeToLight()
//   }else if(mode === "dark"){
//     changeToDark()
//   }
// }


// --------------------------------Long Press event--------------------------
// document.addEventListener('DOMContentLoaded', () => {
//   addClickTouch();
// });

// let timmy = null;
// let timmyLong = null;
// const delay = 800; //ms delay to be considered a long press

// function addClickTouch() {
//   //stop the longpress delay if it has started because clearTimeout cancel the setTimeout and stop it's callback function
//   clearTimeout(timmy); 
  
//   // [1] chech if the device accept touch or click
//   // if ('ontouchstart' in document.body) {
//   //   document.querySelectorAll('[data-long]').forEach((btn) => {
//   //     btn.addEventListener('touchstart', start, {
//   //       once: true,
//   //     });
//   //   });
//   // } else {
//   //   document.querySelectorAll('[data-long]').forEach((btn) => {
//   //     btn.addEventListener('mousedown', start, {
//   //       once: true,
//   //     });
//   //   });
//   // }

// // [2] using pointer no need to check if the device accept touch or click
//   document.querySelectorAll('[data-long]').forEach((btn) => {
//     btn.addEventListener('pointerdown', start, {
//       once: true,
//     });
//   });

// }

// function start(ev) {
//   //[1] to prevent the touchstart context menu and select text (only when using touch or click event)
//   // ev.preventDefault();

//   // [2] to prevent the context menu and select text (only when using pointer event)
//   // adding touch-action:none; and user-select:none; in CSS File and oncontextmenu="return false;" in HTML

//   let btn = ev.target.closest('[data-long]');
//   btn.innerHTML = '👍'; //remove the other buttons

//   timmy = setTimeout(longPress.bind(btn), delay); // the LONG PRESS
  
//   // [1] using touch or mouse click events
//   // btn.addEventListener('mouseup', addClickTouch);
//   // btn.addEventListener('touchcancel', addClickTouch);
  
//   // [2] using pointer events
//   btn.addEventListener('pointerup', addClickTouch);
//   btn.addEventListener('pointercancel', addClickTouch);
// }

// function longPress() {
//   let btn = this;
//   // [1] using touch or mouse click events
//   // btn.removeEventListener('mouseup', addClickTouch);
//   // btn.removeEventListener('touchcancel', addClickTouch);

//   // [2] using pointer events
//   btn.removeEventListener('pointerup', addClickTouch);

//   //remove all the flyout buttons after delay if no interaction for 3 seconds
//   timmyLong = setTimeout(resetButtons.bind(btn), 3000);

//   let template = document.getElementById('emojis');
//   let content = template.content.cloneNode(true);
//   btn.appendChild(content);
//   btn.querySelectorAll('button').forEach((b) => {

//     // [1] using touch or mouse click events
//     // if ('ontouchstart' in document.body) {
//     //   b.addEventListener('touchend', selected, {
//     //     capture: false,
//     //     once: true,
//     //   });
//     // } else {
//     //   b.addEventListener('mouseup', selected, {
//     //     capture: false,
//     //     once: true,
//     //   });
//     // }

//     // [2] using pointer events
//     b.addEventListener('pointerup', selected, {
//           capture: false,
//           once: true,
//         });
//     // to wait tell buttons added inside main btn then add class go if we added directly without
//     // setTimeout will add move move directly without animation
//     setTimeout(function () {
//       b.classList.add('go');
//     }, 0);
//   });
// }

// function resetButtons() {
//   this.innerHTML = '👍';
//   addClickTouch();
// }

// function selected(ev) {
//   ev.stopImmediatePropagation(); //stop bubble up => don't send the click to the main button
//   console.log('selected', ev.target);
//   clearTimeout(timmyLong); //we have interacted...
//   let b = ev.target; // <button class="top happy go">
//   let arr = Array.from(b.classList).filter(
//     (cls) =>
//       cls != 'go' &&
//       cls != 'top' &&
//       cls != 'right' &&
//       cls != 'bottom' &&
//       cls != 'left'
//   );
//   let match = arr[0]; //the selected class
//   document.querySelector('header h2').textContent = `You are ${match}`;
//   let btn = ev.target.parentElement;
//   btn.querySelectorAll('button').forEach((item) => {
//     //loop through the 4 child buttons
//     if (item.classList.contains(match)) {
//       setTimeout(
//         function (item) {
//           item.remove();
//           resetButtons.call(this);
//         }.bind(btn, item),
//         delay
//       );
//       //delay removing the selected one same length as the long press
//     } else {
//       item.remove();
//       //remove all the flyout buttons except the selected ones
//     }
//   });
// }


// ------------------difference between EventHandlers and addEventListener------------------

/*
- if you add two event handlers for the same button click, the second event handler 
will overwrite the first and only that event will trigger

- you can only have one event handler per event type, 
but you can have multiple event listeners
*/

// let google = document.querySelector("a")

// // this will override the default click and will not go to google.com
// google.onclick = function(){
//   return false
// }

// // this will create a new event and will not prevent default click and will go to google.com
// google.addEventListener("click",function(){
//   return false
// })

// ------------------------------Composed Path event--------------------
// composedPath() return an array of full path of an element inside DOM (from that element to it's parents till window)
// document.addEventListener('DOMContentLoaded', () => {
//   //add click listeners to ALL elements inside main
//   document.querySelectorAll('main *').forEach(addClick);
// });

// function addClick(tag) {
//   //add a click listener to the tag
//   tag.addEventListener('click', (ev) => {
//     ev.preventDefault(); //just to stop the anchor
//     ev.stopPropagation();
//     console.log(ev.target.tagName);
//     console.log(ev.composedPath()); // Array
//   });
// }

// ------------------------------Page Lifecycle API---------------------------
/*
*** page has 6 visibility states : 
[1] Active 
[2] Passive  
[3] Hidden  
[4] Frozen 
[5] Terminated 
[6] Discarded

In the active, passive, and hidden states, it's possible to run JavaScript code that 
determines the current Page Lifecycle state from existing web platform APIs.

const getState = () => {
  if (document.visibilityState === 'hidden') {
    return 'hidden';
  }
  if (document.hasFocus()) {
    return 'active';
  }
  return 'passive';
};

The frozen and terminated states, on the other hand, can only be detected in their 
respective event listener (freeze and pagehide) as the state is changing.

the document object also now includes a wasDiscarded property. 
To determine whether a page was discarded while in a hidden tab, you can inspect 
the value of this property at page load time (note: discarded pages must be reloaded to use again).

developers can now observe when a hidden tab is frozen and unfrozen by listening for the freeze and resume events on document.

Not all Page Lifecycle events have the same target. 
pagehide, and pageshow are fired on window; 
visibilitychange, freeze, and resume are fired on document
focus and blur are fired on their respective DOM elements.

* bfcache (back forward cache)
bfcache is an in-memory cache that stores a complete snapshot of a page 
(including the JavaScript heap) as the user is navigating away. With the entire page 
in memory, the browser can quickly and easily restore it if the user decides to return.
How many times have you visited a website and clicked a link to go to another page, only 
to realize it's not what you wanted and click the back button? In that moment, bfcache can 
make a big difference in how fast the previous page loads:

** there are events in Page lifeCycle : 
[1] pageshow
[2] focus
[3] blur
[4] visibilitychange
[5] freeze
[6] resume
[7] beforeunload
[8] pagehide
[9] unload

*/

// --[4]visibilitychange event
/*
- The visibilitychange event is fired at the document when the contents of its tab have 
become visible or have been hidden.

- This event fires with a visibilityState of hidden when a user navigates to a new page, 
switches tabs, closes the tab, minimizes or closes the browser, or, on mobile, switches 
from the browser to a different app. 

- Examples:

[1] Pausing music on transitioning to hidden
This example begins playing a music track when the document becomes visible, 
and pauses the music when the document is no longer visible.

document.addEventListener("visibilitychange", function() {
  if (document.visibilityState === 'visible') {
    backgroundMusic.play();
  } else {
    backgroundMusic.pause();
  }
});

[2] Sending end-of-session analytics on transitioning to hidden
This example treats the transition to hidden as the end of the user's session, 
and sends the appropriate analytics using the Navigator.sendBeacon() API:

document.onvisibilitychange = function() {
  if (document.visibilityState === 'hidden') {
    navigator.sendBeacon('/log', analyticsData);
  }
};
*/
// document.onvisibilitychange = function() {
//   if (document.visibilityState === 'hidden') {
//     console.log("why you left me!")
//   }
// };

// ----[7]beforeunload
/* 
Never add a beforeunload listener unconditionally or use it as an end-of-session signal. 
Only add it when a user has unsaved work, and remove it as soon as that work has been saved.

but using it prevents pages from being added to the Back-Forward Cache, 
it's recommended that you only add beforeunload listeners when a user has unsaved 
changes and then remove them immediately after the unsaved changes are saved.

onAllChangesSaved(() => {
  removeEventListener('beforeunload', beforeUnloadListener, {capture: true});
});

- add the event to the window object
- Or assign an event to the onbeforeunload attribute of the <body> element in HTML file

if you want to warn the user that there is some promises or fetching still working
you can create set then add promises to that set and make if statment to know if it's empty or not

or you can create a variable and assign it to false if(!variable) ev.returnValue = "still waiting?"

const pendingPromises = new Set()
const cleanup = () => pendingPromises.delete(promise);

function updatePage(){
  // promises
  const promise = fetch("")
  
  // add promises to Set
  pendingPromises.add(promise)

  // remove promise after success or faliure
  promise.then(cleanup).catch(cleanup)
}
window.addEventListener("beforeunload", function(ev){
  if(pendingPromises.size){
    ev.returnValue = "still waiting?"
  }
})
*/

// ---[8] pagehide event
/*
The pagehide event is sent to a Window when the browser hides the current page in the process
of presenting a different page from the session's history.
For example, when the user clicks the browser's Back button, 
the current page receives a pagehide event before the previous page is shown.

The persisted property returns a Boolean value that indicates if the webpage is 
loaded directly from the server, or if the page is cached, when an onpageshow or onpagehide 
event occurs.

window.onpagehide = function(ev) {
  let txt = JSON.stringify(ev.persisted)
  window.localStorage.setItem("pagehide",txt)
};
*/

// ---[9]unload
/*
Never use the unload event on modern browsers.

Many developers treat the unload event as a guaranteed callback and use it as an 
end-of-session signal to save state and send analytics data, but doing this is extremely 
unreliable, especially on mobile! The unload event does not fire in many typical unload 
situations, including closing a tab from the tab switcher on mobile or closing the browser 
app from the app switcher.
For this reason, it's always better to rely on the visibilitychange event to determine when 
a session ends, and consider the hidden state the last reliable time to save app and user data.

Furthermore, the mere presence of a registered unload event handler (via either onunload or 
  addEventListener()) can prevent browsers from being able to put pages in the Back-Forward 
  Cache for faster back and forward loads.
In all modern browsers (including IE11), it's recommended to always use the pagehide event 
to detect possible page unloads (a.k.a the terminated state) rather than the unload event. 
If you need to support Internet Explorer versions 10 and lower, you should feature detect 
the pagehide event and only use unload if the browser doesn't support pagehide:
*/

// ----------------------------------sendBeacon()------------------------------
/*
if you want to make fetch request or any request to server when leaving the page you can not use unload
or beforeunload event because these requests will be rejected
but with navigatior.sendBeacon() you can send request to the server but you will not get respnse
*/

// beforeunload or unload
// window.addEventListener('unload', (ev) => {
//   console.log(ev);
//   // fetchVersion(ev); // will not work
//   beaconVersion(ev);
// });

// function fetchVersion(ev) {
//   let url = 'http://127.0.0.1:3333/analytics';
//   fetch(url)
//     .then((res) => res.json())
//     .then((content) => {
//       localStorage.setItem('departed', JSON.stringify(content));
//     })
//     .catch((err) => console.error);
// }

// function beaconVersion(ev) {
//   let url = 'http://127.0.0.1:3333/analytics';
//   let data = JSON.stringify({ departure: Date.now() });
//   //Always POST
//   //status of request will always be pending because we will not get response
//   //ArrayBuffer, ArrayBufferView, Blob, DOMString, FormData,
//   // or URLSearchParams object containing the data to send.
//   navigator.sendBeacon(url, data); 
//   console.log(data);
// }

// -----------------------------requestAnimationFrame()-----------------------
/*
The window.requestAnimationFrame() method tells the browser that you wish to perform 
an animation and requests that the browser calls a specified function to update an 
animation before the next repaint. The method takes a callback as an argument to be 
invoked before the repaint.

If you go to another tab on browser (visibilitystate hidden ) the browser will pause the requestAnimationFrame
But setInterval will still running in background

The callback method is passed a single argument, 
a DOMHighResTimeStamp, which indicates the current time 
(based on the number of milliseconds since time origin => first requestAnimationFrame call)
DOMHighResTimeStamp value will change according to the refresh rate of screen
*/

// let output = document.getElementById('output');
// let box = document.getElementById('box');
// let number = 0;
// let xpos = 0;
// function paint() {
//   number++;
//   output.textContent = number;

//   if (number < 300) {
//     // paint(); // if we use this we will not see number increase will see 300 immediatlty
//     requestAnimationFrame(paint);
//   }
// }

// function move(timmy) {
//   if (timmy) {
//     let diff = timmy - number;
//     console.log('DOMHighResTimeStamp', timmy);
//     console.log('frame', diff); // 16.6 means 60 fps
//     number = timmy; //DOMHighResTimeStamp
//   }
//   xpos = xpos + 5;
//   box.style.transform = `translateX(${xpos}px)`;
//   let ww = document.body.clientWidth - 100;
//   if (xpos < ww) {
//     // move() // if we use this will not see block moving we will see it at the end immediatly
//     requestAnimationFrame(move);
//   }
// }

// // paint()
// move()

// ---------------------alert , confirm & prompt------------------
// document.addEventListener('DOMContentLoaded', () => {
//   document.querySelector('p.a').addEventListener('click', handleClickA);
//   document.querySelector('p.c').addEventListener('click', handleClickC);
//   document.querySelector('p.p').addEventListener('click', handleClickP);
//   if ('document' in window) {
//     console.log('doc');
//   }
// });

// function handleClickA(ev) {
//   //alert
//   let answer = alert('this is a message');
//   console.log(answer); //undefined
// }
// function handleClickC(ev) {
//   //confirm
//   let answer = confirm('Are you sure?');
//   console.log(answer); //true false
// }
// function handleClickP(ev) {
//   //prompt
//   let answer = prompt('This is my question', 'default answer');
//   console.log(answer); //answer -- null if cancel
// }

// ----------------------------------window.open()---------------------------
/*
* values inisde target attribute in <a> in HTML or window.open(url, '_blank', features) : 
[1] _blank => open in new tab or window ( depend on features options )
[2] _self => open at the same tab (doesn't depend on features options)
[3] frame name => open at iframe with attribute name ="frame name"
[4] _parent => Will open the in the next level up of a frame if they were nested to inside one another
[5] _top => his breaks outside of all the frames it is nested in and opens the link as top document in the browser window.
*/

// let other = null; //will be our window reference
// let features =
//   'menubar=yes,location=yes,resizable=yes,scrollbars=yes,status=yes';
// //,height=400,width=400

// document.getElementById('btnGoogle').addEventListener('click', (ev) => {
//   //open google in a new tab or window
//   let url = 'https://google.com/';
//   // _blank is the default is open in new tab if you need to open in new window 
//   // you can change some features then window can not open two tabs with different features so open it in a new window
//   let other = window.open(url, '_blank', features);
// });
// document.getElementById('btnSelf').addEventListener('click', (ev) => {
//   //open google in current tab
//   let url = 'https://google.com/';
//   window.open(url, '_self');
// });
// document.getElementById('btnTwo').addEventListener('click', (ev) => {
//   //open local page in a new tab
//   let url = 'http://127.0.0.1:5500/index.html';
//   let other = window.open(url, '_blank');
//   // we should add setTimeout because the window.open() will take time to open and we need to wait
//   // before add style to it
//   setTimeout(() => {
//     other.document.body.style.backgroundColor = 'cornflowerblue';
//   }, 1000);
// });
// document.getElementById('btnFrame').addEventListener('click', (ev) => {
//   //open local page in the iFrame
//   let url = 'http://127.0.0.1:5500/index.html';
//   let other = window.open(url, 'myFrame');
//   setTimeout(() => {
//     other.document.body.style.backgroundColor = 'cornflowerblue';
//   }, 1000);
// });
// document.getElementById('btnColor').addEventListener('click', (ev) => {
//   //set a random background colour in the iframe's document
//   let clr = `#${Math.random().toString(16).substring(2, 8)}`;
//   let fr = document.querySelector('iframe');
//   fr.contentDocument.body.style.backgroundColor = clr;
//   fr.contentWindow.document.body.style.backgroundColor = clr;
// });

// ---------------------select between HTML and JS------------------------
/*
Selecting multiple options vary in different operating systems and browsers:
* For windows: Hold down the control (ctrl) button to select multiple options
* For Mac: Hold down the command button to select multiple options

Because of the different ways of doing this, and because you have to inform the user that 
multiple selection is available, it is more user-friendly to use checkboxes instead.
*/
// document.addEventListener('DOMContentLoaded', () => {
//   document.getElementById('flavours').addEventListener('input', handleSelect);
//   document.getElementById('thing').addEventListener('input', handleData);
// });

// function handleSelect(ev) {
//   //document.getElementById('flavours'); is the same because select element has 
//   // property called value (the value selected) but give you only 1st selection so we need to do loop 
//   //  incase of multiple selection
//   let select = ev.target; 
//   console.log(select.value);
//   console.log(select.selectedOptions) // HTML Collection
//   let choices = [];
//   // for (let i = 0; i < select.selectedOptions.length; i++) {
//   //   choices.push(select.selectedOptions[i].value);
//   // }
//   choices = [].map.call(select.selectedOptions, (option) => option.value);
//   console.log(choices);
// }
// function handleData(ev) {
//   let theInput = ev.target;
//   console.log(theInput.value, typeof theInput.value);
// }

// -----------------------Console is more than just log---------------------
/*
console.trace() => show you the call path taken to reach the point at which you call console.trace()
1st anonymous means global scope
function scope if has name will show it's name if not will show anonymous
*/
// let log = console.log;
// let str = 'Hello';
// let num = 123;
// let bool = true;
// const data = {
//   prop1: 'hello',
//   prop2: [
//     { id: 1, name: 'Marshall', actor: 'Jason' },
//     { id: 2, name: 'Barney', actor: 'Neil' },
//     { id: 3, name: 'Robin', actor: 'Cobie' },
//     { id: 4, name: 'Lily', actor: 'Alyson' },
//     { id: 5, name: 'Ted', actor: 'Josh' },
//   ],
// };
// const funcs = {
//   f1() {
//     log('inside f1');
//     funcs.f2();
//   },
//   f2() {
//     log('inside f2');
//     funcs.f3();
//   },
//   f3() {
//     log('inside f3');
//     funcs.f4();
//   },
//   f4() {
//     console.trace('inside f4'); // give you entire stack
//     // done the chain
//   },
// };

// log('1st: ', str, num, bool);
// log('2nd: ' + str + ' ' + num);

// // log('3rd: ' + data);
// // log('4th:', data);
// // log({ data });

// console.table(data);
// console.table(data.prop2);

// funcs.f1();
// funcs.f4();
// setTimeout(function bob() {
//   funcs.f4(); 
// }, 1000);

// console.error('hello');
// console.warn('hello');
// console.info('hello');

// -------------------------------monitorEvents-------------------
/*
only on console on Browser to track any keydown or mousedown 
monitorEvents(document.body, 'keydown');
// to remove the event
unmonitorEvents(document.body, "keydown")
*/


// --------------------------practical EXP. LocalStorage--------------
// const APP = {
//   keybase: 'Steve-Shows-App-',
//   keys: [],
//   init() {
//     //start the app
//     document.getElementById('btnSave').addEventListener('click', APP.saveChar);
//     document.querySelector('header').addEventListener('click', APP.loadChar);
//     APP.loadShows();
//   },
//   saveChar(ev) {
//     ev.preventDefault();
//     let show = document.getElementById('show').value.trim();
//     let char = document.getElementById('char').value.trim();
//     if (show && char) {
//       //if both a show and character are provided
//       let key = APP.keybase + show.toLowerCase();
//       let storage = localStorage.getItem(key);
//       let chars = [];
//       if (storage) {
//         chars = JSON.parse(storage);
//       }
//       chars.push(char);
//       chars = Array.from(new Set(chars));
//       localStorage.setItem(key, JSON.stringify(chars));
//       document.getElementById('show').value = '';
//       document.getElementById('char').value = '';

//       APP.loadShows();
//     }
//   },
//   loadShows() {
//     //go to localstorage and retrieve all the keys that start with APP.keybase
//     let num = localStorage.length;
//     if (num) {
//       APP.keys = []; //reset the keys array
//       for (let i = 0; i < num; i++) {
//         let key = localStorage.key(i);
//         if (key.startsWith(APP.keybase)) {
//           APP.keys.push(key);
//         }
//       }
//       APP.keys.sort();
//       APP.buildNav();
//     }
//   },
//   buildNav() {
//     let nav = document.querySelector('header');
//     nav.innerHTML = '';
//     let foot = document.querySelector('footer');
//     foot.innerHTML = '';
//     let df = document.createDocumentFragment();
//     APP.keys.forEach((key) => {
//       //create a new anchor in the header for each show
//       let a = document.createElement('a');
//       a.className = 'show';
//       a.textContent = key.replace(APP.keybase, '');
//       df.append(a);
//     });
//     nav.append(df);
//   },
//   loadChar(ev) {
//     if (ev.target.tagName === 'A') {
//       //put the show name into the input field
//       let show = ev.target.textContent.toLowerCase();
//       document.getElementById('show').value = show;
//       //remove old active show class
//       //set current active class
//       let oldactive = document.querySelector('header a.active');
//       if (oldactive) {
//         oldactive.classList.remove('active');
//       }
//       ev.target.classList.add('active');
//       //get the characters for the show and build the footer
//       let key = APP.keybase + show;
//       let storage = localStorage.getItem(key);
//       if (storage) {
//         let chars = JSON.parse(storage);
//         APP.buildChars(chars);
//       }
//     }
//   },
//   buildChars(chars) {
//     let foot = document.querySelector('footer');
//     foot.innerHTML = '';
//     let df = document.createDocumentFragment();
//     chars.forEach((char) => {
//       //build the spans in the footer
//       let span = document.createElement('span');
//       span.className = 'char';
//       span.textContent = char;
//       df.append(span);
//     });
//     foot.append(df);
//   },
// };

// document.addEventListener('DOMContentLoaded', APP.init);

// ---------------------------form Events----------------------

// blur or change: can be used for validation when pattern needed
// input: better for validation than change in most cases

// document.addEventListener('DOMContentLoaded', () => {
//   //add event listeners to form elements
//   //name email phone pass lang btnSend
//   let name = document.getElementById('name');
//   let email = document.getElementById('email');
//   let phone = document.getElementById('phone');
//   let pass = document.getElementById('pass');
//   let lang = document.getElementById('lang');
//   let btn = document.getElementById('btnSend');
//   // form has attribute name and you can get this form by it's name
//   let form = document.sampleForm;

//   // KeyBoard Events
//   ['keypress','keydown','keyup'].forEach(function(event){
//     name.addEventListener(event,handleKey)
//   });
//   // Mouse Events
//   ['click','mousedown','mouseup'].forEach(function(event){
//     name.addEventListener(event,handleMouse)
//   });
//    // Focus Event
//   [name,email,phone,pass,lang].forEach(function(element){
//     element.addEventListener("focus",handleFocus)
//   });
//   // Blur Event
//   [name,email,phone,pass,lang].forEach(function(element){
//     element.addEventListener("blur",handleBlur)
//   });
//   // Change Event
//   [name,email,phone,pass,lang].forEach(function(element){
//     element.addEventListener("change",handleChange)
//   });
//   // Input Event
//   [name,email,phone,pass,lang].forEach(function(element){
//     element.addEventListener("input",handleInput)
//   });

//   //handle form submission
//   form.addEventListener('submit', handleSend);
//   btn.addEventListener('click', handleSend);
//   //even with enter key
//   document.addEventListener('keypress', (ev) => {
//     console.log({ ev });
//   });
// });

// function handleChange(ev) {
//   console.log(ev.type.toUpperCase(), ev.target.id, ev.target.value);
// }
// function handleInput(ev) {
//   console.log(ev.type.toUpperCase(), ev.target.id, ev.target.value);
// }

// function handleFocus(ev) {
//   console.log(ev.type.toUpperCase(), ev.target.id, ev.target.value);
// }
// function handleBlur(ev) {
//   console.log(ev.type.toUpperCase(), ev.target.id, ev.target.value);
// }

// function handleMouse(ev) {
//   console.log(ev.type.toUpperCase(), ev.target.id, ev.target.value);
// }
// function handleKey(ev) {
//   console.log(ev.type.toUpperCase(), ev.target.id, ev.target.value);
//   let code = ev.keyCode || ev.which;
//   if (code == 10 || code == 13) {
//     //return or enter key
//     handleSend(ev);
//   }
// }

// function handleSend(ev) {
//   ev.preventDefault();
//   //stop the form from submitting and reloading the page
//   console.log(ev.type.toUpperCase(), 'Submitting the Form');
// }

// ------------------------exp. of module and destructing------------------
/*
benifits of destructing in user.js is :
[1] we should not pass argument at same order of submit function inside user.js (inside module folder)
[2] we can add more parameters to submit function without effecting our code here
*/

// import { USER } from './Module/user.js';
// import { NetworkError } from './Module/error.js';

// const APP = {
//   init() {
//     //add event listeners to form elements
//     APP.addListeners();
//   },
//   addListeners() {
//     let form = document.sampleForm; // beacuse form element has attribute name = "sampleForm"
//     form.addEventListener('keypress', (ev) => {
//       let key = ev.keyCode || ev.which;
//       if (key === 10 || key === 13) { // Enter Key
//         APP.send(ev);
//       }
//     });
//     form.addEventListener('submit', APP.send);
//     let btn = document.getElementById('btnSend');
//     btn.addEventListener('click', APP.send);
//   },
//   send(ev) {
//     ev.preventDefault();
//     ev.stopPropagation();
//     let em = document.getElementById('email');
//     let password = document.getElementById('pass');
//     let language = document.getElementById('lang');
//     let endpoint = '/register';
//     // Property Value Shorthand and destructing
//     let obj = {
//       email : em,
//       password,
//       language,
//       endpoint
//     }
//     USER.submit(obj)
//       .then((response) => {
//         if (response.status >= 200 && response.status <= 299) {
//           return response.json();
//         } else {
//           throw new NetworkError(`${response.statusText} ${response.status}`);
//         }
//       })
//       .then((info) => {
//         console.log(info);
//       })
//       .catch((err) => {
//         switch (err.name) {
//           case 'ValidationError':
//             //deal with form errors
//             console.warn(`Form validation error with ${err.field}.`);
//             document.getElementById(err.field).classList.add('error');
//             break;
//           case 'NetworkError':
//             //unable to complete the fetch
//             console.warn('unable to complete the fetch');
//           default:
//             console.warn({ err });
//         }
//       });
//   },
// };
// document.addEventListener('DOMContentLoaded', APP.init);

// ------------------------------Form Validation Part 1 (CSS & HTML)-------------------------
/*
[1] Form elements' attributes in HTML : 
id
name
type
value
checked
selected
inputmode => ="numeric" for numbers / ="text" default / ="tel" / ="decimal" / ="url" / ="search" / ="email"
enterkeyhint
autocomplete
placeholder
required => when you submit the browser will warn you you should write input here
readonly => you can not add input or change placeholder
disabled => style of input field will change (dark color like it's off now) and you can't add anything to this input field
min => for numbers
max => for numbers
step => for numbers (add arrows up and down) and you can add step="2" to add 2 each click
minlength 
maxlength
pattern => here add regular expression (you have to add required attribute wihout it will accept if you didn't add input)
novalidate => only for form element (specifies that the form-data (input) should not be validated when submitted)
formnovalidate => you can add this attribute to submit button to submit or save without validation

[2] selectors in CSS :
input:focus
input:focus-within => matches an element if the element or any of its descendants are focused
input:read-only => if element has readonly attribute at HTML
input:read-write => default doesn't have read-only attribute
input:disabled => if element has disabled attribute at HTML
input:required => if element has required attribute at HTML
input:optional => default doesn't have required attribute
::placeholder => style for the text
:placeholder-shown => style for the filed itseld that has text placeholder
input:valid => when you enter valid input
input:invalid => when you enter invalid input 
:in-range => you have to add value attribute if you want to show style at the beginning
:out-of-range => you have to add value attribute if you want to show style at the beginning
*/

// ------------------------------Form Validation Part 2 (JS)-------------------------

/****
 * References
 * https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation
 * https://developer.mozilla.org/en-US/docs/Web/API/ValidityState
 * https://regexr.com/ - Tool by Grant Skinner for testing Regular Expressions
 *

-validity readonly prop - a ValidityState object

-ValidityState object props: (Boolean values)
badInput, customError, patternMismatch, rangeOverflow, rangeUnderflow
stepMismatch, tooLong, tooShort, typeMismatch, valid, valueMissing

-willValidate readonly prop - boolean willValidate is a property that says whether or not
input can be validated, not if it is valid or not. The only time that willValidate 
is false is if the input element is disabled or the like.

-checkValidity() checks element, returns boolean,
                fires the invalid event

-setCustomValidity(msg) if called with non-empty string it
                    will change the value of validity.valid
                    to false and validity.customError to true

-validationMessage - readonly prop from browser validation
                    or setCustomValidity( ) method

-reportValidity() checks AND reports result
                  this shows the browser tooltip with warning
                  can be called at any point to show message
                  fires the invalid event

*difference between checkValidity() and ValidityState.valid : 
So the main difference is that checkValidity() will also fire an "invalid" event.
If you just want to know whether the value is valid, use ValidityState.valid. 
But if you want to change the form state to invalid, use checkValidity().

*difference between checkValidity() and reportValidity() :
checkValidity() check and fires invalid event
reportValidity() check , fires invalid event and show message of setCustomValidity() on screen
*/

// const APP = {
//   init() {
//     APP.addListeners();
//   },
//   addListeners() {
//     let form = document.sampleForm;
//     let fullname = document.getElementById('fullname');
//     let email = document.getElementById('email');
//     let pass = document.getElementById('pass');
//     let cell = document.getElementById('cell');
//     let regcode = document.getElementById('regcode');
//     let pets = document.getElementById('pets');
//     //after changing the whole value
//     fullname.addEventListener('change', APP.testName);
//     email.addEventListener('change', APP.testEmail);
//     pass.addEventListener('change', APP.checkPasswordRequirements)

//     //while typing
//     regcode.addEventListener('input', APP.formatCode);
//     cell.addEventListener('input', APP.formatPhone);

//     //what to do if something went wrong during validation
//     fullname.addEventListener('invalid', APP.fail);
//     email.addEventListener('invalid', APP.fail);

//     //when the form gets submitted
//     form.addEventListener('submit', APP.validate);
//   },
//   validate(ev) {
//     ev.preventDefault();
//     let form = ev.target;

//     let email = document.getElementById('email');
//     console.log('willValidate', email.willValidate);
//     //run validation on the whole form when submitting...

//     // form controls have the following
//     // invalid event
//     console.log(email.validity);
//   },
//   testName(ev) {
//     let fullname = ev.target;
//     fullname.setCustomValidity(''); //clear old message
//     //built-in test for error based on type, pattern, and other attrs
//     let currently = fullname.checkValidity();
//   },
//   testEmail(ev) {
//     let email = ev.target;
//     console.log(email.validity); // ValidityState object
//     console.log(email.validity.valid); // true - false if not valid
//     console.log(email.checkValidity()) // true - false if not valid and trigger invalid event
//     console.log(email.willValidate) // always true except disabled input
//     email.setCustomValidity(''); //clear old message
//     //built-in test for error based on type, pattern, and other attrs
//     let currently = email.checkValidity();
//     console.log('currently', currently);
//     if (currently) {
//       let emReg = new RegExp('@gmail.com$', 'i');
//       if (emReg.test(email.value) === false) {
//         //not a gmail address
//         email.setCustomValidity('NOT a gmail address.');
//         console.log(email.validationMessage); // 'NOT a gmail address'
//         email.reportValidity(); //show the custom message(on screen), trigger invalid event
//         // email.checkValidity(); //will not show the custom message(on screen), trigger invalid event
//       }
//     }
//   },
//   formatCode(ev) {
//     let regcode = ev.target;
//     let val = regcode.value;
//     val = val.toUpperCase();
//     regcode.value = val; //converts anything typed to uppercase
//     //check for i and o used instead of 1 or 0...
//     regcode.setCustomValidity('');
//     if (/(I|O)/.test(val)) {
//       regcode.setCustomValidity(
//         'There are no letters i or o in the codes. Should this be a one or a zero?'
//       );
//       regcode.reportValidity(); //display the message and trigger invalid event
//     }
//   },
//   formatPhone(ev) {
//     //format and correct the phone number as user is typing?
//     //eg: +1 (555) 555-1212
//     //restrict to numbers, parentheses, hyphens, and + as typing?
//   },
//   checkPasswordRequirements(ev) {
//     //check password requirements as user types
//     // uppercase, lowercase, numeric, length >= 10
//     // Allowed: [! @ # $ % ^ & * ( ) . , ? ; : ~]
//     let response = {
//       upper: false,
//       lower: false,
//       num: false,
//       len: false,
//       matches: null,
//       valid: true,
//     };
//     let txt = ev.target.value.trim();
//     response.upper = /[A-Z]/.test(txt);
//     response.lower = /[a-z]/.test(txt);
//     response.num = /[0-9]/.test(txt);
//     response.len = ev.target.value.trim().length >= 10;
//     response.matches = txt.match(/[^A-Za-z0-9_!@#$%^&*().,?;:~]/);
//     if (response.matches && response.matches.length > 0) {
//       response.valid = false;
//     }
//     Object.entries(response).forEach(array => {
//       if(array[1] === false){
//         document.querySelector(`.${array[0]} .unchecked`).classList.add("show")
//         document.querySelector(`.${array[0]} .checked`).classList.remove("show")
//       }else if(array[1] === true){
//         document.querySelector(`.${array[0]} .checked`).classList.add("show")
//         document.querySelector(`.${array[0]} .unchecked`).classList.remove("show")
//       }
//     })
//     return response;
//   },
//   fail(ev) {
//     let field = ev.target;
//     // the invalid event fired
//     console.log('INVALID');
//     //standard display change for any element
//     switch (field.id) {
//       case 'email':
//         let span = field.parentElement.querySelector('.errMessage');
//         span.textContent = 'Must be a valid Gmail address.';
//         break;
//     }
//   },
// };
// document.addEventListener('DOMContentLoaded', APP.init);

// -------------------------------History API---------------------------------
// console.log(location.href) // link
// console.log(location.protocol) // http: protcol decide how info transfered between server and client
// console.log(location.host) // host name
// console.log(location.port) // :5500 or befault port used by http: :80
// console.log(location.hash) // #id will scroll page to element with this id
// console.log(location.pathname) // file location on server
// console.log(location.search) // QueryString ?name=Soliman&age=33
// location.replace(new url) // will replace current page to new one
// location.reload() // will reload current page
// window.location.reload() if you pass true, then the browser loads a fresh page, 
// but if false, then the cache version is loaded...

// history.go(3) // go forward 3 steps 
// history.go(-3) // go backward 3 steps 
// history.back() // go backword 1 step // like history.go(-1)
// history.forward() // go forward 1 step // like history.go(1)
// history.state


//  pushState, replaceState, history.state, popstate, hashchange 
// http:// sub.example.com :80 /path/filename.html 
// ?query=string&num=1
// #hashvalue - comes after the querystring
// 127.0.0.1 localhost


// document.addEventListener('DOMContentLoaded', ()=>{
//   // this object will be added to history.state and you can access it
//   //history.pushState({"abc":123}, "title", url);  //add to the array
//   //history.replaceState({"abc":123}, "title", url);   //replace current entry
//   //history.pushState(null, "Title", "pretend.html");

//   //add listeners to buttons and links that navigate
//   document.getElementById("link").addEventListener('click', c);

//   //add listeners for hashchange and popstate
//   // will trigger if we press back or forward arrow from browser or link inside webpage
//   window.addEventListener("hashchange", hc); // will be triggered if hash changed in url
//   window.addEventListener("popstate", ps); // will be triggered if the whole URL changed
  
// });

// function c(ev){
//   show('clicked');
//   ev.preventDefault(); // because of this will not trigger popstate 
//   let href = ev.currentTarget.href;
//   let pid = ev.currentTarget.getAttribute("data-person");
//   show(href);
//   // history.pushState({"pid":pid}, "title", href); // will add to history list in browser
//   history.replaceState({"pid":pid}, "title", href); // will no add anything to history list will only change the current 
//   loadPerson();
// }

// function loadPerson(){
//   show('LoadPerson');
//   show(history.state.pid);
// }

// function hc(ev){
//   // ev.newURL  ev.oldURL
//   show("hashchange");
//   //location.hash
// }
// function ps(ev){
//   //  ev.state
//   show("popstate");
// }

// function show(output){
//   let p = document.createElement('p');
//   p.textContent = output;
//   document.getElementById('output').appendChild(p);
//   setTimeout(_ => {
//       document.getElementById('output').removeChild(p);
//   }, 4000);
// }

// ------------------history pushState() and replaceState()----------
/*
history.replaceState(data, title, url)
history.pushState(data, title, url)

- data => you can pass data and then get it by history.state
- title => most of browsers ignore it so better to use document.title = 'new string';
- url => will change url only at browser but not got to this link you have to refresh 

* difference between pushState & replaceState :
  - replaceState only change url at browser
  - pushState change url at browser and add it to history array
*/
// document.addEventListener('DOMContentLoaded', () => {
//   document.getElementById('l1').addEventListener('click', goOne);
//   document.getElementById('l2').addEventListener('click', goTwo);
//   document.getElementById('l3').addEventListener('click', goThree);
//   console.log(history.state);
// });
// function goOne(ev) {
//   ev.stopPropagation();
//   history.replaceState({ id: 1 }, '', 'http://127.0.0.1:5500/hello');
//   document.title = 'new string';
// }
// function goTwo(ev) {
//   ev.preventDefault();
//   history.pushState({ id: 234 }, '', 'another.html');
// }
// function goThree(ev) {
//   ev.preventDefault();
//   let num = Math.floor(Math.random() * 10000);
//   history.pushState({ id: num }, '', `#${num}`);
// }

// -------------------popstate , hashchange & events---------------
/*
- popstate =>  is fired when the active history entry changes while the user navigates the session history
    history.pushState() or history.replaceState() won't trigger a popstate event. 
    The popstate event will be triggered by doing a browser action such as a 
    click on the back or forward button (or calling history.back() or history.forward() in JavaScript).

- hashchange => is fired when the fragment identifier of the URL has changed 
    (the part of the URL beginning with and following the # symbol).
    not fired by history.pushState() or history.replaceState()

- queryString => fresh reload of the page
*/
// const APP = {
//   init() {
//     //when the page loads
//     //check the state or hash value or both
//     APP.checkState(); //when the page loads
//     //add listeners for nav bar
//     //add listeners for popstate OR hashchange
//     APP.addListeners();

//     //APP.updateLayout('earth');
//   },
//   addListeners() {
//     document.querySelector('nav').addEventListener('click', APP.nav);

//     window.addEventListener('popstate', APP.checkState);
//     //when the user clicks back or forward
//     // window.addEventListener('hashchange', APP.tempHC);
//     // window.addEventListener('popstate', APP.tempPop);
//   },
//   // tempPop(ev) {
//   //   console.log('popstate');
//   //   console.log(history.state);
//   // },
//   // tempHC(ev) {
//   //   console.log('hashchange');
//   //   console.log(history.state);
//   // },
//   checkState() {
//     //do we want to drive our app by state or fragment-identifier(hash) or query?
//     //called when page loads AND after a popstate event
//     console.log(location);
//     console.log(history);
//     if (!location.hash) {
//       //default first load
//       history.replaceState(
//         { home: 'Earth', name: 'James Holden' },
//         '',
//         '#earth'
//       );
//       document.title = 'Earth';
//       APP.updateLayout('earth');
//     } else {
//       let hash = location.hash.replace('#', '');
//       APP.updateLayout(hash);
//       document.title = hash; //first letter to uppercase needed
//     }
//   },
//   nav(ev) {
//     ev.preventDefault();
//     let anchor = ev.target;
//     let home = anchor.getAttribute('data-home');
//     let name = anchor.getAttribute('data-name');
//     let state = {
//       home,
//       name,
//     };
//     let hash = `#${home.toLowerCase()}`;
//     history.pushState(state, '', hash);
//     document.title = home;
//     // if you don't want to add them to history array
//     // history.replaceState(state, '', hash);
//     APP.updateLayout(home.toLowerCase());
//   },
//   updateLayout(place) {
//     //accept a className and update the interface based on that
//     let main = document.querySelector('main');
//     main.className = place;
//   },
// };

// document.addEventListener('DOMContentLoaded', APP.init);

// --------------------------------------Storage Event-------------------
/*
localStorage stores key-value pairs that are origin (domain) specific so if you have 2 pages (html file) at 
same domain and change localStorage from 1st page and you need the 2nd page to know that
there is a changes in localStorage you can use Storage Event which is triggered once any changes
happend in localStorage

we are using here another html called other (look at html file)
 */
// const APP = {
//   list: null,
//   names: [],
//   key: null,
//   storage: null,
//   init(key) {
//     //script runs on every page that links to main.js
//     APP.key = key;
//     APP.storage = window.localStorage;
//     return APP;
//   },
//   getStorage() {
//     //load the key item from localStorage into our names array
//     let ref = APP.storage.getItem(APP.key);
//     if (!ref) {
//       APP.storage.setItem(APP.key, JSON.stringify([]));
//     }
//     APP.names = JSON.parse(ref);
//     return APP;
//   },
//   addName(nm, list) {
//     //add a name to the names array and then update localstorage
//     let obj = {
//       id: Date.now(),
//       name: nm,
//     };
//     APP.names.push(obj);
//     APP.saveNames();
//     if (list) {
//       APP.buildList(list);
//     }
//   },
//   removeName(nm) {
//     //remove a name from the names array and then update localstorage
//     APP.names = APP.names.filter((obj) => obj.name !== nm);
//     APP.saveNames();
//   },
//   updateName(oldName, newName) {
//     //update the names array and then localStorage
//     APP.names = APP.names.map((obj) => {
//       if (obj.name === oldName) {
//         return {
//           id: obj.id,
//           name: newName,
//         };
//       }
//       return obj;
//     });
//     APP.saveNames();
//   },
//   saveNames() {
//     //save the updated names array in localStorage
//     APP.storage.setItem(APP.key, JSON.stringify(APP.names));
//   },
//   clearNames() {
//     //remove all names from localStorage and empty the names array
//     APP.names = [];
//     APP.storage.clear();
//   },
//   buildList(element) {
//     //update the list element based on the names array
//     if (!APP.names) {
//       APP.names = [];
//     }
//     if(element){
//       element.innerHTML = APP.names
//       .map((obj) => {
//         return `<li data-key="${obj.id}">${obj.name}</li>`;
//       })
//       .join('\n');
//     }
//   },
// };

// document.addEventListener('DOMContentLoaded', () => {
//   //script specific to THIS page
//   let list = document.querySelector('#names');
//   //set up storage
//   let key = 'somewhat-shared-names-of-the-day';
//   APP.init(key).getStorage();
//   //populate data
//   APP.buildList(list);
//   //add listeners
//   document.AddForm?.addEventListener('submit', addName);
//   window.addEventListener('storage', (ev) => {
//     console.log({ ev });
//     let targetURL = new URL(ev.url);
//     if (location.pathname != targetURL.pathname) {
//       //came from another page
//       APP.getStorage().buildList(list);
//     }
//   });
// });

// function addName(ev) {
//   ev.preventDefault();
//   let nm = document.getElementById('name').value.trim();
//   let list = document.getElementById('names');
//   if (nm && list) {
//     APP.addName(nm, list);
//     document.getElementById('name').value = '';
//   }
// }

// --------------------------------IndexedDB---------------------------------
/*
* IndexedDB like localStorage is origin (domain) specific.

Using idb-keyval library version 5
This example is using Jake Archibald's idb-keyval library for indexedDB.

IndexedDB can be treated like Local / SessionStorage with key values pairs.

The big differences between localStorage and IndexedDB are:

[1] IndexedDB does not need to use the JSON.parse or JSON.stringify methods.
[2] IndexedDB can be used from Service Worker.(localStorage can not be used from Service Worker )
[3] IndexedDB can store BLOBs (binary data).

The idb-keyval library does not:
  ...allow for multiple stores/collections per database.
  ...have cursors.
  ...expose transactions.

  *****playlist for IndexedDB
  https://youtube.com/playlist?list=PLyuRouwmQCjmNyAysdqjNz5fIS5cYU4vi
*/
// import {
//   get,
//   set,
//   getMany,
//   setMany,
//   update,
//   del,
//   clear,
//   keys,
//   values,
//   entries,
//   createStore,
// } from 'https://cdn.jsdelivr.net/npm/idb-keyval@5.0.6/dist/esm/index.js'; // you can import from file online or download it and add it to your folder
// //methods return Promises
// //default DB name is 'keyval-store' (like a document DB)
// //default store name is 'keyval'    (like a Collection in the DB)

// (function init() {
//   //app is running now
//   //console.log(get);
//   let st = createStore('myDB', 'myStore');

//   set('user_id', Date.now())
//     .then(() => {
//       console.log('saved the user_id');
//       //overwrites old values for the same key
//     })
//     .catch(console.warn);

//   let myobj = {
//     id: 123,
//     name: 'steve',
//     email: 'steve@work.org',
//   };

//   //3rd parameter is which idb you want to set or get data from it (default or custom created idb)
//   set('info', myobj, st) 
//     .then(() => {
//       console.log('saved the info');
//     })
//     .catch(console.warn);

//   let pup = [{ type: 'Boxer' }, { type: 'Great Pyrenees' }];
//   const blob = new Blob([JSON.stringify(pup, null, 2)], {
//     type: 'application/json',
//   });

//   set('puppies', blob, st);

//   get('info',st)
//     .then((data) => {
//       console.log(data.id, data.email);
//     })
//     .catch(console.warn);

//   // 2nd parameter of update method is function which is accept the value of key ('user_id') as argument
//   update('user_id', (val) => {
//     return val - 10000;
//   })
//     .then((data) => {
//       console.log('update complete');
//     })
//     .catch(console.warn);

//   set('nope', 567);

//   del('nope')
//     .then(() => {
//       console.log('successfully deleted.');
//     })
//     .catch(console.warn);

//   keys().then((resp) => {
//     console.log('keys');
//     console.log(resp);
//   });

//   values().then((resp) => {
//     console.log('values');
//     console.log(resp);
//   });

//   entries().then((resp) => {
//     console.log(resp.length);
//     console.log(resp[0]);
//     //items from the store by index
//   });
// })();

// --------------------------catching error or rejected inside then---------------
/*
then can accept two function as parameters 
1st function is for resolve 
2nd function is for reject or error from last then or fetch istself

for exp. : 
2nd function in 1st then will catch error from fetch (failed to fetch)
2nd function in 2nd then will catch error from reading (response.json())

** fetch only goes into .catch handler when it fails to make the request for example 
when the network is not available or the domain does not exist.
But 404(not found) error will not go to .catch Handler
*/
//standard fetch
// let url = 'https://jsonplaceholder.typicode.com/todos/12';

// fetch(url)
//   .then((response) => response.json())
//   .then((data) => {
//     console.log(data);
//   })
//   .catch((err) => {
//     console.warn(err.message);
//   });

// promise
// let p = new Promise((resolve, reject) => {
//   //this function represents the async task
//   //resolve();
//   reject('bad');
// })
//   .then(
//     (response) => {
//       //resolved
//       console.log('resolve');
//     },
//     (reject) => {
//       console.log(reject);
//     }
//   )
//   .catch((err) => {
//     //handle any errors
//     console.log('error catch');
//   });


// fetch(url)
//   .then(
//     (resp) => {
//       if (!resp.ok) {
//         // this will no go directly to .catch because of interrupt in 2nd then 
//         // it will go to (err) in 2nd then and you can throw another Error there to go to catch
//         // but in this case we will not know if the Error from !resp.ok or from resp.json() failure
//         throw new Error(resp.statusText)
//       }
//       return resp.json();
//     },
//     (err) => {
//       //first interrupt
//       //the fetch failing
//       console.log('Network Error');
//       console.log(err)
//       //talk to the indexedDB to get cached data
//     }
//   )
//   .then(
//     (data) => {
//       console.log(data);
//     },
//     (err) => {
//       //failed to run resp.json()
//       // throw new Error()
//     }
//   )
//   .catch((err) => {
//     console.warn('NOT resp.ok');
//   });

// after checking response.ok you can throw an Error or return Promise.reject(response) to go to .catch handler
// fetch('https://jsonplaceholder.typicode.com/todos/434234234') 
//   .then((response) => {
//     if (response.ok) { 
//       return response.json();
//     }
//     return Promise.reject(response); 
//   })
//   .then((result) => { 
//     console.log(result); 
//   })
//   .catch((error) => {
//     console.log('Something went wrong.', error); 
//   });

// --------------------------------fetch sample for html or json or blob--------------
// let url = 'http://127.0.0.1:5500/videos/Eloquent.jpeg';

// let options = {
// method: 'GET',
// };

// fetch(url, options)
// .then(async (resp) => {
//   if (!resp.ok) throw resp.statusText;
//   console.log({ resp });
//   console.log(resp.headers.get('content-type'));
//   // headers methods : 
//   //append() delete() get()  has() values() keys() entries() set()
//   for (let h of resp.headers) {
//     console.log(h);
//   }
//   let type = resp.headers.get('content-type');
//   let obj = {
//     html: null,
//     json: null,
//     blob: null,
//   };
//   // we used async and await because .text() .json() asynchrnous
//   if (type.startsWith('text/html')) {
//     obj.html = await resp.text();
//   } else if (type.startsWith('application/json')) {
//     obj.json = await resp.json();
//   } else if (type.startsWith('image/')) {
//     obj.blob = await resp.blob();
//   }
//   return obj;
// })
// .then(({ html, json, blob }) => { // destructring
//   //handle the contents of the file
//   if (html) {
//     const doc = new DOMParser().parseFromString(html, 'text/html');
//     // console.log(doc.body);
//     let h1 = doc.querySelector('h1');
//     console.log(h1.textContent);
//   }
//   if (json) {
//     //js object
//     console.log(json)
//   }
//   if (blob) {
//     //image
//     let img = document.createElement('img');
//     let url = URL.createObjectURL(blob);
//     img.src = url;
//     document.body.append(img);
//   }
// })
// .catch((err) => {
//   console.warn(err.message);
// });

// ------------------------------image size without downloading---------------------
// let base = 'http://127.0.0.1:5500/videos/';
// let smallURL = `${base}237-400x300.jpeg`;
// let mediumURL = `${base}237-800x600.jpeg`;
// let largeURL = `${base}237-1600x1200.jpeg`;
// let options = {
//   // method : "GET" // if you want to download the file
//   method: 'HEAD', //only fetch the headers
// };
// let files = {};
// //one file
// fetch(mediumURL, options)
//   .then((resp) => {
//     if (!resp.ok) throw resp.statusText;
//     // to download the file
//     //return resp.blob();
//     //how big? to know only the size
//     console.log(resp.headers.get('content-length'));
//   })
//   .then((blob) => {
//     //convert blob to url
//   })
//   .catch((err) => {
//     console.warn(err.message);
//   });

// //list of files
// Promise.all([
//   fetch(smallURL, options),
//   fetch(mediumURL, options),
//   fetch(largeURL, options),
// ])
//   .then((responses) => { // will return array of responses responses = [resp1,resp2,resp3]
//     // console.log(new URL(respSM.url).pathname);
//     // console.log('small', respSM.headers.get('content-length'));
//     // console.log('med', respMD.headers.get('content-length'));
//     // console.log('lg', respLG.headers.get('content-length'));

//     for (let resp of responses) {
//       files[new URL(resp.url).pathname] = resp.headers.get(
//         'content-length'
//       );
//     }
//     // files[new URL(respSM.url).pathname] = respSM.headers.get(
//     //   'content-length'
//     // );
//     // files[new URL(respMD.url).pathname] = respMD.headers.get(
//     //   'content-length'
//     // );
//     // files[new URL(respLG.url).pathname] = respLG.headers.get(
//     //   'content-length'
//     // );
//     console.log(files );
//   })
//   .catch((err) => {
//     console.warn(err.message);
//   });

// -------------------------------custom protocol--------------------
// const APP = {
//   init() {
//     //Register the custom protocol handler `web+bob`
//     //Requires HTTPS in Chrome
//     //http works in Firefox for localhost
//     //forget about Safari...

//     // `web+bob:louise` would become
//     // `http://127.0.0.1:3003/character.html?char=louise`
//     navigator.registerProtocolHandler(
//       `web+bob`,
//       `http://127.0.0.1:5500/html/charachters.html?char=%s`, // %s means string after web+bob: 
//       `Title`
//     );

//     //check if we are on the character page and handle the link
//     APP.checkCustom();
//   },
//   checkCustom() {
//     //are we on the character page?
//     if (location.pathname.indexOf('/html/charachters.html') > -1) {
//       //Do we have a name in the queryString
//       let params = new URL(location).searchParams;
//       if (params.has('char')) {
//         let value = params.get('char').split("web+bob:")[1];
//         let h2 = document.querySelector('header h2');
//         if (h2) {
//           h2.textContent = value.toUpperCase();
//         }
//       }
//     }
//   },
// };
// document.addEventListener('DOMContentLoaded', APP.init);

// -------------------------image lazy loading------------------
/*
eager or lazy attributes from img element : 

- eager : 
The default behavior, eager tells the browser to load the image as soon as 
the <img> element is processed.

- lazy :
Tells the user agent to hold off on loading the image until the browser estimates 
that it will be needed imminently. For instance, if the user is scrolling through 
the document, a value of lazy will cause the image to only be loaded shortly before 
it will appear in the window's visual viewport.
*/

// document.addEventListener('DOMContentLoaded', () => {
//   //when the HTML has finished loading
//   console.log('got the HTML');
//   let images = document.querySelectorAll('p img');
//   images.forEach((img) => {
//     img.addEventListener('load', (ev) => {
//       console.log(`loaded ${ev.target.src}`);
//     });
//   });
// });

// window.addEventListener('load', () => {
//   //when the HTML, css, js, fonts,
//   //and images that are NOT lazy are finished loading
//   console.log('loaded the page and assets, NOT counting lazy images');
//   //start getting more images...
//   let main = document.querySelector('main');
//   let section = document.createElement('section');
//   let lorem = `Architecto, asperiores, ipsum modi unde iusto sunt reprehenderit
//           aliquam quo labore provident laboriosam obcaecati fugiat doloribus
//           vero quisquam odit cum perferendis sequi nostrum assumenda iste
//           aliquid sapiente expedita nobis! Nulla.`;
//   for (let i = 5; i <= 6; i++) {
//     let p = document.createElement('p');
//     p.append(createImage(i), lorem);
//     section.append(p);
//   }
//   main.append(section); //repaint
// });

// function createImage(num) {
//   let img = document.createElement('img');
//   img.loading = 'lazy';
//   img.addEventListener('load', (ev) => {
//     let url = new URL(ev.target.src);
//     console.log(`Finished loading ${url.pathname}`);
//   });
//   img.addEventListener('error', (ev) => {
//     let url = new URL(ev.target.src);
//     console.log(`Failed to load ${url.pathname}`);
//   });
//   img.src = `./videos/pexels-${num}.jpeg`;
//   return img;
// }

// ------------------------decode attribute & decode() method on images-------------
/*
- decode attribute :
* sync: the rendering will continue only after the image is ready; preferred for a "complete experience"
* async: continue the rendering and as soon as image decoding is complete, the browser will update the presentation; preferredfor performance
* auto: will let the browser do what it determines is best approach (not sure who it decides that)

- decode() method : 
One potential use case for decode(): when loading very large images 
, you can present a low resolution thumbnail image initially and then 
replace that image with the full-resolution image by instantiating a 
new HTMLImageElement, setting its source to the full-resolution image's 
URL, then using decode() to get a promise which is resolved once the 
full-resolution image is ready for use.
*/
// document.addEventListener('DOMContentLoaded', () => {
//   //when the HTML has finished loading
//   console.log('got the HTML');
  
//   // steves ways (there is an error here)
//   // let images = document.querySelectorAll('img[decode="async"]');
//   // images.forEach(function (img) {
//   //   img.addEventListener('load', (ev) => {
//   //     console.log(`Finished loading the LOW RES ${ev.target.src}`);
//   //     ev.target.setAttribute('data-loaded', 'low');
//   //     //low res versions are:
//   //     //<img loading="lazy" decode="async"/>
//   //     //go decode the real one asynchronously
//   //     //wait for decode() promise to be resolved
//   //     //listen for the load event for the real one
//   //     let i = new Image(); // like document.createElement('img')
//   //     i.src = img.src.replace('-low-', '-');
//   //     i.decode().then(() => {       
//   //       let url = new URL(i.src);
//   //       console.log(`ASYNC: Finished decoding REAL ${url.pathname}`);
//   //       img.replaceWith(i); // method to replace node element with another one
//   //       i.setAttribute('data-loaded', 'high-decoded');
//   //     });
//   //   });
//   // });

//   // my way to solve Error 
//   let images = document.querySelectorAll('img[decode="async"]');
//   let notBusy = true;
//   for(let img of images){
//     img.addEventListener('load', function(){
//       let intervalID = setInterval(function (img) {
//         if(notBusy){
//           notBusy = false
//           let i = new Image(); // like document.createElement('img')
//           i.src = img.src.replace('-low-', '-');
//           i.decode().then(() => {       
//             let url = new URL(i.src);
//             console.log(`ASYNC: Finished decoding REAL ${url.pathname}`);
//             img.replaceWith(i); // method to replace node element with another one
//             i.setAttribute('data-loaded', 'high-decoded');
//             clearInterval(intervalID)
//             notBusy = true;
//           });
//         }
//       },100,img)
//     });
//   }

// });

// window.addEventListener('load', () => {
//   //when the HTML, css, js, fonts,
//   //and images that are NOT lazy are finished loading
//   console.log('loaded the page and assets, NOT counting lazy images');
// });

// -----how to pause a loop
// const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms))

// const loop = async () => {
//   for (const a of [1, 2, 3]) {
//     console.log(a)
//     await wait(2000)
//   }
// }
// loop()

// ------------------------------add variable to CSS from JS--------------
// let root = document.documentElement
// root.style.setProperty("--mainColor", "red")

// ------------------link datalist element to input element using list attribute---------------

// document.addEventListener("DOMContentLoaded", () => {
//   let country = document.getElementById("country");
//   country.addEventListener("input", countrySelected);
// });

// function countrySelected(ev) {
//   console.log(ev.target.value);
//   let countryName = ev.target.value.toLowerCase();
//   if (!document.getElementById(countryName)) return;

//   let state = document.getElementById("state");
//   state.setAttribute("list", countryName);
//   state.focus();
//   state.value = "";
// }

// ------------------------import method from JS-------------------
/*
- instead of import { default as rand, colour } from './Module/utils.js';
  you can use import method in JS and will return a promise

- with import method you don't need to add type="module" attribute

*/

// const allowImport = true;

// document.addEventListener('DOMContentLoaded', () => {
//   let main = document.querySelector('main');

//   if (allowImport) {
//     import('./Module/utils.js')
//       .then(({ default: r, colour: clr }) => {
//         let pn = document.createElement('p');
//         let today = new Date().getDate();
//         pn.textContent = `Today's number is ${r(today)}.`;
//         main.append(pn);

//         let pc = document.createElement('p');
//         let c = clr();
//         pc.style.color = c;
//         pc.textContent = `Today's colour is ${c}`;
//         main.append(pc);
//       })
//       .catch((err) => {
//         console.error('Failed to load the utils functions');
//       });
//   }
// });

// --------------------------convert callback hell to promise-----------------

// const delayCallback = (func, seconds = 2) => {
//   let timmy = setTimeout(func, seconds * 1000);
//   return timmy;
// };

// const delayPromise = (seconds = 2) => {
//   return new Promise((resolve, reject) => {
//     setTimeout(resolve, seconds * 1000);
//   });
// };
// document.addEventListener('DOMContentLoaded', () => {
//   //HTML has loaded, add click listener
//   document.getElementById('btnDelay').addEventListener('click', wait);
// });

// const changeBtnColor = () => {
//   let color = `#${Math.random().toString(16).substr(2, 6)}`;
//   let element = document.getElementById('btnDelay');
//   element.style.backgroundColor = color;
//   console.log(`Button is now ${color}`);
//   return Math.floor(Math.random() * 4) + 1;
// };

// const wait = (ev) => {
//   let delay1 = 3;
  
//   //callback version

//   // delayCallback(() => {
//   //   let delay2 = changeBtnColor();
//   //   delayCallback(() => {
//   //     let delay3 = changeBtnColor();
//   //     delayCallback(() => {
//   //       let delay4 = changeBtnColor();
//   //     }, delay3);
//   //   }, delay2);
//   // }, delay1);

//   //change the button colour after delay
//   delayPromise(delay1)
//     .then(changeBtnColor) //return value gets passed to the next then()
//     .then(delayPromise)
//     .then(changeBtnColor)
//     .then(delayPromise)
//     .then(changeBtnColor)
//     .catch((err) => console.error);
// };

// -------------------------------------CSS clamp---------------
/*
[1] if browser support -webkit-line-clamp : 
  add those 4 lines to CSS File
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;

[2] if not supported do our JS simulated support :
watch this video (https://youtu.be/GxpUp0FecEw) to understand


*/
// const LINES = 2;
// let lineHeight = 1;

// document.addEventListener("DOMContentLoaded", () => {
//   //HTML loaded
//   // to check if browser support -webkit-line-clamp 
//   if (
//     CSS.supports("-webkit-line-clamp", LINES) &&
//     window.getComputedStyle(document.querySelector("main p"))[
//       "-webkit-line-clamp"
//     ] !== "none"
//   ) {
//     // -webkit-line-clamp is supported...
//     // and there is a value set for -webkit-line-clamp in the CSS
//     console.log("CSS is doing the work for us.");
//     console.log(
//       window.getComputedStyle(document.querySelector("main p"))[
//         "-webkit-line-clamp"
//       ],
//       "lines for clamping"
//     );
//   } else {
//     // No -webkit-line-clamp support...
//     //let's do our JS simulated support

//     //one time when we first load, get the p line-height, save the original text, do clamping
//     document.querySelectorAll("main > p").forEach((p) => {
//       lineHeight = parseFloat(window.getComputedStyle(p).lineHeight);
//       p.setAttribute("data-text", p.textContent); //save the original text
//       clampIt(p);
//     });

//     //when the page gets resized repeat the clamping
//     //could use resizeObservers on the paragraphs instead
//     //this would be a good place to use debouncing to reduce the number of calls
//     window.addEventListener("resize", () => {
//       document.querySelectorAll("main > p").forEach((p) => {
//         clampIt(p);
//       });
//     });
//   }
// });

// function clampIt(p) {
//   let originalText = p.getAttribute("data-text");
//   let totalChars = originalText.length; //number of characters in the original text

//   let bounds = p.getBoundingClientRect();
//   console.log({ bounds }); //dimensions of the current paragraph - width and height

//   let lineCount = bounds.height / lineHeight;
//   console.log({ lineCount }); //number of lines that could be displayed

//   let totalAvailLength = lineCount * bounds.width; //width if that many lines were on one.
//   let avgCharWidth = Math.round(totalAvailLength / p.textContent.length);
//   console.log({ avgCharWidth }); //total width divided by current number of characters
//   // to estimate an average width per character

//   let charsPerLine = bounds.width / avgCharWidth;
//   console.log({ charsPerLine }); //how many characters can be shown per line, estimated.

//   let targetChars = Math.ceil(charsPerLine * LINES);
//   console.log({ targetChars }); //our estimate of how many characters to show in the paragraph

//   if (targetChars < totalChars) {
//     let nextSpace = originalText.indexOf(" ", targetChars - 5);
//     if (nextSpace > -1) {
//       //found a space near the target length
//       //display the substring of the right number of characters
//       p.textContent = originalText.substr(0, nextSpace).concat("\u2026"); //add ellipsis
//     } else {
//       //no space after this point in the text
//       //display the substring of the right number of characters
//       p.textContent = originalText.substr(0, targetChars - 1).concat("\u2026"); //add ellipsis
//     }
//   } else {
//     //not enough chars to fill the lines, so show it all
//     p.textContent = originalText;
//   }
// }

/* how clampIt function works
1. Find the average character width for the Element
  a. take the height of the element divided by the line-height to get the total number of current lines
  b. multiply the lines by the width of the element to get the total length
  c. divide total length by number of chars in current text

2. Find the number of characters can be held in requested number of lines
  a. requested lines multiplied by element width
  b. divide that length by the average character width

3. Truncate the original text under different conditions
  a. enough room to hold all the original text - show all of it
  b. not enough room - find the next <space> and truncate then add an ellipsis
  c. not enough room but no <space> truncate there and add an ellipsis
  
*/

// -------------------------------drag and drop-----------------------
// let imgElement = new Image();
// let dragElement = document.createElement('span');
// let myData = {
//   id: 123,
//   tag: 'p',
//   text: 'Just a paragraph',
//   timestamp: 0,
//   url: '',
// };

// document.addEventListener('DOMContentLoaded', () => {
  
//   //required event listeners
//   document.body.addEventListener('dragstart', handleDragStart); //for draggable
//   document.body.addEventListener('drop', handleDrop); //for dropzone
//   document.body.addEventListener('dragover', handleOver); //for dropzone
  
//   //optional but useful events
//   document.body.addEventListener('mousedown', handleCursorGrab);
//   document.body.addEventListener('dragenter', handleEnter);
//   document.body.addEventListener('dragleave', handleLeave);
  
//   //set up draggable things (non-ios)
//   imgElement.src = './videos/pexels-3.jpeg';
//   document.querySelector('footer>p').appendChild(imgElement);
//   dragElement.textContent = 'Wheeeee';
//   dragElement.classList.add('wheeeee');
//   document.querySelector('footer>p').appendChild(dragElement);
// });

// function handleDragStart(ev) {
//   //user started to drag a draggable from the webpage
//   let obj = ev.target;
//   if (!obj.closest('.draggable')) return;
//   if(obj.classList.contains('draggable')){
//     obj = obj.firstElementChild;
//   }

//   // When a drag occurs, a translucent image is generated from the drag target 
//   // (the element the dragstart event is fired at), and follows the mouse pointer during 
//   // the drag. This image is created automatically, so you do not need to create it yourself. 
//   // However, if a custom image is desired, the DataTransfer.setDragImage() method can be used
//   // console.log('DRAGSTART');
//   // ev.dataTransfer.setDragImage(dragElement, 50, 50); // (image, xOffset , yOffset)
//   // ev.dataTransfer.setDragImage(imgElement, 50, 50);
//   // ev.dataTransfer.setData('text/plain', ' No MORE DATA ');
  
//   myData.tag = obj.tagName;
//   myData.text = obj.textContent?obj.textContent:obj.alt?obj.alt:'';
//   myData.url = obj.href?obj.href: obj.src? obj.src:'';
//   myData.timestamp = Date.now();
//   let data = JSON.stringify(myData);
//   ev.dataTransfer.setData('application/json', data); // (format , data) => type and data to be added to drag object
//   console.log(ev.dataTransfer.getData("application/json"))
//   obj.setAttribute('data-ts', myData.timestamp);
  
//   let dataList = ev.dataTransfer.items;
//   for(let i=0; i<ev.dataTransfer.items.length; i++){
//     let item = ev.dataTransfer.items[i];
//     console.log(i, item.kind, item.type);
//   }
  
// }
// function handleDrop(ev) {
//   let dropzone = ev.target;
//   if (!dropzone.classList.contains('dropzone')) return;

//   ev.preventDefault();
//   // console.log('DROP', ev.dataTransfer);
//   // let data = ev.dataTransfer.getData('text/plain');
//   let data = JSON.parse(ev.dataTransfer.getData('application/json'));
//   let draggable = document.querySelector(`[data-ts="${data.timestamp}"]`);
//   let clone = draggable.cloneNode(true);
//   dropzone.append(clone);
//   draggable.remove();
  
//   // dropzone.textContent += data;
//   dropzone.classList.remove('over');
  
//   let len = ev.dataTransfer.items.length;
//   for(let i = 0; i < len; i++){
//     let item = ev.dataTransfer.items[i];
//     console.log(item)
//     if(item.kind === 'string' && item.type.match('^text/html')){
//       //i got an html element
//     }
//     if(item.kind==='string' && item.type.match('^application/json')){
//       //same as before... except the method getAsString (Asynchronous function)
//       item.getAsString((json)=>{ 
//         let data = JSON.parse(json);
//         console.log('timestamp was', data.timestamp);
//       })
//     }
//   }
  
  
// }
// function handleOver(ev) {
//   //fires continually
//   let dropzone = ev.target;
//   if (!dropzone.classList.contains('dropzone')) return;
//   ev.preventDefault();
//   // dropzone.classList.add('over'); //can do this in handleEnter
//   // console.log('dragover dropzone');
// }

// //optional but useful visual stuff...
// function handleCursorGrab(ev) {
//   let obj = ev.target;
//   if (!obj.closest('.draggable')) return;
//   obj.style.cursor = 'grabbing'; //close the hand
// }
// function handleEnter(ev) {
//   //fires once
//   let dropzone = ev.target;
//   if (!dropzone.classList.contains('dropzone')) return;
//   ev.preventDefault();
//   dropzone.classList.add('over');
//   // console.log('dragenter dropzone')
// }
// function handleLeave(ev) {
//   let dropzone = ev.target;
//   if (!dropzone.classList.contains('dropzone')) return;
//   ev.preventDefault();
//   dropzone.classList.remove('over');
//   // console.log('dragleave dropzone');
// }

// ---------------------------location iq API-----------------------------
/*
Documentation : 
https://locationiq.com/docs-html/index.html?javascript#static-maps
*/

// const APP = {
//   TOKEN: 'pk.6b6005e44e04badf378e7b27d15d962e',
//   SEARCHURL: `https://us1.locationiq.com/v1/search.php?format=json&`,
//   REVERSEURL: `https://us1.locationiq.com/v1/reverse.php?format=json&`,
//   MAPURL: `https://maps.locationiq.com/v3/staticmap?`,
//   data: null,
//   init: () => {
//     document
//       .getElementById('btnSearch')
//       .addEventListener('click', APP.doSearch);
//     document
//       .getElementById('btnReverse')
//       .addEventListener('click', APP.doReverse);
//     document.getElementById('btnMap').addEventListener('click', APP.getMap);
//   },
//   doSearch: (ev) => {
//     ev.preventDefault();
//     //use forward geocoding
//     let q = document.getElementById('keyword').value.trim();
//     if (!q) return false;
//     let url = `${APP.SEARCHURL}key=${APP.TOKEN}&q=${q}`;
//     //call the API and do a forward geocoding search
//     //save the results in a global location
//     fetch(url)
//       .then((resp) => {
//         if (!resp.ok) throw new Error(resp.statusText);
//         return resp.json();
//       })
//       .then((data) => {
//         APP.data = data[0];
//         APP.showSearchResults();
//       })
//       .catch((err) => {
//         console.error(err);
//       });
//   },
//   showSearchResults: () => {
//     //display the results of the search
//     console.log(APP.data);
//     let section = document.querySelector('.results');
//     let pre = section.querySelector('pre');
//     if (!pre) {
//       pre = document.createElement('pre');
//       section.append(pre);
//     }
//     //just dump the data response into the <pre> element
//     //just the first result from the array
//     pre.textContent = JSON.stringify(APP.data, null, 2);
//   },
//   doReverse: (ev) => {
//     ev.preventDefault();
//     let q = document.getElementById('keyword').value.trim();
//     //validation
//     if (!q) return false; //exit if empty
//     if (q.indexOf(',') < 0) return false; //exit if no comma
//     let parts = q.split(','); //make array with 2 parts
//     if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) return false;
//     //exit if not number lat or lon, not two values
//     //build url
//     let url = `${APP.REVERSEURL}key=${APP.TOKEN}&lat=${parts[0]}&lon=${parts[1]}`;
//     //do a reverse geocoding call
//     //save the results in a global location
//     fetch(url)
//       .then((resp) => {
//         if (!resp.ok) throw new Error(resp.statusText);
//         return resp.json();
//       })
//       .then((data) => {
//         console.log(data);
//         APP.data = data; //no [0]
//         APP.showSearchResults();
//       })
//       .catch((err) => {
//         console.error(err);
//       });
//   },
//   getMap: (ev) => {
//     ev.preventDefault();
//     if (!APP.data) return false; //make sure there is data
//     let lon = APP.data.lon; //get the longitude from the last retrieved
//     let lat = APP.data.lat; //get the longitude from the last retrieved
//     //build the URL with center, zoom, size, format
//     let url = `${APP.MAPURL}key=${APP.TOKEN}&center=${lat},${lon}&zoom=9&size=400x600&format=png`;
//     //display the static map
//     APP.showMap(url);
//   },
//   showMap: (url) => {
//     let section = document.querySelector('.map');
//     let img = section.querySelector('img');
//     if (!img) {
//       img = document.createElement('img');
//       section.append(img);
//     }
//     img.alt = APP.data.display_name; // get the display_name from the data
//     // put some ref into an attribute
//     img.setAttribute('data-place-id', APP.data.place_id);
//     // set the src with the url param
//     img.src = url;
//   },
// };

// document.addEventListener('DOMContentLoaded', APP.init);

// -------------------controlling CSS (element's styles and css variables) from Js-------------
// window.addEventListener("load", function(){
//   let body = document.body
//   let root = document.querySelector(":root")
//   // CSSStyleDeclaration object (key : number , value : style name)
//   console.log(getComputedStyle(body)) 
//   // CSSStyleDeclaration object (key : style name , value : value) but only values added by js file not css
//   console.log(body.style) 
//   // if you need to get value added by css file use get
//   console.log(getComputedStyle(body).getPropertyValue("color")) // green in rgb
//   // to be able to use body.style.color you should add it by js file
//   console.log(body.style.color) // empty not green (in CSS file)
//   body.style.color = "red"
//   console.log(body.style.color) // red
//   // you can setProperty and access it by getPropertyValue or body.style.color
//   body.style.setProperty("color","blue")
//   console.log(getComputedStyle(body).getPropertyValue("color")) //blue in rgb
//   console.log(body.style.color) // blue
//   // you can access also CSS Variable from JS
//   console.log(getComputedStyle(root).getPropertyValue("--mainColor")) // blue
//   root.style.setProperty("--mainColor","purple")
//   console.log(getComputedStyle(root).getPropertyValue("--mainColor")) // purple
// })

// --------------------------import CSS file or JSON file-------------------
/*
This is my app.js module, which means
it can import other JS modules.
...and now, CSS and JSON too
Chrome 91 added support for JSON Modules
and Chrome 93 added CSS imports.
Edge and Opera have these too.
Support in Firefox is under development.

**instead of using fetch
*/

//-----[1]JSON
//static import
// import data from './json/slideshow.json' assert { type: 'json' };
// console.log(data.items);

//dynamic import ( using import method)
// import('./json/slideshow.json', { assert: { type: 'json' } })
//   .then((mod) => {
//     //mod is my module
//     console.log(mod.default.items);
//   })

//-------[2]CSS
// import sheet from './css/main.css' assert { type: 'css' };
// document.adoptedStyleSheets = [sheet];

// ----------------------------import maps---------------
/*
in node you can write from 'luxon' and node will search for luxon automatically
but in browser you have to write full path so if you want to write only from 'luxon'
you shoud add script tage in HTML file  :
<script type="importmap">
  {
      "imports": {
      "luxon": "./node_modules/luxon/src/luxon.js"
      }
  }
</script>

npm init -y => to install package.json with defaults
npm i luxon => to install luxon liberary

npm documentation (https://www.javascripttutorial.net/nodejs-tutorial/what-is-npm/)
luxon video (https://youtu.be/vAuUzEwTbck)
*/

// import * as luxon from 'luxon'; 

// document.addEventListener('DOMContentLoaded', () => {
//   console.log('page is ready');
//   let output = document.querySelector('.output');
//   let DateTime = luxon.DateTime;
//   let today = DateTime.local();
//   let f = { month: 'long', day: '2-digit' };
//   let newDt = today.set({ month: 12 });
//   output.textContent = newDt.setLocale('fr-CA').toLocaleString(f);
// });


// --------------------------file object and fileList (and using fetch)---------------------------
/*
in HTML file you can write what are the accepted files types inside accept attribute: 
  text/html,.html,text/xml,.xml
  text/css,.css
  application/json,.json,text/json
  image/*,.png,.jpg,.gif,.webp,image/jpeg,image/gif,image/webp,image/png  


*/

// document.addEventListener('DOMContentLoaded', () => {
//   document.getElementById('inputFile').addEventListener('change', filesPicked);

//   document.getElementById('btnToggle').addEventListener('click', toggleInput);
//   document.getElementById('btnPick').addEventListener('click', askForFiles);
//   document.getElementById('btnInfo').addEventListener('click', showFileInfo);
// });

// function filesPicked(ev) {
//   //any time one or more files are picked in the file picker dialog
//   let input = ev.target;
//   let files = input.files;
//   console.log({ files });
//   if (files.length > 0) {
//     showFileInfo(ev);
//     //upload a file or file(s) to a web server/api
//     let url = 'https://jsonplaceholder.typicode.com/users';
//     // let h = new Headers();
//     // h.append('content-type', files[0].type);
//     // h.append('content-length', files[0].size);

//     // if you want to select mutliple files you can not add header but you can use FormData and 
//     // the browser will create "Content-disposition": "Multipart/Form-Data" by default and 
//     // create a boundary also (a seperating text between selected files )
//     //  "Content-disposition": "Multipart/Form-Data;boundary=--asdlkasj(random string created by browser)"
//     let fd = new FormData();
//     fd.append('name', 'Steve');
//     for (let i = 0, len = files.length; i < len; i++) {
//      // FormData append accept 3 parameters (name , value, file name )
//       fd.append(`files-${i}`, files[i], files[i].name);
//     }
//     let request = new Request(url, {
//       body: fd,
//       // headers: h,
//       mode: 'no-cors',
//       method: 'POST',
//     });
//     fetch(request)
//       .then((response) => {
//         console.log(response.status, response.statusText);
//       })
//       .catch(console.warn);
//   }
// }

// function toggleInput(ev) {
//   //hide or show the <input type="file">
//   ev.preventDefault();
//   let control = document.getElementById('inputFile').parentElement;
//   //we want to apply this class to the parent
//   control.classList.toggle('hidden');
// }

// function askForFiles(ev) {
//   //open the file picker dialog
//   ev.preventDefault();
//   let control = document.getElementById('inputFile');
//   control.click();
// }

// function showFileInfo(ev) {
//   if (ev.type == 'click') ev.preventDefault();
//   //loop through all the files in the filelist
//   //and display the name, size, type, and lastModified date
//   let files = document.getElementById('inputFile').files;
//   let len = files.length;
//   for (let i = 0; i < len; i++) {
//     console.group();
//     console.log(files[i].name);
//     console.log(files[i].size);
//     console.log(files[i].type);
//     console.log(files[i].lastModified);
//     console.groupEnd();
//   }
// }

// ------------------Files, Blobs, ArrayBuffers, TypedArrays, DataViews-------------

/*
new Blob([ data ], {type:"text/plain", endings: "transparent"||"native"}) // ending => for carriage return or new line characters  

new File([ data ], filename, {type:"text/plain", lastModified: Date.now()})

(data - Blob, ArrayBuffer, TypedArray, DataView, String (utf-8 string), a mixture)
File is a sub-class of Blob. Can often be used interchangeably. 
Once you have a Blob/File then you can use it:
- upload via fetch as a file or stream
- save it in the cache
- add a link in a webpage to the file
- display it as an image (if image)
- read the text contents (json, txt, html...) and:
  - display on page
  - parse the html, xml, json, etc
  - save in localStorage or cookie

ArrayBuffer - raw data as a fixed-length string of bytes. It is NOT an Array.

DataView - an interpretation of some raw bytes expressed as 8-bit, 16-bit, 32-bit,
  or 64-bit integers. Used to add or edit data in an ArrayBuffer. Like a wrapper 
  for ArrayBuffers if you need to edit them. It is a View of the Data from the ArrayBuffer

TypedArray - It is an Array-like view of raw bytes stored as 
  8-bit, 16-bit, 32-bit or 64-bit  integers, clamped integers, 
  signed and unsigned integers, or floats. 

ArrayBuffer can be passed as parameter to DataView to edit it (for get and set methods)
ArrayBuffer can be passed as parameter to TypedArray because TypedArray have most of array methods


1. The ArrayBuffer, a data structure designed to hold a given amount of binary data.
2. TypedArray, a view into an ArrayBuffer where every item has the same size and type.
3. The DataView, another view into an ArrayBuffer, but one which allows items of different size and type in the ArrayBuffer.
*/

// document.addEventListener('DOMContentLoaded', () => {
//   document.getElementById('btnGo').addEventListener('click', createBlob);
// });

// function createBlob(ev) {
//   ev.preventDefault();
//   let ab = new ArrayBuffer(2); //2 bytes / 1 byte = 8 bits 0 - 255
//   let dataview = new DataView(ab);
//   dataview.setInt8(0, 104); //h in ASCII
//   dataview.setInt8(1, 105); //i in ASCII
//   console.log(new Uint8Array(ab).toString()); // typed array

//   let b = new Blob([ab]);
//   console.log(b);

//   let f = new File([ab], 'myinfo.txt', { type: 'text/plain'});
//   console.log(f);

//   let url = URL.createObjectURL(f);
//   let a = document.createElement('a');
//   a.href = url;
//   a.download = f.name;
//   a.textContent = `Download ${f.name}`;
//   document.querySelector('main').append(a);
// }

// -----------------------------custom Response Object---------------

/*
Why would you want to create a Response Object?

* Save a generated file in the Cache
* Put a user's local file into the Cache
* Return a generated file from a Service Worker
* Make copies of files
*/

/*
new Response(body, {
  status: 200,
  statusText: 'All good',
  headers: {
    'x-my-header': 'some value',
  }
});

body - Blob, File, ArrayBuffer, TypedArray, DataView,
  FormData, String, ReadableStream, URLSearchParams
*/

// document.addEventListener('DOMContentLoaded', () => {
//   //when the page is ready...
//   createJSONResponse();

//   createImageResponse();
// });

// async function createJSONResponse() {
//   //create an object, convert to JSON and create a file in a Response
//   const myobj = {
//     id: 123,
//     name: 'Sheldon',
//   };
//   let json = JSON.stringify(myobj);
//   let file = new File([json], 'mydata.json', { type: 'application/json' });
//   console.log(file);
//   const response = new Response(file, {
//     status: 200,
//     statusText: 'All good',
//     headers: {
//       'x-my-header': 'some value',
//       'content-type': file.type,
//       'content-length': file.size,
//     },
//   });
//   console.log(response);
//   const copy = response.clone(); // to take a copy of response object and store it at variable
//   console.log(copy);
//   let contents = await copy.json(); // async function
//   console.log({ contents });
// }

// function createImageResponse() {
//   //load a local image and put it in a Response
//   let input = document.createElement('input');
//   input.type = 'file';
//   input.accept = 'image/*';
//   document.querySelector(".imgInput").appendChild(input)
//   input.addEventListener('change', async (ev) => {
//     let input = ev.target;
//     let file = input.files[0];
//     let response = new Response(file, {
//       status: 200,
//       statusText: 'ok',
//       headers: {
//         'content-type': file.type,
//         'content-length': file.size,
//       },
//     });
//     let copy = response.clone();
//     console.log(copy);
//     //get image from response
//     let blob = await copy.blob(); // async function
//     //add to <a href>
//     let url = URL.createObjectURL(blob);
//     console.log(url);
//   });
// }

// ----------------------------------File Handling for web App--------------

/*
to understand Cache there is a video in service workers list :
https://youtu.be/Gu0t2EW2kfU
*/
// const APP = {
//   file: null,
//   response: null,
//   cacheName: 'samplecache-v1',
//   cache: null,
//   canvas: null,
//   ctx: null,
//   init: () => {
//     APP.addListeners();
//     APP.drawCircleOnCanvas();
//   },
//   addListeners: () => {
//     //input type="file" select image or json file
//     document
//       .getElementById('inputImage')
//       .addEventListener('change', APP.pickLocalFile);
//     document
//       .getElementById('inputJSON')
//       .addEventListener('change', APP.pickLocalFile);
//     //add the current file to a Response object
//     document
//       .getElementById('btnResponse')
//       .addEventListener('click', APP.createResponseObject);
//     //save the response in the Cache
//     document
//       .getElementById('btnCache')
//       .addEventListener('click', APP.saveInCache);
//     //display current local file on the webpage
//     document
//       .getElementById('btnDisplayLocal')
//       .addEventListener('click', APP.displayLocal);
//     //display the last item from the cache on the page
//     document
//       .getElementById('btnDisplayCache')
//       .addEventListener('click', APP.displayCache);
//     //extract the image from the canvas and display on the page
//     document
//       .getElementById('btnDisplayCanvas')
//       .addEventListener('click', APP.saveAndDisplayCanvas);
//     //generate a JSON(text) file and prompt the user to download and save the file
//     document
//       .getElementById('btnGenAndSave')
//       .addEventListener('click', APP.genAndSave);
//   },
//   ///////////////////////////////////////////////////////
//   drawCircleOnCanvas: () => {
//     //draw a blue circle and pink background on the canvas
//     APP.canvas = document.getElementById('canvas');
//     APP.ctx = canvas.getContext('2d');

//     APP.ctx.beginPath();
//     APP.ctx.fillStyle = 'lightpink';
//     APP.ctx.rect(0, 0, 200, 200);
//     APP.ctx.fill();

//     APP.ctx.beginPath();
//     APP.ctx.fillStyle = 'cornflowerblue';
//     APP.ctx.ellipse(100, 100, 50, 50, 0, 0, Math.PI * 2, false);
//     APP.ctx.fill();
//   },
//   ///////////////////////////////////////////////////////
//   pickLocalFile: (ev) => {
//     //take a file from the local file system clicked on the pickImage or pickJSON button
//     console.log('pick local file');
//     let input = ev.target;
//     let files = input.files; //array of selected file(s)
//     console.log(files.length);
//     APP.file = files[0];
//     console.log(APP.file);
//     document.querySelector('span.title').textContent = files[0].name;
//     console.log(
//       'A File object can be added as Request body for a fetch call or Response body for Cache or Service Worker.'
//     );
//   },
//   ///////////////////////////////////////////////////////
//   createResponseObject: (ev) => {
//     if (APP.file) {
//       //take the current file and save it in a Response object
//       APP.response = new Response(APP.file, {
//         status: 200,
//         statusText: 'Ok',
//         headers: {
//           'content-type': APP.file.type,
//           'content-length': APP.file.size,
//           'X-file': APP.file.name,
//         },
//       });
//       console.log(APP.response);
//       console.log(APP.file.name, 'saved in a Response object');
//     } else {
//       console.log('Pick a local file first');
//     }
//   },
//   ///////////////////////////////////////////////////////
//   saveInCache: (ev) => {
//     if (APP.response) {
//       //save the current Response object in the Cache using the Cache API
//       // caches.open() is Async function 
//       caches.open(APP.cacheName).then((cache) => {
//         APP.cache = cache;
//         let name = APP.response.headers.get('X-file');
//         let url = new URL(`/${Date.now()}/${name}`, location.origin);
//         cache.put(url, APP.response);
//         console.log(url, 'response saved in cache');
//       });
//     }
//   },
//   ///////////////////////////////////////////////////////
//   displayLocal: (ev) => {
//     //display APP.file on the webpage
//     if (APP.file) {
//       let type = APP.file.type;
//       if (type == 'application/json') {
//         //using arrayBuffer() and new TextDecoder('utf-8').decode(buffer)
//         APP.file.arrayBuffer().then((buffer) => { // returns a Promise that resolves with the contents of the file as binary data contained in an ArrayBuffer.
//           let txt = new TextDecoder('utf-8').decode(buffer);
//           document.getElementById('outputJSON').textContent = txt;
//         });
//         // using fetch
//         if(type == 'application/json'){
//           let uri = URL.createObjectURL(APP.file)
//           fetch(uri).then(response => response.text()).then(console.log)
//         }

//       } else if (type.startsWith('image/')) {
//         //image
//         let url = URL.createObjectURL(APP.file); // URL.createObjectURL is a pointer to the location of file in memory
//         document.getElementById(
//           'outputIMG'
//         ).innerHTML = `<img src="${url}" alt="image from ..."/>`;
//       } else {
//         //not a type we handle
//       }
//     } else {
//       console.log('no APP.file');
//     }
//   },
//   ///////////////////////////////////////////////////////
//   displayCache: async (ev) => {
//     //display last item from cache
//     if (!APP.cache) {
//       APP.cache = await caches.open(APP.cacheName);
//     }
//     let keys = await APP.cache.keys(); // cacheKey (request object)
//     console.log(keys)
//     //if there is something in the cache, get the last one, check the type, add to the page
//     if (keys.length > 0) {
//       let url = keys[keys.length - 1].url;
//       let response = await APP.cache.match(url);  //match() returns a Promise that resolves to the Response associated with the first matching request in the Cache object.
//       let type = response.headers.get('content-type');
//       if (type == 'application/json') {
//         //json
//         let txt = await response.text();
//         document.getElementById('outputJSON').textContent = txt;
//       } else if (type.startsWith('image/')) {
//         //image
//         let blob = await response.blob();
//         let url = URL.createObjectURL(blob);
//         document.getElementById(
//           'outputIMG'
//         ).innerHTML = `<img src="${url}" alt="image from ..."/>`;
//       } else {
//         //we don't want this
//       }
//     }
//   },
//   ///////////////////////////////////////////////////////
//   saveAndDisplayCanvas: (ev) => {
//     //extract the image from the Canvas, save it in the cache
//     //and display it on the screen
//     APP.canvas.toBlob(
//       async (buffer) => {
//         //handle the buffer from the canvas
//         let file = new File([buffer], 'canvasImage.jpg', {
//           type: 'image/jpeg',
//         });
//         let response = new Response(file, {
//           status: 200,
//           statusText: 'ok',
//           headers: {
//             'content-type': file.type,
//             'content-length': file.size,
//             'X-file': file.name,
//           },
//         });
//         let url = new URL(`/${Date.now()}/${file.name}`, location.origin);
//         if (!APP.cache) {
//           APP.cache = await caches.open(APP.cacheName);
//         }
//         APP.cache.put(url, response);
//         let blobUrl = URL.createObjectURL(file);
//         document.getElementById(
//           'outputIMG'
//         ).innerHTML = `<img src="${blobUrl}" alt="image from ..."/>`;
//       },
//       'image/jpeg',
//       1 // 1 means 100% quality
//     );
//   },
//   ///////////////////////////////////////////////////////
//   genAndSave: (ev) => {
//     let numbers = {
//       one: Date.now(),
//       two: Math.floor(Math.random() * Date.now()),
//       three: Math.floor(Math.random() * Date.now()),
//     };
//     let str = JSON.stringify(numbers);
//     //turn the string into a file and prompt the user to download the file
//     let file = new File([str], 'numbers.json', { type: 'application/json' });
//     let url = URL.createObjectURL(file);
//     let a = document.createElement('a');
//     //a.download = file.name;
//     a.setAttribute('download', file.name);
//     a.href = url;
//     a.click();
//   },
// };

// document.addEventListener('DOMContentLoaded', APP.init);

// ------------------------CSS.registerProperty---------------------

/*
https://drafts.css-houdini.org/css-properties-values-api/#at-property-rule
https://youtu.be/1bzq-KlfXBk

values in syntax :
  * - any value read as a string
  <length> - number plus unit - absolute units work. Relative fail(rem). (for font-size, width , height)
  <length>+ - space separated list of length values
  <number> - numbers with or without decimals
  <integer> - only integers
  <percentage> - 45%
  <length-percentage> - any length or percentage or calc value 
  <color> - any valid colour value
  <image> - an image url
  <url> - a url
  <angle> - number plus deg or rad or turn
  <time> - number plus ms or s
  <frequency>
  <position>
  <ratio>
  <resolution> - any valid resolution value like 500dpi
  <transform-list> - a list of transform functions
  <transform-function> - like scale, translate, rotate, matrix, etc
  <custom-ident> (a custom identifier string)
*/
// CSS.registerProperty({
//   name: '--somesize',
//   syntax: '<length>',
//   inherits: true,
//   initialValue: '60mm', // you can use px also
// });

// ---------------------------at method-------------------------------
/*
difference between [] and at method on arrays that at method accept negative no.
*/
// let names = ["Mohamed","Ahmed","Soliman","Hussein"]
// console.log(names[2])
// console.log(names.at(2))
// console.log(names[names.length - 1] ) // to get last item in array
// console.log(names.at(-1)) // to get last item in array


// ----------------------------JS Interview Question----------------------
//----------Video no. 1
// console.log("a")
// let timmy = setTimeout(function(){
//   console.log("b")
// },1)
// let timothy = setTimeout(function(){
//   console.log("c")
// },10)
// let timer = setTimeout(function(){
//   console.log("d")
// },0)
// console.log("e")
// order of input ? a , e, b , d , c

/* b before d because it's only 1 milisecond and setTimeout (timmy) will be finished and go 
to callback function queue before reaching line of setTimeout (timer)*/

//----------Video no. 2
// let num = 0;
// async function increment(){
//   num += await 2; // Promise.resolve(2)
//   console.log(num)
// }
// increment();
// num += 1;
// console.log(num)

// output => 2,3 / 1,3 / 1,2 / 2,1 => 1,2
// from me you can get 1,3 by using setTimeout setTimeout(increment,0)

//----------Video no. 3
// // turn this object literal into a mmodule that only exposes the render method
// let myModule = {
//   data : [],
//   render : () => {
//     console.log("Render Method")
//   },
//   add : () => {
//     console.log("Add Method")
//   },
//   remove : () => {
//     console.log("Remove Method")
//   },
// }
// myModule.render()

// // my solution

// class myModule2 {
//   static data = 10;
//   constructor(){
//     this.data = myModule2.data;
//   }
//   render() {
//     console.log("Render Method")
//   }
//   #add () {
//     console.log("Add Method")
//   }
//   #remove() {
//     console.log("Remove Method")
//   }
// }
// let myInst = new myModule2()
// myInst.render()

// // steve's solution

// let myModule3 = (function(){
//   let render = ()=> {
//     console.log("Render Method")
//   }
//   let add = ()=> {
//     console.log("Add Method")
//   }
//   let remove = ()=> {
//     console.log("Remove Method")
//   }
//   return {
//     render
//   }
// })();

// myModule3.render()


//----------Video no. 4
// how to check if arguments same no. of parametes
// my solution 
// let f = function(a,b){
//   if(arguments.length === arguments.callee.length) console.log(`no of arguments = no of params`)
// }

// //steve's solution 
// let f2 = function(a,b){
//   if(arguments.length === f2.length) console.log(`no of arguments = no of params`)
// }


// f(1)
// f(1,2)
// f(1,2,3)

// f2(1)
// f2(1,2)
// f2(1,2,3)

//----------Video no. 5
/* the problem here is ; if not add the js will see this as one line of code an search for 
property a inside object {a:123} */
// let a = {a : 123}
// [a].forEach(function(x){
//   console.log(x)
// })

//----------Video no. 6
// we need here to create 2 instances reference to same object

// let obj = (function(){
//   let objIntsance;
//   function create(){
//     if(!objIntsance) objIntsance = {name : "Soliman"}
//     return objIntsance;
//   }
//   return {
//     getInstance : create
//   }
// })();

// let obj1 = obj.getInstance();
// let obj2 = obj.getInstance();

// console.log(obj1)
// console.log(obj2)
// console.log(obj1 === obj2)

//----------Video no. 7
// function f(){
//   for(var i = 0; i < 3; i++){
//     setTimeout(function(i){
//       console.log(i)
//     },1000 * i)
//   }
// }
// f()

/* you have 4 options to solve this 
- use let
- use bind
- pass i argument to setTimeout
- use IIFE

search here for 4 options to find topic of this problem
*/


//----------Video no. 8
// create array of five random numbers :

// my answer : 
// let a1  = [];
// let a2  = [];
// for(let i =0; i < 5; i++){
//   a1.push(Math.floor(Math.random() * 10))
//   a2.push(Math.floor(Math.random() * 10))
// }
// console.log(a1)
// console.log(a2)

// steve's answers:

// let a1 = Array.from({length : 5} , () => Math.floor(Math.random() * 10)) // second param is map
// let a2 = new Array(5).fill(null).map(() => Math.floor(Math.random() * 10))
// console.log(a1)
// console.log(a2)

//----------Video no. 9
// var and let hoisting

//----------Video no. 10
// create random hex color values

// // my answer : 
// function color(){
//   let rand =`#${Math.floor(Math.random() * 10e6).toString(16)}` 
//   if(rand.length === 7) {
//     console.log(rand) 
//   }else{
//     console.log("One More Time")
//     color()
//   }
// }
// color()

// // steve's answer:
// function color2(){
//   let rand =`#${Math.random().toString(16).substring(2,8)}` 
//   console.log(rand)
// }
// color2()

//----------Video no. 11
/*
parseInt is often used with one argument, but takes two.
The first is an expression and the second is the radix.
To the callback function, Array.prototype.map passes 3 arguments to parseInt: the element, the index, the array.
The third argument is ignored by parseInt, but not the second one, hence the possible confusion.
*/
// let result = ["1","7","11"].map(parseInt)
// console.log(result)

// let arr = ["1","7","11"]
// let x = arr.map((num) => parseInt(num))
// console.log(parseInt("11",2))

//----------Video no. 12

// Differences between dot notation and square bracket syntax

// let sam = {
//   castiel: "mary"
// }
// let dean = {
//   john: "crowley",
//   mary: "chuck"
// }

// //which, if any, of these three log statements will work?
// console.log(dean[sam.castiel]); // ok
// console.log(dean.sam.castiel); // ERORR
// console.log(dean[sam['castiel']]); // Ok
// console.log(dean[sam[castiel]]); // ERORR

//----------Video no. 13
// Using `this` inside an object
// The object has functions created three different ways 
// What will be the result of the three log statements?

// const circle = {
//   radius: 10,
//   circumference: function () {
//       return (this.radius * 2);
//   },
//   diameter() {
//       return (this.radius * 2);
//   },
//   area: () => {
//       return (this.radius * 2);
//   }
// }
// console.log(circle.circumference()); // 20
// console.log(circle.diameter()); // 20
// console.log(circle.area()); // NaN

//----------Video no. 14
/**
 * Write a function to determine if a number is an integer
 */

// my answer
// let isInt = function (num) {
//   return Number.isInteger(num)
// }

// steve's answer
// let isInt = function (num) {
//   return (!isNaN(num) && parseInt(num) === num)
// }

// console.log(3, isInt(3));
// console.log(3.5, isInt(3.5));
// console.log(1.00000, isInt(1.00000));

//----------Video no. 15
/**
 * Write a function to determine if one String is 
 * a case-insensitive anagram of another String
 * anagram means => two strings with same length and same letters but can be different order
 */

// my answer
// let isAnagram = function (str1, str2) {
//   let check = true;
//   str1.split("").map(char =>{
//     if(!str2.split("").includes(char)){
//       check = false;
//     }
//   })
//   if(str1.length === str2.length && check ){
//     return true
//   }else{
//     return false
//   }
// }

//  steve's answer
// let isAnagram = function (str1, str2) {
//   let sorted1 = str1.split("").sort().join("").toLowerCase()
//   let sorted2 = str2.split("").sort().join("").toLowerCase()
//   return (sorted1 === sorted2)
// }

// console.log(isAnagram('hello', 'jello'));
// console.log(isAnagram('hello', 'loelh'));

//----------Video no. 16
/**
 * Write a function to determine the largest difference 
 * between any two numbers in an array of numbers
 */

// let numbers = [12, 2, 6, 5, 9, 10, 33];

// my answer
// let difference = (function (arr) {
//   let sortedNum = arr.sort((num1,num2) => num1 > num2 ? 1 : -1)
//   return sortedNum.at(-1) - sortedNum.at(0)
// })(numbers);

// steve's answer
// let difference = (function (arr) {
//   let sortedNum = Array.from(new Set(arr)).sort((num1,num2) => (num2 - num1))
//   return sortedNum[0] - sortedNum[arr.length-1]
// })(numbers);

// console.log(difference);

//----------Video no. 17

/*
 * Write a function to determine if the supplied string is a palindrome
 * Eg:  radar,  racecar, kayak, and redder are all palidromes
 * They are the spelled same backwards and forwards
 */

// my answer
// let palindrome = function (word) {
//   let num = 1;
//   let check = true;
//   word.split("").forEach((char,index,arr) =>{
//     if(char !== arr.at(-num)) check = false;
//     num++
//   })
//   return check
// }

// steve's answer
// let palindrome = function (word) {
//   let len = word.length;
//   let start = word.substring(0,Math.floor(len/2)).toLowerCase();
//   let end = word.substring(len - Math.floor(len/2)).toLowerCase();
//   let flip = end.split("").reverse().join("");
//   return (start === flip)
// }

// youtube's comment
// let palindrome = function (word) {
//   let reverse = word.split("").reverse().join("")
//   return reverse === word
// }

// console.log(palindrome('radar')); //true
// console.log(palindrome('redder')); //true
// console.log(palindrome('window')); //false

//----------Video no. 18

// //what are the values for a, b, x, y, j, k, r, s in the global scope?
// // y , s , z (without var or let ) because js will search for variable inside function if not found
// // search in global scope not found then will add x to global object

// (function f1() {
//   var a = 1, b = 1;
//   var x = y = 2;
// })();
// (function f2() {
//   let j = 1, k = 1;
//   let r = s = 2;
//   var h = 10
//   z = 10
// })();

// console.log(window.a); // undefined
// console.log(window.b); // undefined
// console.log(window.x); // undefined
// console.log(window.y); // 2
// console.log(window.j); // undefined
// console.log(window.k); // undefined
// console.log(window.r); // undefined
// console.log(window.s); // 2
// console.log(window.h); // undefined
// console.log(window.z); // 10

//----------Video no. 19
/**
 * Write a script to determine the brightness of the 
 * background colour and set the text colour as 
 * either white or black.
 * 30% of red +  60% of green + 10% of blue = intensity 
 */
// let log = console.log;

// let textColor = (bg) => {
//     bg = bg.replace('#', '');
//     //check length of string length of string should be 6
//     // you can use bitwise or substring
//     let red = parseInt(bg, 16) >>> 16; // parseInt(bg.substring(0,2), 16);
//     let green = (parseInt(bg, 16) >>> 8) & 255; // parseInt(bg.substring(2,4), 16)
//     let blue = parseInt(bg, 16) & 255; // parseInt(bg.slice(4,6), 16);
//     let intensity = (red * 0.299) + (green * 0.587) + (blue * 0.114); 
//     if (intensity > 186) {
//         return '#000000'; //black
//     } else {
//         return '#ffffff'; //white
//     }
// }

//  log(textColor('#BADA55')); //a bright green
//  log(textColor('#F0E68C')); //khaki
//  log(textColor('#990000')); //rebeccapurple
//  log(textColor('#6495ED')); //cornflowerblue

//----------Video no. 20
// let process = word => {
//   let vowels = ["a","e","i","o","u"];
//   let vowelsInWord = [];
//   let wordArr = word.split("")
//   wordArr.forEach((char,index)=>{
//     if(vowels.includes(char)){
//       vowelsInWord.push([index ,char])
//     }
//   })
//   let oddNum = vowelsInWord.length % 2;
//   if(oddNum) vowelsInWord.splice(Math.floor(vowelsInWord.length / 2),1);
//   let indx = 1;
//   vowelsInWord.forEach((char,index,arr)=>{
//     wordArr.splice(char[0],1,arr.at(-indx)[1])
//     indx++
//   })
//   return wordArr.join("")
// }

// console.log(process("javascript"))
// console.log(process("hello"))

//----------Video no. 21
/**
 * What will be the output of the following console.log?
 */

// let obj = {
//   'a': 'three',
//   b: 4,
//   'c': "five",
//   a: 3,
//   'b': "four",
//   "c": 'five',
//   "a": "tre",
//   "b": 'fyra',
//   c: 5
// };

// // any key of object a or "a" or 'a' will be converted to string "a" 
// console.log(obj); // {a: 'tre', b: 'fyra', c: 5}

//----------Video no. 22
/**
 * What will the output from the console.log be and why?
 */
// let box = {};
// let bag = {
//   prop: "bag",
//   can: "box"
// };
// let can = {
//   prop: "can",
//   bag: "box"
// };
// box[bag] = "Monday";
// box[can] = "Tuesday";

// // the key here will be converted to String( [object object]) so box[bag] will override box[can]
// console.log(box)
// console.log(bag.toString()) // [object object]
// console.log(box[bag]);

//----------Video no. 23
/***
 * What will be the output of this code and why?
 */
// let obj = { a: 1 , b : {c : 2}};
// let objb = { a: 1 , b : {c : 2} };

// if ({ a: 1 } === { a: 1 }) { // saved in two different locations in memory
//   console.log("Monday");
// } else if ({ a: 1 } == { a: 1 }) { // equality in value works with string or number or .. not with 2 different objects
//   console.log("Tuesday");
// } else if (obj == { a: 1 }) { // same 
//   console.log("Wednesday");
// } else if (obj == objb) { // same
//   console.log("Thursday");
// } else if (Object.is(obj, objb)) { // same
//   console.log("Friday");
// } else {
//   console.log("Saturday");
// }

// how to compare two objects:
/*
[1] JSON.stringify()

let obj = { a: 1 , b : {c : 2}};
let objb = { a: 1 , b : {c : 2} };
console.log(JSON.stringify(obj) === JSON.stringify(objb)) // true

let obj = { b : {c : 2},  a: 1};
let objb = { a: 1 , b : {c : 2} };
console.log(JSON.stringify(obj) === JSON.stringify(objb)) // false

[2] loadash liberary
import _ from "loadlash"

 */

//----------Video no. 24
/**
 * What will the output of the following two loops be?
 */
// const numbers = [1, 2, 3];
// numbers[10] = 11;

// for (let i = 0; i < numbers.length; i++) {
//   console.log(i, numbers[i]);
// }
// numbers.forEach((num, idx) => { // forEach will ignore undefined values
//   console.log(idx, num);
// });

//----------Video no. 25

/**
 * Create an example of a callback function with multiple parameters
 * and then show it being used
 */

// let callBack = function(success , fail , character){
//   let timmy = Math.floor(Math.random() * 1000)
//   if (character.isGood){
//     setTimeout(ftw , timmy , character.name)
//   }else{
//     setTimeout(wtf , timmy , character.name)
//   }
// }

// let ftw = function(name) {
//   console.log("Depending on the season,", name, "is a good guy");
// };
// let wtf = function(name) {
//   console.warn("Depending on the season,", name, "is a bad guy");
// };
// let app = (function() {
//   const castiel = { name: "Castiel", isGood: true };
//   const crowley = { name: "Crowley", isGood: false };
//   //use callback function here
//   callBack(ftw , wtf , castiel)
//   callBack(ftw , wtf , crowley)
// })();

//----------Video no. 26
/**
 * Finish the following script to extends the built-in
 * JavaScript String Object
 * so it has a method which will reverse the order of
 * characters in a string and return the resulting reversed string.
 * It should run with code provided.
 *
 * Bonus marks if it ignores punctuation at the end of the String.
 */

// let str = "Can I use Google during the interview?";

// // [1] using Array.from() and pop()
// // String.prototype.flip = function(){
// //   let arr = Array.from(this)
// //   arr.pop()
// //   let reversedStr = arr.reverse().join("")
// //   return reversedStr
// // }

// // [2] using regulay Expression
// String.prototype.flip = function(){
//   let reg = /\w|\s/ig
//   let char = this.match(/[?]/ig) || "" // if you want to add ? at the end
//   let arr = this.match(reg)
//   let reversedStr = arr.reverse().join("") + char
//   return reversedStr
// }

// console.log(str.flip());

//----------Video no. 27
/**
 * What will the value of the three log statements be?
 */
// let n1 = 111;
// let n2 = new Number(123);
// let n3 = Number(123);
// n1.prop = true;
// n2.prop = true;
// n3.prop = true;
// console.log(n1.prop); // undefined n1 primitive
// console.log(n2.prop); // true n2 object
// console.log(n3.prop); // undefined n3 primitive

//----------Video no. 28
/**
 * Variable Scope
 * What will be the output of the three log statements
 * and in what order?
 */
// (() => {
//   let one, two;
//   try {
//     throw new Error(321);
//   } catch (one) {
//     (one = 123), (two = 321);
//     console.log(one);
//   }
//   console.log(one);
//   console.log(two);
// })();

//----------Video no. 29
/**
 * What will the output of the following statements be?
 */

// let log = console.log;
// log(!!true);
// log(!!"");
// log(!!1);
// log(!!-1);
// log(!!NaN);
// log(!!undefined);
// log(!!"false");
// log(!!null);
// // 1st ! try to convert to Boolean then 2nd ! flip the boolean 

//----------Video no. 30

/**
 * What will be the value stored in the variable n?
 *
 */

// using comma operator as seperator between expressions will return last value
// let n = ((x = 1), (y = 2), (z = 3));
// console.log(n)

//----------Video no. 31
/**
 * What will be the output of the following statements?
 */

// let log = console.log;
// log(+"1");
// log(+true);
// log(+false);
// log(+"");
// log(+"hello");
// log(+1);

//----------Video no. 32

/**
 * Quirky operators and precedence in JavaScript
 * What is the output of these three lines and why?

  * Operator Precedence table
  * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
 */

//  let first = (! + [] * []);
// // +[] => 0   /  !+[] => true
// // true * 0 => 0
//  let second = (! + [] + [] * []);
// // true + [] * []
// // true + 0 * 0
// // 1 + 0 => 1
// let third = (! + [] + [] + ![]).length; // concat as string
// // true + [] + [] + false
// // true + "" + false
// // "truefalse".length => 9

// console.log(first); // 0
// console.log(second); // 1
// console.log(third); // 9
// console.log([] + []) // ""
// console.log(![]) // false (Boolean)
// console.log(true + []) // true (String)

//----------Video no. 33
/**
 * Which of the following lines will return a true and
 * which will return false?
 */

/*
The main difference between the == and === operator in javascript is that the == operator 
does the type conversion of the operands before comparison, whereas the === operator 
compares the values as well as the data types of the operands.
*/
// console.log(["a", "b"] == ["a", "b"]); // false
// console.log(["a", "b"] == ["a", "b"] + []); // true
// // ["a", "b"] == "a,b" + ""
// // "a,b" == "a,b"
// console.log(["a", "b", "c"] == ["a", "b"] + []); // false
// // ["a", "b", "c"] == "a,b" + ""
// // "a,b,c" == "a,b"
// console.log(["a", "b"] == ["b", "a"]); // false
// // "a,b" == "b,a"
// console.log(["a", "b"] == "a,b");// true

//--------------------Broadcast Channel API-----------------
// const APP = {
//   channel: new BroadcastChannel('wkrp'),
//   win: null,
//   init: () => {
//     //add button listeners
//     document.getElementById('btnOpen').addEventListener('click', APP.openTab);
//     document
//       .getElementById('btnSend')
//       .addEventListener('click', APP.sendMessage);
//     //register service worker
//     navigator.serviceWorker.register('webWorkers/broadsww.js');

//     //listen for broadcasted messages
//     APP.channel.addEventListener('message', APP.gotMessage);
//   },
//   openTab: (ev) => {
//     //open a new tab / window
//     APP.win = window.open('./index.html');
//   },
//   sendMessage: (ev) => {
//     let msg = document.getElementById('txtMessage').value;
//     //send the message on the broadcast channel
//     if (msg) {
//       APP.channel.postMessage({ message: msg });
//     }
//   },
//   gotMessage: (ev) => {
//     //message received on the wkrp broadcast channel
//     if (ev && ev.data) {
//       document.getElementById(
//         'messages'
//       ).innerHTML += `<p>RECEIVED: ${ev.data.message}</p>`;
//     }
//   },
// };

// //once DOM has loaded as each page loads
// document.addEventListener('DOMContentLoaded', APP.init);

//-----------------------Tabs and PopUp Windows-------------------
// //script run with defer
// document.getElementById('btnTab').addEventListener('click', this.openTab);
// document.getElementById('btnWin').addEventListener('click', this.openWin);

// function openTab(ev) {
//   console.log('open a tab');
//   let win = window.open('html/tab.html', null);
//   win.onload = (ev) => {
//     win.document.body.style.backgroundColor = '#999';
//     setTimeout(() => {
//       win.close();
//     }, 2500);
//   };
// }

// function openWin(ev) {
//   console.log('open a popup window');
//   // let win = window.open(
//   //   'html/win.html',
//   //   null,
//   //   'popup,width=400,height=400,left=300,top=500, noopener' //noopener It prevents the opening page to gain any kind of access to the original page
//   // );
//   let win = window.open(
//     '',
//     null,
//     'popup,width=400,height=400,left=300,top=500'
//   );
//   win.document.write(
//     '<html><head><title>Sample</title></head><body>Sample</body></html>'
//   );
//   // onload event will not work here because we did not open a file we opened '' and used we win.document.write
//   win.onload = () => {
//   let timmy = setInterval(() => {
//     let w = Math.random() * parseInt(window.screen.availWidth);
//     let h = Math.random() * parseInt(window.screen.availHeight);
//     win.resizeTo(w, h);
//   }, 1000);

//   setTimeout(() => {
//     clearInterval(timmy);
//     win.close();
//   }, 6000);
//   };
// }

//---------------------------------------showPicker---------------------------

// document.getElementById('btnPick').addEventListener('click', (ev) => {
//   ev.preventDefault();
//   console.log('activate a picker');
//   if ('showPicker' in HTMLInputElement.prototype) {
//     console.log('yes');

//     try {
//       // document.getElementById('inColour').showPicker();
//       // document.getElementById('inList').showPicker();
//       // document.getElementById('inDate').showPicker();
//       // document.getElementById('inTime').showPicker();
//       // document.getElementById('inLocal').showPicker();
//       // document.getElementById('inMonth').showPicker();
//       document.getElementById('inWeek').showPicker();
//       // document.getElementById('inFile').showPicker();
//     } catch (err) {
//       switch (err.type) {
//         case 'InvalidStateError':
//         //element is not mutable (disabled)
//         case 'NotAllowedError':
//         //didn't use transient activation
//         case 'SecurityError':
//           //cross-origin issue involving iframes
//           console.log({ err });
//           break;
//         default:
//           console.log('general error');
//       }
//     }
//   } else {
//     console.log('no');
//   }
// });

// ------------------------------eyeDropper------------------------

// document.getElementById('btnGo').addEventListener('click', function(ev)  {
//   const output = document.getElementById('result');
//   if (!'EyeDropper' in window) {
//     output.textContent = 'Sorry. No support for the Eyedropper API';
//     return;
//   }

//   const dropper = new EyeDropper();
//   const abortController = new AbortController();
//   // abortController.abort(""); //cancel the eyedropper

//   // setTimeout(abortController.abort.bind(abortController),1000) // see difference between method invocations and function invocations

//   dropper
//     .open({ signal: abortController.signal })
//     .then((result) => {
//       console.log(result.sRGBHex);
//       output.textContent = result.sRGBHex;
//       output.style.borderLeftColor = result.sRGBHex;
//     })
//     .catch((err) => {
//       output.textContent = err;
//       output.style.borderLeftColor = `transparent`;
//     });
// });

// -----------difference between method invocations and function invocations-----------
/*
A method is a function stored as a property of an object. When invoking (i.e. calling) 
a method using the dot notation or square bracket notation, 
the this keyword is bound to the object:

When invoking (i.e. calling) a function that is not the property of an object, 
the this keyword is:
* bound to the global object (window) in sloppy mode.
* undefined in strict mode.


An "illegal invocation" error is thrown when calling a function whose this keyword doesn't 
refer to the object where it originally
 */

// let obj = {
//   myFunc : function(){
//     console.log(this)
//   }
// }

// //  [1] direct
// obj.myFunc() // this => obj


// //  [2] assigned to variable
// let myFuncVar = obj.myFunc
// myFuncVar() // this => window
// setTimeout(myFuncVar,1000)

// // [3] Destructed Method
// let { myFunc } = obj
// setTimeout(myFunc,1000)

// //  Two fixes
// // [1] create a function that's call the method
// let myFuncVar = () => obj.myFunc()
// myFuncVar() // this => obj

// // [2] Bind
// let myFuncVar = obj.myFunc.bind(obj)
// myFuncVar() // this => obj

// ----------------------------innerHTML and outerHTML--------------------
/*
- both are strings but outerHTML is string includes tag :
  console.log(p.innerHTML) Hello
  console.log(p.outerHTML) <p>Hello</p>

- both parse the string to element :
  main.innerHTML = <h1>Hello</h1> will add h1 element inside main element
  main.outerHTML = <h1>Hello</h1> will add h1 element inside main element
*/
//using defer attribute so this script runs after DOMContentLoaded event

// document.body.addEventListener('click', (ev) => {
//   //clicking somewhere on the body element
//   //this function runs after the event bubbles to the <body>
//   let target = ev.target;
//   let tag = target.localName;
//     // let tag = target.tagName; // but capital not small like localName
//   if (tag === 'p' || tag === 'h1') {
//     console.log(target.innerHTML);
//     let pre = document.createElement('pre');
//     pre.innerHTML = target.innerHTML; //copy of the text inside
//     document.querySelector('main').append(pre);

//     console.log(target.outerHTML);
//     let elemString = target.outerHTML;
//     document.querySelector('main').innerHTML += elemString;

//     // target.innerHTML = 'hello';
//     // target.outerHTML = '<h3>goodbye</h3>';
//     let htmlString = target.outerHTML;
//     const parser = new DOMParser();
//     const doc = parser.parseFromString(htmlString, 'text/html');
//     document.querySelector('main').append(doc.body.firstElementChild);
//   }
// });


// ------------------------Custom Errors in JavaScript-----------------
//using defer and type="module" to delay the running of the scripts
// import { SteveError, NetworkError } from './Module/errors.js';

// document.body.addEventListener('click', (ev) => {
//   let err = new Error('error message');
//   try {
//     throw err;
//   } catch (e) {
//     console.log({ e });
//   }

//   let errSteve = new SteveError('steve error happened');
//   try {
//     throw errSteve;
//   } catch (e) {
//     console.log({ e });
//   }

//   //pretend fetch
//   let resp = new Response(null, {
//     status: 452,
//     statusText: 'Your mom called. Time for dinner',
//     headers: {
//       'x-my-header': 'failure to curfew',
//     },
//   });
//   Promise.resolve(resp)
//     .then((resp) => {
//       if (!resp.ok) throw new NetworkError(resp);
//       console.log('response was too good.');
//     })
//     .catch((err) => {
//       console.log({ err });
//     });
// });

// ----------------------------DOMTokenLists-------------
// let link = document.getElementById('otherlink');
// let output = document.getElementById('out');
// let main = document.querySelector('main');
// let nm = document.getElementById('nm');
// let em = document.getElementById('em');

// nm.addEventListener('input', buildOutput);
// em.addEventListener('input', buildOutput);

// function buildOutput(ev) {
//   output.value = `${nm.value} ${em.value}`;
// }

// console.log(output.getAttribute('for'));
// console.log(output.htmlFor);

// // console.log(main.title);
// // console.log(main.className);
// // console.log(main.classList);
// // console.log(link.rel);
// // console.log(link.relList);
// main.classList.toggle('steve');
// // console.log(main.classList.contains('steve'));
// // console.log(main.classList.contains('notSteve'));

// // console.log(link.relList.supports('stylesheet'));
// // console.log(link.relList.supports('gibberish'));
// // console.log(link.relList.supports('nonsense'));
// // console.log(link.relList.supports('icon'));


// ------------attach event handlers to dynamically created JavaScript elements-----------
/*
to attach event to dynamically created element you have to add class or id to that element
then get it by document.querySelector or document.getElementById after adding it to DOM

you can not add event directly to variable newDog because it's just a copy of created element 
on JS memory saved in variable
not the Real element in the DOM
*/

// let newDog = document.createElement('div')

// newDog.classList.add('dog')

// const myImage = document.createElement('img')
// myImage.src="https://picsum.photos/id/237/500/500";
// myImage.alt='Dog photo'

// const h2 = document.createElement('h2')
// h2.textContent = 'My name is Roviel and i love playing and eating.'

// const p = document.createElement('p')
// p.classList.add('moreInfo')
// p.style.display ='none'
// p.textContent= 'more Info......'


// const button = document.createElement('button')
// button.classList.add('btn')
// button.textContent= 'Click to read  more about me '

// document.body.appendChild(newDog)
// newDog.appendChild(myImage)
// newDog.appendChild(h2)
// newDog.appendChild(p)
// newDog.appendChild(button)

// // Adding event handlers

// function showMore(){
//     document.querySelector('.moreInfo').style.display ='block'
// }

// document.querySelector('.btn').addEventListener('click', showMore)

***************************************** JEST Test *****************************************

** Unit Tests
Building small testable units

** Integration Tests 
Integrate and test units
to work together

** End to End tests (UI Tests E2E)
User test the whole application 

** Testing Rules : 
[1] Get the Function to test
[2] Give Input to the Function
[3] Dfine what is the output
[4] Check  For th output

** TDD => Test Driven Development

[1] Think About What your Code will be
[2] Write The Code
[3] Test The Code

***************************************** TypeScript *****************************************

//---------------------difference between Statically typed language and Dynamically Typed Language----------------------
/*
[1] Statically typed language > (Rust , C , C++)
    Variables Type are Static , once Declared you can not change it
    Do Type Checking at Compile-Time
    Better Performance at Run-Time because no need to check Types Dynamically (Error Detected earlier)

[2] Dynamically Typed Language > (PHP, Python, JS)
    Variable Type is Dynamic , you can change it any time
    Type Checking at Excution-Time (Error can be detected after Excution)
*/

// let num = 10;
// num = "Elzero" // Error Type 'String' is not assignable to type 'number'

// let age = 40;
// if(age > 30) {
//     console.log("Good")
// }else{
//     // repeat is string method not number method
//     // will detect the Error before run the Code and even if age > 30 and will not excute this line of code
//     console.log(age.repeat(3)) 
// }


/*
    -------------------------------------Type Annotations || Signature------------------------------------
    -- Indicate The Data Type Of Variables
    -- Indicate The Data Type Of Functions Input/Output
    -- Objects, etc.

    - Why We Use It ?
    - Is It Mandatory ? 
    - What Happen If We Didnt Use It ?
*/

// let theName = "Elzero"; // if you declare variable without writing it's type but you assigned it to a value => type will be considered type of it's value
// let theAge: number = 40;
// let hire: boolean = true;
// let all: any = "Elzero Web School";
// let allVars; // if you declare variable without writing it's type or a value => type will be considered (any)
// theName = "Osama";
// all = 100;


// in JS 
// function add(n1, n2) {
//     return n1 + n2;
// }
// console.log(add(10, 20)); //30
// console.log(add(10, "20")); // 1020
// console.log(typeof add(10, 20));

// in TS
// function add(n1: number, n2: number) { // you should write type of Function input (parameters)
//     return n1 + n2;
// }
// console.log(add(10, 20)); //30
// // console.log(add(10, "20")); // Error
// console.log(typeof add(10, 20));

// -------------------------------------Type Annotations With Arrays-------------------------------


// let all: (string | number | boolean) = "Osama";

// all = "A";
// all = 100;
// all = true;

// let myFriends = ["Osama", "Ahmed", "Sayed", 10]; // Error with repeat myFriends (string | number )[] => means array of strings and number (considered automatically from values)
// let myFriends: string[] = ["Osama", "Ahmed", "Sayed", 10]; // Error with 10 because we wrote string[] => means array of strings only
// let myFriends: string[] = ["Osama", "Ahmed", "Sayed"];

// for (let i = 0; i < myFriends.length; i++) {
//     console.log(myFriends[i].repeat(3));
// }

// -------------------------------Type Annotations With mutliDimensional Arrays-------------------------

// let arrayOne: number[] = [1, 2, 3, 4, 5];
// let arrayTwo: string[] = ["A", "B", "C"];
// let arrayThree: (string | number)[] = [1, 2, 3, 4, "A", "B", "C"];

// let arrayFour: (string | number | string[] | boolean)[] = [1, 2, 3, 4, "A", "B", ["C", "D"], true, false];
// let arrayFive: (string | number | (string | number)[] | boolean)[] = [1, 2, 3, 4, "A", "B", ["C", "D", 5 , 6 ], true, false];


// -------------------------------Type Annotations With Functions-----------------------------
/*
=> in tsconfig.json file : 
- noImplicitAny = true ; Default Enable error reporting for expressions and declarations with an implied 'any' type.
- noImplicitAny = false ; will not give you an Error

- noImplicitReturns
    --- Will Check All Code Paths In A Function To Ensure They Return A Value

- noUnusedLocals
    --- Report Errors On Unused Local Variables

- noUnusedParameters
    --- Report Errors On Unused Parameters In Functions.
*/

// let showMsg = true;

// function showDetails(name: string, age: number, salary: number) : string { // last :string => means function should return string
//     let test = 10;
//     if (showMsg) {
//         return `Hello ${name}, Age Is ${age}, Salary Is ${salary}, Test Variable ${test}`;
//     }
//     return `No Data To Show`;
// }

// console.log(showDetails("Osama", 40, 5000));

// -------------------------------Optional and Default Parameters-----------------------
/*
- In JavaScript, Every Parameter Is Optional => "undefined" If You Didnt Use It
- "?" Optional Parameter
*/

// in JS
// function showData(name = "Unknown", age, country = "Unknown") {
//     return `${name} - ${age} - ${country}`;
// }
// // you can write only 2 arguments of 3 parameters without any Errors
// console.log(showData("Osama", 40)); 
// // you can skip an argument by adding undefinded
// console.log(showData(undefined, 40 , "Egypt")); // will return unknown - 40 - Egypt


// in TS
// you can write only 2 arguments of 3 parameters but you have to add default parameter or optional parameter

//[1] Default Parameter
// function showData(name: string = "Unknown", age: number, country: string = "Unknown") {
//     return `${name} - ${age} - ${country}`;
// }
// console.log(showData("Osama", 40));

//[2] Optional Parameter
// function showData(name?: string, age?: number, country?: string) {
//     return `${name} - ${age} - ${country}`;
// }

// console.log(showData("Osama", 40));

// Note : Required Parameter can not be after optional parameter
/*
showData(name?: string, age?: number, country?: string) => OK
showData(name?: string, age: number, country?: string) => not OK (age Required parameter can not be after name optional parameter 
*/

// -------------------------------Function Rest Parameter-----------------------
// Float => All (float or int) Is Under Type Number


// function addAll(...nums: number[]) : number {
//     let result = 0;
//     for (let i = 0; i < nums.length; i++) {
//         result += nums[i];
//     }
//     // nums.forEach((num) => result += num);
//     return result;
// }

// console.log(addAll(10, 20, 30, 100, 10.5, +true));

// ---------------------------Function Anonymous Function and Arrow Function-------------

// const add = function(num1: number, num2: number) : number {
//     return num1 + num2;
// }

// console.log(add(10, 20));

// const addWithArrow = (num1: number, num2: number) : number => num1 + num2;

// console.log(addWithArrow(10, 20));

// ---------------Assignments from lesson 1 to 11-----------

// assignment 1 : 
/*
in tsconfig File : 
"rootDir": "./project/files/typescript/"
"outDir": "./dist/compiled/javascript/"
"sourceMap": true
*/

// assignment 2 :
// function calculate(numOne : number, numTwo : number) {
//     return numOne + numTwo;
// }

// console.log(calculate(10, 20)); // 30
// console.log(calculate("10", "20")); // We Don't Need This To Work
// console.log(calculate(+true, +true)); // 2

// assignment 3 :
// function printInfo(valueOne : (string | number), valueTwo : (string | number)) {
//     return `Value One Is ${valueOne}, Value Two Is ${valueTwo}`;
// }

// console.log(printInfo(10, 20)); // Value One Is 10, Value Two Is 20
// console.log(printInfo("10", "20")); // Value One Is "10", Value Two Is "20"
// console.log(printInfo(true, [1, 2, 3])); // We Don't Need This To Work

// assignment 4 :

// let arr: (number | boolean[] | (string | (string | number)[])[])[];
// let arr1: (any | any[] | (any | (any)[])[])[];

// assignment 5 :
// function reportErrors(username:string, age: number) { //noUnusedParameters in tsconfig file to give you an error of unused param
//     let rank = "Professor"; //noUnusedLocals in tsconfig file to give you an error of unused variable
//     return `Username: ${username}`;
//     console.log("We Will Not Reach Here"); // "allowUnreachableCode": false,  in tsconfig to give you an Error of unreachable code after return statment
// }
// console.log(reportErrors("Elzero", 40));

// assignment 6 :
// let nothing;
// let theName: string = "Elzero";
// function showMyDetails(a = "", b = "", c:string) {
//     return `${a}${b}${c}`;
// }

// // Replace ???? With The Available Variables As Argument To Get The Result
// console.log(showMyDetails(nothing,nothing,theName)); // Elzero

// assignment 7 :
// function showMsg(user?: string, age?: (number | string), country?: string) {
//     return `${user}${age}${country}`;
// }

// console.log(showMsg());
// console.log(showMsg("Elzero"));
// console.log(showMsg("Elzero", 40));
// console.log(showMsg("Elzero", "40", "Egypt"));

// assignment 8 : 
// Write The Function Here
// function printInConsole(...diffArr : (number | string | boolean)[]){
//     let result :string = "";
//     diffArr.forEach(ele => result += `The Value Is ${ele} And Type Is ${typeof ele}\n`)
//     return result += "Done"
// }
// // Using The Function => Do Not Edit
// console.log(printInConsole(1, 2, 3, 4, 5));
// console.log(printInConsole("A", "B", "C"));
// console.log(printInConsole(true, false, false, true, true));

// Output
/* 
The Value Is 1 And Type Is number
The Value Is 2 And Type Is number
The Value Is 3 And Type Is number
The Value Is 4 And Type Is number
The Value Is 5 And Type Is number
Done
The Value Is A And Type Is string
The Value Is B And Type Is string
The Value Is C And Type Is string
Done
The Value Is true And Type Is boolean
The Value Is false And Type Is boolean
The Value Is false And Type Is boolean
The Value Is true And Type Is boolean
The Value Is true And Type Is boolean
Done
*/

// ---------------------------------Data Types- Type Alias----------------------------

// type st = string;
// let theName: st = "Elzero";
// theName = "Osama";

// type standnum = string | number;
// let all: standnum = 10;
// all = 100;
// all = "Osama";

// ---------------------------------Advanced Type Alias----------------------------

// type Buttons = {
//     up: string,
//     right: string,
//     down: string,
//     left: string
// }

// type Last = Buttons & {
//     x: boolean
// }

// function getActions(btns: Last) {
//     console.log(`Action For Button Up Is ${btns.up}`);
//     console.log(`Action For Button Right Is ${btns.right}`);
//     console.log(`Action For Button Down Is ${btns.down}`);
//     console.log(`Action For Button Left Is ${btns.left}`);
// }

// // properties of object should be the same name inside type annotation of Buttons or Last
// getActions({ up: "Jump", right: "Go Right", down: "Go Down", left: "Go Left", x: true });


// ---------------------------------Literal Types----------------------------
// // you can write type of specific number or string not only writing type (string | number | boolean )
// let ten : 10 = 10; // ok
// let nine : 9 = 10; // Error

// // you can write what function can return ... here function compare allowed to return only 0 , 1, -1 and we used type alias to give it a name (nums)

// type nums = 0 | 1 | -1; // type alias

// function compare(num1: number, num2: number) : nums { 
//     if (num1 === num2) {
//         return 0;
//     } else if (num1 > num2) {
//         return 1;
//     } else {
//         return -1;
//     }
// }

// console.log(compare(20, 20)); // 0
// console.log(compare(20, 15)); // 1
// console.log(compare(20, 30)); // -1

// let myNumber: nums = 1;

// -------------------------------------------------Tuple------------------------------------
/*
    Data Types
    - Tuple
    --- Is Another Sort Of Array Type
    --- We knows Exactly How Many Elements It Contains
    --- We Knows Which Types It Contains At Specific Positions
*/

// let article: readonly [number, string, boolean] = [11, "Title One", true];
// article = [12, "Title Two", false];
// // article.push(100); // will not work if readonly
// console.log(article);

// const [id, title, published] = article;
// console.log(id);
// console.log(title);
// console.log(published);

// -------------------------------------------------Void------------------------------------
/*
    Data Types
    - Void
    --- Function That Will Return Nothing 
    --- Function In JavaScript That Not Return A Value Will Show undefined
    --- undefined is not void
    ** if you write return; will not give you error with function fn(param:string):void {}
    ** if you write return undefined; will not give you error with function fn(param:string):void {} 
    ** if you write return undefined; or return; and did not write fn(param:string):void {} TS will considered it as : void

    - Never
    --- Return Type Never Returns
    --- The Function Doesn't Have A Normal Completion
    --- It Throws An Error Or Never Finishes Running At All "Infinite Loop"
    ** TS automatically detect the Error or infinte Loop inside Function Expressions not Function Declerations and give it automatically : never
    ** if TS automatically give the function : never you can write return but will be unreachable Code
    ** if you write : never manually you can not write return and will give you an Error
*/

// function logging(msg: string) : void {
//     console.log(msg);
//     return ; 
//     // return undefined;
// }

// console.log(logging("Iam A Message"));
// console.log("Test");

// const fail = (msg: string) => {
//     throw new Error(msg);
//     // return 10; // unreachable Code
// }

// const alwaysLog = function (name: string){ // TS see it as : Never 
//     while(true) {
//         console.log(name);
//     }
//     // return 10; // 2 Errors => [1]unreachable Code [2]type number is not assigned to type never
// }
// function alwaysLog2 (name: string) : never{ 
//     while(true) {
//         console.log(name);
//     }
//     // return 10; // 2 Errors => [1]unreachable Code [2]type number is not assigned to type never
// }

// alwaysLog("Osama");
// // console.log("Test"); //unreachable Code because alwaysLog is a function of while loop

// --------------------------------------Enumerations-----------------------------------------------
/*
    Data Types
    - Enums => Enumerations
    --- Allow Us To Declare A Set Of Named Constants
    --- Used For Logical Grouping Collection Of Constants "Collection Of Related Values"
    --- It Organize Your Code
    --- By Default Enums Are Number-Based, First Element Is 0
    --- Theres A Numeric Enums
    --- Theres A String-Based Enums
    --- Theres Heterogeneous Enums [String + Number]
*/

// const KIDS = 15;
// const EASY = 9;
// const MEDIUM = 6;
// const HARD = 3;

// if you did not give it values it will start from 0 (kid) => 1 (easy) => 2 (medium) => 3 (hard)
// enum Level {
//     Kids ,
//     Easy,
//     Medium,
//     Hard
// }

// enum Level {
//     Kids = 15,
//     Easy = 9,
//     Medium = 6,
//     Hard = 3
// }
// // Level.Easy = 12; // Error because it's read only property (enum is group of const and you can not reassign const)

// let lvl: string = "Easy";

// if (lvl === "Easy") {
//     console.log(`The Level Is ${lvl} And Number Of Seconds Is ${Level.Easy}`);
// }


// --------------------------------------Enumerations Part 2-----------------------------------------------

/*
Data Types
- Enums => Enumerations
--- Enum Can Refer To Other Enum
--- Enum Can Refer To Same Enum
--- Enum Can Have Calculations
--- Enum Can Have Functions
*/

// function getHardSeconds() : number {
// return 3;
// }

// // if you write const enum kid => will not show in JS File but if you need it to show in JS File add "preserveConstEnums": true in tsconfig File
// enum Kids {
// Five = 25,
// Seven = 20,
// Ten = 15
// }

// enum Level {
//     first, // you can add enum without value at the top
//     Kid = Kids.Ten, // Enum Can Refer To Other Enum
//     Easy = 9,
//     Medium = Easy - 3, // Enum Can Refer To Same Enum and Enum Can Have Calculations
//     Hard = getHardSeconds(),
//     // last, // you can not add enum without value after enums with values
// }

// let lvl: string = "Easy";

// if (lvl === "Easy") {
// console.log(`The Level Is ${lvl} And Number Of Seconds Is ${Level.Hard}`);
// }

// ------------------------------------Type Assertions---------------------------
/*
    Data Types
    - Type Assertions
    --- Sometime Compiler Doesnt Know The Information We Do
    --- TypeScript Is Not Performing Any Check To Make Sure Type Assertion Is Valid
*/

// // let myImg = document.getElementById("my-img") as HTMLImageElement;
// let myImg = <HTMLImageElement> document.getElementById("my-img");
// console.log(myImg.src);


// let data: any = 1000;
// // here you told TS that 1000 is string and TS believes you and will not give you an Error when you add .repeat function on it but will give you an Error when you run the JS File
// console.log((data as string).repeat(3));

// ------------------------------------Union And Intersection Type---------------------------

/*
    Data Types
    - Union And Intersection Types
    --- Union Type
    ------ The | Symbol Is Used To Create The Union => "Or"

    --- Intersection Type
    ------ Is A Type That Combines Several Types Into One
    ------ The & Symbol Is Used To Create An Intersection => "And"

    --- If A Union Is An OR, Then An Intersection Is An AND.
*/

// let all: number | string = 100;

// type A = {
//     one: string,
//     two: number,
//     three: boolean
// }

// type B = A & {
//     four: number
// }

// type C = {
//     five: boolean
// }

// type mix = A & C;

// function getActions(btns: mix) {
//     console.log(`Hello ${btns.one}`);
//     console.log(`Hello ${btns.two}`);
//     console.log(`Hello ${btns.three}`);
//     console.log(`Hello ${btns.five}`);
// }

// getActions({ one: "String", two: 100, three: true, five: true });


// ------------------------------------Type Annotations With Object---------------------------

// let myObject: {
//     readonly username: string,
//     id: number,
//     hire?: boolean,
//     skills: {
//         one: string,
//         two: string
//     }
// } = {
//     username: "Elzero",
//     id: 100,
//     hire: true,
//     skills: {
//         one: "HTML",
//         two: "CSS"
//     }
// };

// // myObject.username = "Osama";
// myObject.id = 101;
// myObject.hire = false;

// console.log(myObject.username);
// console.log(myObject.id);
// console.log(myObject.hire);
// console.log(myObject.skills.one);

// ------------------------------Assignments from lesson 12 to 21-----------------------

// assignment 1 

// // Write Your Code Here
// type n  = number;
// // Do Not Edit Here
// let myData: n;
// myData = 1000; // No Problem Here
// myData = +true; // No Problem Here

// assignment 2

// // Write Your Code Here
// type mix = number | boolean;
// // Do Not Edit Here
// let myInfo: mix;
// myInfo = 1000; // No Problem Here
// myInfo = true; // No Problem Here

// assignment 3

// // Write Your Code Here
// type Info = {
//     theName : string,
//     theAge : number
// }
// type Full = Info & {
//     country : string
// }
// // Do Not Edit Here
// function showInfo(data: Info) {
//     console.log(`The Name Is ${data.theName}`);
//     console.log(`The Age Is ${data.theAge}`);
// }
// console.log(showInfo({ theName: "Elzero", theAge: 40 }));

// function showFullInfo(data: Full) {
//     console.log(`The Name Is ${data.theName}`);
//     console.log(`The Age Is ${data.theAge}`);
//     console.log(`The Country Is ${data.country}`);
// }
// console.log(showFullInfo({ theName: "Elzero", theAge: 4, country: "Egypt" }));

// assignment 4

// function yesOrNo(val: number | string) : "True" | "False" | "Error"{
//     if(typeof val === "string") return "Error"
//     return val > 10 ? "True" : "False";
// }

//   // Do Not Edit Here
//   console.log(yesOrNo("100")); // Error
//   console.log(yesOrNo(30)); // True
//   console.log(yesOrNo(8)); // False

// assignment 5
// type custom = "Yes" | "No" | "Error"
// function isHeOld(age: number | string) : custom {
//     if(typeof age === "string") return "Error"
//     return age > 40 ? "Yes" : "No";
// }

//   // Do Not Edit Here
//   console.log(isHeOld("100")); // Error
//   console.log(isHeOld(45)); // "Yes"
//   console.log(isHeOld(30)); // "No"

// assignment 6
// let post : readonly [number, string, boolean];
// // post = [100, 200, "Title"]; // Error
// // post = ["Title", 100, true]; // Error
// post = [100, "Title", true]; // Good

// // post.push("Elzero"); // Error => Cant Add

// // Create Destructuring Here
// let [id , title , state] = post
// // Do Not Edit Here
// console.log(id); // 100
// console.log(title); // "Title"
// console.log(state); // true

// assignment 7
// Create Enums + Function Here
// enum Game {
//     Easy = 100 ,
//     Medium = 80,
//     Hard = 30,
//     Insane = 20
// }
// // Output
// console.log(Game.Easy); // 100
// console.log(Game.Medium); // 80
// console.log(Game.Hard); // 30
// console.log(Game.Insane); // 20

// assignment 8
// const user: {
//     username: string,
//     age: number | string,
//     website?: string,
//     skills: {
//         frontEnd: string[],
//         backEnd: (string | number)[]
//     }
// } = {
//     username: "Elzero",
//     age: 40,
//     website: "Elzero.org",
//     skills: {
//         frontEnd: ["HTML", "CSS", "JS"],
//         backEnd: ["PHP", "Python"]
//     }
// }

//   // We Need To Remove Error From This Edits
// user.username = "Osama";
// user.age = "40";
// user.skills.backEnd.push(100);

// ----------------------------------Interface---------------------------------
/*
    - Interface Declaration
    --- Serve Like Types
    --- The Interface Describes The Shape Of An Object
    --- It Defines The Syntax To Follow

    --- Use With Object
    --- Use With Function
    --- Use Read Only And Optional Operator
*/

// interface User {
//     id?: number,
//     readonly username: string,
//     country: string
// }

// let user: User = {
//     id: 100,
//     username: "Elzero",
//     country: "Egypt"
// }

// user.country = "Syria";

// console.log(user);

// function getData(data: User) {
//     console.log(`Id Is ${data.id}`);
//     console.log(`Username Is ${data.username}`);
//     console.log(`Country Is ${data.country}`);
// }

// getData({ id: 200, username: "Osama", country: "KSA" });
// getData({ username: "Osama", country: "KSA" }); // will give Error if id is not optional (id?: number)

// -----------------------------------Interface Method And Parameters---------------


// interface User  {
//     id: number;
//     username: string;
//     country: string;
//     sayHello() : string;
//     sayWelcome: () => string;
//     getDouble(num: number) : number;
// }

// let user: User = {
//     id: 100,
//     username: "Elzero",
//     country: "Egypt",
//     sayHello() {
//         return `Hello ${this.username}`;
//     },
//     sayWelcome: () => {
//         return `Welcome ${user.username}`;
//     },
//     getDouble(n) {
//       return n * 2;
//     }
// }

// console.log(user.id);
// console.log(user.sayHello());
// console.log(user.sayWelcome());
// console.log(user.getDouble(100));

// ---------------------------------------ReOpen The Interface And Use Cases------------------


// // Homepage
// interface Settings {
//     readonly theme: boolean;
//     font: string;
// }

// // Articles Page
// interface Settings {
//     sidebar: boolean;
// }

//   // Contact Page
// interface Settings {
// external: boolean;
// }

// let userSettings: Settings = {
//     theme: true,
//     font: "Open Sans",
//     sidebar: false,
//     external: true
// }

// -------------------------------------Extending Interfaces-------------------------


// interface User {
//     id: number;
//     username: string;
//     country: string;
// }

// interface Moderator {
//     role: string | number;
// }

// interface Admin extends User,Moderator { // like & in type
//     protect?: boolean;
// }

// let user: Admin = {
//     id: 100,
//     username: "Elzero",
//     country: "Egypt",
//     role: "Mod",
//     protect: true,
// }

// console.log(user.id);

// ---------------------------------- Interface vs Type Aliases-----------------------
/*
** with Type you can not reopen Type and add properties but interface you can : 

[1] Type : 
type setting = {
    font: string;
}
type setting = { // will give you Error
    sidebar: boolean;
} 

[2] Interface :
interface setting  {
    font: string;
}
interface setting  { // No Error
    sidebar: boolean;
} 

** with Interface you can use extends but with Type you use &

[1] Type : type Admin = User & Moderator
[2] Interface : interface Admin extends User,Moderator{}

*/

// let el = document.getElementById("id") as HTMLElement; // - Take A Look On HTMLElement Interface

// // Homepage
// type Settings = {
//     readonly theme: boolean;
//     font: string;
//     sidebar: boolean;
//     external: boolean;
// }

// let userSettings: Settings = {
//     theme: true,
//     font: "Open Sans",
//     sidebar: false,
//     external: true
// }

// ---------------------------------- Class Type Annotations-----------------------


// class User {
//     u: string;
//     s: number;
//     msg: () => string;
//     constructor(username: string, salary: number) {
//         this.u = username;
//         this.s = salary;
//         this.msg = function () {
//             return `Hello ${this.u} Your Salary Is ${this.s}`;
//         }
//     }
//     sayMsg() {
//         return `Hello ${this.u} Your Salary Is ${this.s}`;
//     }
// }

// let userOne = new User("Elzero", 6000);

// console.log(userOne.u);
// console.log(userOne.s);
// console.log(userOne.msg());
// console.log(userOne.sayMsg());

// ---------------------------------- Data Access Modifiers & Parameters Properties-----------------------
/*
    Class
    - Data Access Modifiers & Parameters Properties
    --- Public
    ------ All Members Of A Class In TypeScript Are Public
    ------ All Public Members Can Be Accessed Anywhere Without Any Restrictions
    --- Private
    ------ Members Are Visible Only To That Class And Are Not Accessible Outside The Class
    --- Protected
    ------ Same Like Private But Can Be Accessed Using The Deriving Class (it's subclasses)

    - TypeScript Is A Layer On Top Of JavaScript
    - It Should Remove All Annotations And Although Access Modifiers "Private For Example"
*/

// class User {
//     // Access Modifiers
//     // private username: string;
//     // protected salary: number;
//     // public readonly address: string;
//     msg: () => string;
//      // if you use Parameters Properties here no need to write it at the begining (Access Modifiers) of class and no need to write this.username = username ...
//     constructor(private username: string, protected salary: number,public readonly address: string) {
//         //this.username = username
//         //this.salary = salary
//         //this.address = address
//         this.msg = function () {
//         return `Hello ${this.username} Your Salary Is ${this.salary}`;
//         }
//     }
//     sayMsg() {
//         return `Hello ${this.username} Your Salary Is ${this.salary}`;
//     }
// }

// let userOne = new User("Elzero", 6000, "Cairo");

// // console.log(userOne.username);
// // console.log(userOne.salary);
// console.log(userOne.msg());
// console.log(userOne.sayMsg());

// ---------------------------------- Class Get And Set Accessors-----------------------


// class User {
//     // same like getter and setter method below but this is created automatically by you write click on username and choose "refactor" and then choose "generate get and set acessors"
//     public get username(): string {
//         return this._username;
//     }
//     public set username(value: string) {
//         this._username = value;
//     }
//     msg: () => string;
//     constructor(private _username: string, public salary: number, public readonly address: string) {
//         this.msg = function () {
//             return `Hello ${this._username} Your Salary Is ${this.salary}`;
//         }
//     }
//     sayMsg() {
//         return `Hello ${this._username} Your Salary Is ${this.salary}`;
//     }
//     // get username() : string {
//     //   return this._username;
//     // }
//     // set username(value: string) {
//     //   this._username = value;
//     // }
// }

// let userOne = new User("Elzero", 6000, "Cairo");

// console.log(userOne.username);
// userOne.username = "Ahmed";
// console.log(userOne.username);
// console.log(userOne.salary);
// console.log(userOne.msg());
// console.log(userOne.sayMsg());

// --------------------------------Class- Static Members----------------
/*
--- Don't Use "name, length, call"
*/

// class User {
//     private static created: number = 0;
//     static getCount() : void {
//         console.log(`${this.created} Objects Created`);
//     }
//     constructor(public username: string) {
//         User.created++;
//     }
// }

// let u1 = new User("Elzero");
// let u2 = new User("Web");
// let u3 = new User("School");
// // console.log(User.created);
// User.getCount();

// -----------------------------Class- Implement Interface-------------------

/*
[1] with Class- Implement Interface you can use theme , font , save() and more no problem but not less than theme , font , save()

[2] with Interface with Object you must use theme , font , save() no more or no less
interface Settings {
    theme: boolean;
    font: string;
    save(): void;
}
let obj : Settings = {
    theme : true,
    font : "Open Sans",
    save(){
        console.log("Saved")
    },
    // Update(){ // Error
    //     console.log("Update")
    // }
}
*/
// interface Settings {
//     theme: boolean;
//     font: string;
//     save(): void;
// }

// class User implements Settings {
//     constructor(public username: string, public theme: boolean, public font: string) {}
//     save(): void {
//         console.log(`Saved`);
//     }
//     update(): void {
//         console.log(`Updated`);
//     }
// }

// let userOne = new User("Elzero", true, "Open Sans");

// console.log(userOne.username);
// console.log(userOne.font);

// userOne.save();
// userOne.update();

// ----------------------------Assignments from lesson 22 to lesson 31------------------

// assignment 1
// Edit The Interface To Fix The Problems
// interface Member {
//     id: number | string;
//     username: string;
//     country?: string;
//     state: boolean;
//     getName() : void;
// }

// // Do Not Edit The Code Below
// let user: Member = { // Property 'country' is missing in type
//     id: 100,
//     username: "Elzero",
//     state: true,
//     getName() { // 'getName' does not exist in type 'Member'
//         return this.username;
//     }
// }

// user.id = 200;
// user.id = "200"; // Type 'string' is not assignable to type 'number'
// user.state = false; // Cannot assign to 'state' because it is a read-only property

// assignment 2
// Create Interface Here
// interface Client {
//     id: number;
//     username: string;
//     active: boolean;
//     discount: number;
//     getPrice(price: number) : void;
// }
// // Do Not Edit The Code Below
// let client: Client = {
//     id: 100,
//     username: "Elzero",
//     active: true,
//     discount: 10,
//     getPrice(price: number) {
//         return price - this.discount;
//     }
// }

// console.log(`Client Id Is ${client.id}`);
// console.log(`Client Name Is ${client.username}`);
// console.log(`Client Has Dicount ${client.discount}`);
// console.log(`Client Product After Discount Is ${client.getPrice(200)}`);

// assignment 3
// interface Superman extends Man,Bird {
//     bodyType: string;
//     origin: string;
// }
// // Do Not Edit The Code Below
// interface Man {
//     title: string;
//     weight: number;
//     age: number;
// }

// interface Bird {
//     canFly: boolean;
// }

// let creature: Superman = {
//     title: "Superman",
//     weight: 100,
//     age: 500,
//     canFly: true,
//     bodyType: "Iron",
//     origin: "Krypton"
// }

// assignment 4
// Create Class Here
// class Player {
//     // details : () => string // if you want to use details as instance method you should write this -- if you will use details as class method no need to write this
//     constructor( public name : string , public job : string , public level : (string | number) , public vip ?: boolean){
//         // this.details = () => {
//         //     if(this.vip){
//         //         return `VIP ${this.name}, Type Is ${job} Level IS ${this.level}`
//         //     }
//         //     return `${this.name}, Type Is ${job} Level IS ${this.level}`
//         // }
//     }
//     details() {
//         if(this.vip){
//             return `VIP ${this.name}, Type Is ${this.job} Level IS ${this.level}`
//         }
//         return `${this.name}, Type Is ${this.job} Level IS ${this.level}`
//     }
// }
// // Do Not Edit The Code Below
// let player1 = new Player("Osama", "Mage", 90, true);
// let player2 = new Player("Shady", "Archer", "85", false);
// let player3 = new Player("Amr", "Fighter", 50, true);
// let player4 = new Player("Mahmoud", "Assassin", 77);

// console.log(player1.details()); // VIP Osama, Type Is Mage Level Is 90
// console.log(player2.details()); // Shady, Type Is Archer Level Is 85
// console.log(player3.details()); // VIP Amr, Type Is Fighter Level Is 50
// console.log(player4.details()); // Mahmoud, Type Is Assassin Level Is 77

// Assignment 5
// class Shorten {
//     constructor (public id: number, public username: string, protected title: string) {}
// }

// let tester = new Shorten(100, "Elzero", "Developer");

// console.log(tester.id);
// console.log(tester.username);

// Assignment 6
// class Show {
//     public get title(): string {
//         return this._title;
//     }
//     public set title(value: string) {
//         this._title = value;
//     }
//     constructor (private _title: string) {}
// }

// let tester = new Show("Elzero");

// console.log(tester.title); // Property 'title' does not exist on type 'Show'
// tester.title = "Osama"; // Property 'title' does not exist on type 'Show'
// console.log(tester.title); // Property 'title' does not exist on type 'Show'

// Assignment 7
// interface Play {
//     id: number;
//     title: string;
//     level: number | string;
//     logIn(): void;
//     logOut(msg: string): void;
// }

// // Create Your Class Here
// class Player implements Play {
//     logIn: () => void 
//     logOut: (msg : string) => void 
//     constructor(public id: number, public title: string, public level: (number | string)) {
//         this.logIn = () => {
//             console.log(`Logged In`);
//         }
//         this.logOut = (msg) => {
//             console.log(`Logged Out , Good Bye`);
//         }
//     }
//     // logIn(): void {
//     //     console.log(`Logged In`);
//     // }
//     // logOut(msg : string): void {
//     //     console.log(`Logged Out , Good Bye`);
//     // }
// }

// let player1 = new Player(100, "Elzero", 95);

//   console.log(player1.id); // 100
//   console.log(player1.title); // "Elzero"
//   console.log(player1.level); // 95
//   player1.logIn(); // Logged In
//   player1.logOut("Good Bye"); // Logged Out, Good Bye

// -------------------------------------Class Abstract Classes And Members--------------------
/*
** Abstract Class is a parent class which child classes inherit from it  so we do not create instance from Abstract Class
** Abstract Method means that child Classes should has this Method (you write only the method name at Abstract Class and write what the method do at child class)
*/

// abstract class Food {
//     constructor(public title: string) {}
//     abstract getCookingTime() : void;
// }

// class Pizza extends Food {
//     constructor(title: string, public price: number) {
//         super(title);
//     }
//     getCookingTime() : void {
//         console.log(`Cooking Time For Pizza Is 1 Hour`);
//     }
// }

// class Burger extends Food {
//     constructor(title: string, public price: number) {
//         super(title);
//     }
//     getCookingTime() : void {
//         console.log(`Cooking Time For Burger Is Half Hour`);
//     }
// }

// let pizzaOne = new Pizza("Awesome Pizza", 100);

// console.log(pizzaOne.title);
// console.log(pizzaOne.price);
// pizzaOne.getCookingTime();

// ----------------------------------------------Polymorphism-------------------------------
/*
    Class
    - Polymorphism & Method Override

    - Polymorphism
    --- Classes Have The Same Methods But Different Implementations

    --- noImplicitOverride (option in tsconfig file to give you Error if you did not write override keyword)

    - Method Override
    --- Allowing Child Class To Provide Implementation Of A Method In Parent Class
    --- A Method In Child Class Must Have Same Name As Parent Class
*/

// class Player {
//     constructor(public name: string) {}
//     attack() : void {
//         console.log("Attacking Now");
//     }
// }

// class Amazon extends Player {
//     constructor(name: string, public spears: number) {
//         super(name);
//     }
//     override attack(): void {
//       // super.attack(); //if you want to inherit attack() from parent class (Player Class)
//         console.log("Attacking With Spear");
//         this.spears -= 1;
//     }
// }

// class Barbarian extends Player {
//     constructor(name: string, public axeDurability: number) {
//         super(name);
//     }
//     override attack(): void {
//       // super.attack();
//         console.log("Attacking With Axe");
//         this.axeDurability -= 1;
//     }
// }

// let barOne = new Barbarian("Elzero", 100);

// console.log(barOne.name);
// barOne.attack();
// console.log(barOne.axeDurability);

// ----------------------------------------------Generics-------------------------------
/*
** you can write <type> and use it to decide which type of will be used as parameter of the function and what the type which is the fucntion should return

    Generics
    - Help Write A Reusable Code
    - Allow To Pass Type As A Parameter To Another Type
    - You Will Be Able To Deal With Multiple Types Without Using ": Any Type"
    - We Can Create:
    --- Generic Classes
    --- Generic Functions
    --- Generic Methods
    --- Generic Interfaces
*/

// function returnNumber(val: number) : number {
//     return val;
// }
// function returnString(val: string) : string {
//     return val;
// }
// function returnBoolean(val: boolean) : boolean {
//     return val;
// }

// console.log(returnNumber(100));
// console.log(returnString("Elzero"));
// console.log(returnBoolean(true));

// function returnType<T>(val: T) : T {
//     return val;
// }

// console.log(returnType<number>(100));
// console.log(returnType<string>("Elzero"));
// console.log(returnType<boolean>(true));
// console.log(returnType<number[]>([1, 2, 3, 4]));

// ------------------------------------Generics-Arrow Function-Multiple Types- Discussion-------------


// function returnType<T>(val: T): T {
//     return val;
// }

// console.log(returnType<number>(100));
// console.log(returnType<string>("Elzero"));

// const returnTypeArrowSyntax = <T>(val: T): T => val;

// console.log(returnTypeArrowSyntax<number>(100));
// console.log(returnTypeArrowSyntax<string>("Elzero"));

// function testType<T>(val: T): string {
//     return `The Value Is ${val} And Type Is ${typeof val}`;
// }

// console.log(testType<number>(100));
// console.log(testType<string>("Elzero"));

// function multipleTypes<T, S>(valueOne: T, valueTwo: S): string {
//     return `The First Value Is ${valueOne} And Second Value ${valueTwo}`;
// }

// console.log(multipleTypes<string, number>("Osama", 100));
// console.log(multipleTypes<string, boolean>("Elzero", true));

// -------------------------------Generic classes------------------
// class User<T = string> { // = string is default value
//     constructor(public value: T) {}
//     show(msg: T) : void {
//         console.log(`${msg} - ${this.value}`);
//     }
// }

// let userOne = new User<string>("Elzero");
// console.log(userOne.value);
// userOne.show("Message");

// let userTwo = new User<number | string>(100); // you have to write <number | string> because we use 100 when creating instance and use string when use method (show)
// console.log(userTwo.value);
// userTwo.show("Message");

// ----------------------------Generics- Classes And Interfaces---------------------------


// interface Book {
//     itemType: string;
//     title: string;
//     isbn: number;
// }

// interface Game {
//     itemType: string;
//     title: string;
//     style: string;
//     price: number;
// }

// class Collection<T> {
//     public data: T[] = []; // in JS constructor(){this.data = []}
//     add(item: T) : void {
//         this.data.push(item);
//     }
// }

// let itemOne = new Collection<Book>();
// itemOne.add({ itemType: "Book", title: "Atomic Habits", isbn: 150510 });
// itemOne.add({ itemType: "Book", title: "Follow Your Heart", isbn: 650650 });
// console.log(itemOne);

// let itemTwo = new Collection<Game>();
// itemTwo.add({ itemType: "Game", title: "Uncharted", style: "Action", price: 150 });
// console.log(itemTwo);

// ----------------------------Assignments from lesson 32 to 38------------------------
// Assignment 1
// Do Not Edit
// type numandstring = number | string;

// abstract class Game {
//     constructor(public title: string, public price: numandstring) {}
//     abstract getLocation() : string;
//     abstract getDiscount() : string;
// }

// // Start Edit And Fix
// class RPG extends Game {
//     constructor(title: string, public price: numandstring, public rate: number) {
//         super(title,price)
//     }
//     getLocation(){
//         return "Location"
//     }
//     getDiscount(){
//         return "Discount"
//     }
// }

// class Action extends Game {
//     constructor(title: string, public price: numandstring, public rate: number, public company:string) {
//         super(title,price)
//     }
//     getLocation(){
//         return "Location"
//     }
//     getDiscount(){
//         return "Discount"
//     }
// }
// // End Edit And Fix

// // Do Not Edit
// let gameOne = new RPG("Ys", 100, 10);
// let gameTwo = new Action("Uncharted", 90, 15, "Sony");

// console.log(gameOne.title); // "Ys"
// console.log(gameOne.price); // 100
// console.log(gameOne.rate); // 10
// console.log(gameOne.getDiscount()); // "Discount"
// console.log(gameOne.getLocation()); // "Location"

// console.log(gameTwo.title); // "Uncharted"
// console.log(gameTwo.price); // 90
// console.log(gameTwo.rate); // 15
// console.log(gameTwo.company); // "Sony"
// console.log(gameTwo.getDiscount()); // "Discount"
// console.log(gameTwo.getLocation()); // "Location"

// Assignment 2
// Write Function Code Here
// ****** Giving void will make the generic type optional.
// function showTypes<t1 = void,t2 = void,t3 = void>(a?:t1,b?:t2,c?:t3):string{
//     return `${a?a:"Nothing"} - ${b?b:"Nothing"} - ${c?c:"Nothing"}`
// }
// // Do Not Edit Here
// console.log(showTypes()); // Nothing - Nothing - Nothing
// console.log(showTypes<string>("String")); // String - Nothing - Nothing
// console.log(showTypes<string, number>("String", 100)); // String - 100 - Nothing
// console.log(showTypes<string, number, boolean>("String", 100, true)); // String - 100 - true

//Assignment 3
// Write Class Code Here

// class Game<t1, t2 = number>{
//     constructor(public title:t1,public price:t2){}
//     getDiscount(x:t1) : void{
//         console.log(`The Discount is ${x}`)
//     }
// }
// // Do Not Edit Here
// let gameOne = new Game<string>("Ys", 100);
// let gameTwo = new Game<number>(2064, 100); // There's A Game Called "2064"

// console.log(gameOne.title); // "Ys"
// console.log(gameOne.price); // 100
// gameOne.getDiscount("50"); // "The Discount Is 50"

// console.log(gameTwo.title); // 2064
// console.log(gameTwo.price); // 100
// gameTwo.getDiscount(80); // "The Discount Is 80".

***************************************** React *****************************************

Creating React App (two options npx or npm): 
[1] npx create-react-app <project-name> 
(not installed globally so no worries about update package)

[2] npm creat-react-app -g
    create-react-app<project_name> 
(installed globally so needs update)

* note : remove <React.StrictMode> from index.js if React component render twice

    React : 
* is library not framework
* Focus on UI not Routing(1) or HTTP Requests
* Has a Rich EcoSystem(2)
* Has a component Based Architecture(3)
* is Declarative(4)
* will handle updating and rendering of the components
* will handle DOM updates



notes:
[1] Routing : is a technology for switching between different UI views, based on the changes of the current URL
[2] Rich EcoSystem : the interesting features and libraries that are available to use with React
[3] component Based Architecture : let you to break down the Application into small encapsulated parts then you can compose them and you has the ability also to reuse these components
[4] Declarative : Tell the React what you want and will build the actual UI
    ** Difference between Declarative programming and Imperative programming: 
    Declarative programming is a paradigm describing WHAT the program does, without explicitly specifying its control flow.
    Imperative programming is a paradigm describing HOW the program should do something by explicitly specifying each instruction (or statement) step by step.

    **Redux : Redux is a state management library (is a predictable state container for JavaScript apps ) that you can use with any JS library or framework like React, Angular, or Vue.
    https://www.freecodecamp.org/news/what-is-redux-store-actions-reducers-explained/amp/

Components : 
    * Root component (usually called APP) inside it there are 4 components :
        (1) Header component
        (2) Side Nav component
        (3) Main Content Component
        (4) Footer component

Types of Components :
    [A] Functional Component 
        a normal JS function returns HTML
        
        function welcome(props){
            return <h1>hello, {props.name}<h1>
        }
    
    [B] Class Component :
        a class Extending Component Class (from React library) and this class has render Method returns HTML
        
        class welcome extends React.component {
            render(){
                return <h1>hello, {this.props.name}<h1> 
            }
        }

* difference betwee class component and functional component : 
    class component has state but functional components are plain JavaScript functions. 
    Thus to maintain state inside the function, React provides several hooks like useState

JSX (JavaScript language syntax) : 
    * transiles to pure JS which is understood by Browser
    * Write XML-like code for elements and component
    * have a tag name , attributes and children
    * you can use React without JSX but with JSX code will be simpler
    * class => className -  for => htmlFor - onclick => onClick - tabindex => tabIndex

Props : 
    * is an object that's contains attributes and values which are passed in parent component ( inside App.js => like <Greet name="Ahmed"></Greet>) 
    * you can use props.children to get elements that added between <Greet></Greet> in parent component ( inside App.js )
    * props is immutable => you can not change it's value from Functional Component  or Class Component inside for Exp. Greet.js
    
Diffrence between State and Props : 
    Props : is Parameter passed to the component and immutable (can be accessed by props in Functional Component or this.props in Class component)
    State : is Variable and managed inside Component and mutable (can be accessed by useState Hook in Functional component or this.state in Class component)

setState :
    * a Method to make changes to state (When you change state directly without using setState you change it but not invoking Render Method so will change but will not shown on the page see exp. in counter.js)
    * has two Parameters (state Object , callBack Function)
    * 1st parameter (state object) can be replaced by function and this function has 2 parameters (prevState , props)
    * when you have to update state based on previous state value , pass in a functions as an argument to the setState method instead of state object
        Let [count , setCount] = useState(0)
        \\ here will increment count by 1 not 3 because in all line count is zero ( not updated number so will re-render only one time )
        Const handleClick = () => {
        setCount( count + 1 ) 
        setCount( count + 1 ) 
        setCount( count + 1 ) 
        } 
        \\ here will increment by 3 because we are using prev ( update count value ) 
        \\ React groups multiple state updates into a single re-render for better performance
        Const handleClick = () => {
        setCount( prev => prev + 1 ) 
        setCount( prev => prev + 1 ) 
        setCount( prev => prev + 1 ) 
        } 
    * ASYNC Method (see exp. in counter.js) to solve this problem use 2nd parameter of setState Method 
    * 2nd Parameter used when you want to change state and invoke another function that use the new value of the state (see exp. in parentComponent.js)

prevState :
    Batching is when React groups multiple state updates into a single update. That is only one single re-render will eventually happen.
    so we use prevState (like new Variable created ) so you can increment it because state will update the value only one time

Shortcuts :
    * rce : class component
    * rcfe : function component
    * rpce : pure Component
    * rconst : construtor

EventBinding: 
    ** because Eventhandler Function is Async and excuted globaly so this will be window object ( in class will be undefined because of strict mode)
    we have 4 options to be sure that this will be class not undefined 

    [1] use bind keyword in render method  (bad performance)
    [2] use arrow function in render method  (bad performance)
    [3] use arrow function as class prop 
    [4] use bind keyword in construtor

Conditional render (exp. userGreeting.js):
    [1] if / else
    [2] Variable
    [3] ternary operator
    [4] short circuit operator (&&) or nullish coalescing operator(??)

Keys of list :
    * has to be unique
    * to avoid a warning message on list (EXP. persons.js) add key property to each child
    * Key is not a prop (you can not access it see persons.js)
    * it is not recommended to use index as key because React link the item list to it's key
    so when add item at the begining you change the index of all items but when render the
    React will render the item (for Exp. item linked to key 0) to the old item linked to 0
    not the newly added item (see video 19 if you didn't understand)

Style in React :
    [1] CSS Stylesheet
    [2] inline styling (object has styles and should be camelCase see inline.js)
    [3] CSS Modules 
     * in regular CSS file import like this import "./appStyles.css" but from module will be like this import styles from "./appStyles.module.css"
     * using regular CSS file <h1 className='error'>Regular CSS</h1> but in module CSS <h1 className={styles.success}>Module CSS</h1>
     * CSS Module better than regular CSS because child component can use regular CSS File(imported to parent component) and this leads to conflict
     but in CSS Module you can not access it at child component because it's locally scoped (see inline.js)
    [4] CSS in JS libraries

LifeCycle Methods : 
    React component when created will call built-in Methods like constructor in Class component and those built-in methods you can override them : 

    [1] Mounting : when an instance of component is being created and inserted into the DOM
        (a)constructor  
        * constructor is perfect for : initializing state or binding (this) to event handler -- do not HTTP Requests inside constructor
        
        (b) static getDerivedStateFromProps(props , state)
        * used when the state of the component depends on changes in props over time.
        * is a static method that is called just before render() method in both mounting and updating phase in React. 
        It takes updated props and the current state as arguments. 
        We have to return an object(the updated state object) or null to indicate that nothing has changed.
                      
        (c) render 
            * The only required Method
            * Do not : Change the state or interact with DOM or make AJAX Calls

        (d) componentDidMount :
            * invoked only once and immediately after a component and all it's Children components has been rendered to the DOM
            * now you can DO : interact with DOM or AJAX calls

    [2] Updating : when a component is being re-render as a result of changes to either it's props or state
        (a) static getDerivedStateFromProps 
            * same like in Mounting

        (b) shouldComponentUpdate 
            * this method decide if the component should re-render or not 
            by default all components will re-render when they recieve a props or the state changes 
            but with shouldComponentUpdate method you can prevent this default behavior by returning false
        
        (c) render 
            * same like in Mounting

        (d) getSnapshotBeforeUpdate(prevProps , prevState)
            * is invoked right before the most recently rendered output is committed to e.g. the DOM. 
            It enables your component to capture some information from the DOM (e.g. scroll position) 
            before it is potentially changed. Any value returned by this lifecycle method 
            will be passed as a parameter to componentDidUpdate().
            * Exp. of using this Method is take the position of scroll of the user inside the website
            and return this information of position and this will be a parameter to componentDidUpdate() 
            so we can use this information to scroll agin the website to the same postion before updating
            * getSnapshotBeforeUpdate will be called before componentDidUpdate even the children 
        
        (e) componentDidUpdate(prevProps , prevState, snapshot)
            * Called only once after each re-render cycle
            * can use AJAX and use prevState with new State
    
    [3] Unmounting : when a component is being removed from the DOM
        (a) componentWillUnmount 
            * invoked immediatly before a component is unmounted or destroyed
            * can be used for cancelling any network requests , removing event handlers , cancelling any subscriptions and also invalidating timers

    [4] Error Handling : when there is an Error during rendering , a LifeCycle method , in a constructor in any child component 
        * Error Boundaries are React Component that catch JS Error in their child component tree 
        * A class component becomes an Error Boundary by definig either or both of getDerivedStateFromError and componentDidCatch (see ErrorBoundary.js) 
        * Error Boundary can not catch Error in event handler
        
        (a)static getDerivedStateFromError : is used to render a fallback UI after an error is thrown 
            
        (b)componentDidCatch(error , info) : is used to log the error information

Fragments : 
    * let you group list of children elements without adding extra nodes to DOM (see fragmentDemo.js and columns.js)
    * key attribute the only attribute can be added to React.Fragment
    * the shorthand of <React.Fragment></React.Fragment> is <></> but you can not add key attribute

Pure Component (works only with class component) : 
    Diffrence between Regular Component and Pure Component : 
    - shouldComponentUpdate implement : 
        * Regular Component does not implement shouldComponentUpdate method and always return true (that's why when changing state to same value will render see (parentComp.js))
        * Pure Component implement shouldComponentUpdate method with a shallow comparison of props and state ( that's why when changing state to same value will not render see (parentComp.js) )
        note : shallow comparison ( [a] primitive types : should be same value and same data type [b] Complex Types : both should reference to the same object like arrays or objects)
        note : if the state is an array do not use for exp. push method to array because you are mutating the same array with same reference so pure component will not render it's better to return new array with new reference

memo (because pure component does not work with functional component we use memo Component):
    * export default React.memo(MemoComp) / React.memo() called higher order component (later will discuss)

ref (reference can by added to DOM element or class Component): 
    * you can create a ref object by React.createRef() in constructor and use ref attribute on HTML element to link this element to created ref
    and this element will be stored as property called current so you can get it by this.myRef.current and you can for exp. Focus on it by this.myRef.current.focus() 
    * or you can add ref attribute to class component inside parent component and access this component by this.inputComp.current see (focusInput.js)

callback ref : 
    * instead of using React.createRef() in the constructor:
    [1] we create an property called cbRef that is initially set to null. (see exp. refsDemo.js) 
    [2] create a method called setCbRef.
    [3] add ref attribute to the element and pass setCbRef method to it (now it's callback)
    [4] When the element mounts the callback ref (setCbRef method) is executed and the element will be an argument for this.setCbRef.
    note : The callback function passed to the ref attribute executes immediately upon the component mounting before componentDidMount fires so The referenced element is also guaranteed to be up to date before componentDidUpdate is executed.
    note : The stored element is directly accessible via this.cbRef (instead of stored as the .current attribute of the object created by React.createRef() or useRef()).

forward ref : 
    * a technique that forwards a ref through a component to one of its children
    * React.forwardRef(component) accept a component as a parameter and this component accept two parameter props and ref see (FRInput.js and FRParentInput.js)

Protals : 
    * root in React : in index.js you will find that we are creating a root using ReactDOM.createRoot() method
    and add the div element that we want it as root by selecting it from index.html by using document.getElementById('root') the render with root and add APP component
    
    * But protals provide a way to render a children outside the root and steps are :
    [1] create an element in index.html and give it an ID (portal-root)
    [2] import ReactDOM  from 'react-dom' inside component (PortalDemo.js)
    [3] use ReactDOM.createPortal(JSX , element) accept 2 parameters 1st is JSX and 2nd is element that you created outside the root (portal-root)

    * use case of Portals is when you add style to all root DOM element and you need another element that does not inherit these styles

    * Note : portals is not inside root element but act as a child in React DOM so event bubbling still works if you click on portal element will buuble up to parents in React root ( https://codepen.io/gaearon/pen/jGBWpE)

Higher Order Component HOC : is a pattern that takes a component as an argument and returns a new component (see ClickCounter.js , HoverCounter.js and HOC.js) 
    * if you want to add for exp. same function to two components no need two write function to each component 
    you can create a function that accept these components as parameter (original component + function ) and return a new component  
    and you can access this function from props that you added inside render method of new component

    * if you want to pass a property to ClickCounter or HoverConuter from APP.js you have to write {...this.props} inside <OriginalComponent> in HOC.js
    because you already use ClickCounter and HoverConuter when you return UpdatedComponent(HoverCounter or ClickCounter) 
    so HoverConuter or ClickCounter inside APP.js not them they are updated version after using HOC

    * you can use 2nd paramter of HOC to use for any purpose you want for exp. (we added incrementNum so you can add different num for each HoverConuter or ClickCounter by returning export default UpdatedComponent(ClickCounter , 10) ) 
    
Render Props : 
    * render prop is a technique for sharing code between React Components using a prop whose value is a function
    like RenderProps.js and then you can add property(you can name this prop render or any other name) to RenderProps component and 
    this property can be a function and this function accepts parameters and return ClickCounterTwo or HoverConuterTwo component 
    and add those paramters as property to them (now you shared them ) 
    and last step to call render property inside RenderProps.js

context : 
    * providing a way to pass data through the component tree without having to pass props down manually at every level
    (means if you have parent A and has child B and grandchild C without context you have to pass property username to A then B then C to access it from grandChild C)

    * Steps : 
        [1] create Context (see UserContext.js) : using React.createContext() Method then take from it 2 components Provider and Consumer
        [2] add Provider Component to APP Component and add property called value to it then inside Provider add ComponentA
        [3] add Consumer to GrandChild (ComponentC) and inside Consumer add function the parameter of this function is the property value that you added to Provider

    * you can add default value by adding it as parameter inside React.createContext() Method and if you didn't add Provider in APP.js 
    Consumer will search for Provider if not found will use default value

    * another steps using contextType (instead of adding consumer and then adding function and it's parameter will be the value property of Provider) : 
    we can export UserContext from UserContext.js and change ContextType of ComponentC to UserContext by (1) ComponentC.contextType = UserContext or (2) static contextType = UserContext
    then we can access value property by this.context 

    * but regular Context is better than typeContext because
    [1] typeContext works only with class component
    [2] with multiple contexts you can not use type context : 
        function content() {
            return (
                <themeContext.consumer>
                    {
                        theme => (
                            <userContext.consumer>
                                {
                                    user => (
                                        <profilepage user={user} theme={theme}></profilepage>
                                    )
                                }
                            </userContext.consumer>
                        )
                    }
                </themeContext.consumer>
            ) 
        }


HTTP : React does not do HTTP Request so we need to use another liberary with Reat (HTTP libraries like axios)

Side Effects : 
    * A React side-effect occurs when we use something that is outside the scope of React in our React components e.g. Web APIs like localStorage or HTTP-Requests or Document.title.
    * We usually manage React side effects inside the useEffect hook or LifeCycle Methods in Class Component like componentDidMount
    * when you add side effect inside React Component directly without useEffect Hook or LifeCycle Method every time the component renders 
    the side Effect will run and cause bad performance and if side effect has inside it changing state of component you will stuck in re-render infinite loop

Pure : 
    Most React components are pure functions, meaning they receive an input and produce a predictable output of JSX.
    it expects the same JSX for the same state/props regardless of how many times it renders

HOOKS : 
    * Allow you to use React features without having to write a class (EXP. state before should use class component with HOOKS no need for class component)
    * Do not work inside classes
    * Avoid the confusion of this keyword
    * Allow you to reuse stateful logic
    * Organize the logic inside a component into reusable isolated units
    * Only call Hooks at the Top Level (do not call hooks inside loops, conditions or nested functions)
    * Only call Hooks from React Functions (call them from React Functional Component not regular JS Function)

useState Hook (lets you to add state to function component) : 
    is a function from React accepts an argumet ( initial value of state) and returns 
    array of the current value of state property and a method for updating state property
    * in class component state can be only object but with useState Hook state can be anything object , array , number ,.... 

The Update Method that's returned from useState : (two options to use it) (see HookCounterTwo.js) 
    [1] setState(new state value)
    [2] setState(function accepts prevState as an argument) this is safer incase of Batching

    * Difference between set state in class and setState Hook is setState merge the object but The set state in class does not (see ClassCounterThree.js and HookCounterThree.js)
    * for EXP. we have state object {firstName:"" , lastName: ""} when you use setState({firstName : "Soliman"}) 
    will not remove lastName property and state object will be like this {firstName:"Soliman" , lastName: ""}
    but with the Update Method when you setName({firstName : "Soliman"}) will remove lastName property
    and the object will be {firstName:"Soliman"} so you need to add it manually every time by using ...name

useEffect Hook (replacment for componentDidMount , componentDidUpdate and componentWillUnmount) : 
    * useEffect(function) will excute the function (which is passed as parameter) every time the component renders
    for EXP. instead of using componentDidMount , componentDidUpdate inside UseEffectOneClass.js we use useEffect() inside UseEffectOne.js

    ** Note : because useEffect hook excute function every render cycle will cause bad performance
    so you can add second parameter to the useEffect and this second paramter is an array (Dependancy array)and you can add 
    inside this array a value and the useEffect will excute the function only if that value changes (see UseEffectOne.js) 

    ** Note : to tell useEffect hook to excute the function only once (replacment componentDidMount in MouseClass.js) add second parameter empty array (see HookMouse.js)

    ** Note : the function inside useEffect can return another function(cleanup function) and this returned function will be excuted
    when the component unmounted (see HookMouse.js) (replacment componentWillUnmount in MouseClass.js)
    useEffect built in such a way that we can return a function inside it and this return function is where the cleanup happens.
    https://www.zipy.ai/blog/understanding-react-useeffect-cleanup-function#:~:text=Cleaning%20up%20event%20listeners,-When%20the%20component&text=The%20useEffect%20hook%20can%20be,window%20object%20inside%20the%20hook.

    ** useEffect runs on every render but not props change

useContext Hook : 
    * incase of nested consumers like in (ComponentB.js) you can use useContext(UserContext) and add UserContext (which is created by react.createContext() in App.js) as parameter
    and will return value of context Provider (UserContext.Provider or ChannelContext.Provider)
    so will be easier of nested consumers

useReducer : is used for state management (alternative to useState)
    * same concept of Array.prototype.reduce
        * Array.prototype.reduce(Reducer callBackFunction , initialValue) and callBackFunction(accumulator,currentValue) and return single value
        * useReducer(Reducer callBackFunction , initialState) and callBackFunction(currentState , action) return pair of values [newState, disptach]
    
    * Steps of useReducer in CounterOne.js : 
        [1] create Variables of initialState and reducer function(state , action)
        [2] use useReducer Hook which is return pair of values (count , disptach function)
        [3] use disptach function and it's parameter is the action argument of reducer function

    * state and action (parameters of reducer function) can be objects like in CounterTwo.js

    * you can use multiple useReducer like in CounterThree.js

    * you can combine useReducer and useContext Hooks like in ComponentD.js

    * useState is mostly used when types of states are number, boolean, array , object , string. useReducer is used when types of states are nested objects and nested arrays.

react.memo : 
    * is a higher order component that's prevent the functional component to re-render if the props or stats did not change like in (Title.js or Count.js or Button.js)
    * Exp in (ParentComponent.js and Title.js , Count.js , Button.js) when using react.memo when you press button for age increment the button for salary increment will re-render
    because of two reasons : 
    [1] default behaviour of React when ParentComponent.js renders (because we changed the age state ) all it's Children will re-render (even if children props or state are the same) and to solve this problem will use react.memo
    [2] when the ParentComponent.js renders (because we changed the age state ) will create an new incrementSalary function so the props of salary button changed so the salary button component will re-render
    to solve this problem we will use useCallback Hook

useCallback Hook : 
    * a hook that will return a copy of callback function (cached Value) that only changes if one of the Dependancies has changed
    * should be used with react.memo
    * Exp in (ParentComponent.js and Title.js , Count.js , Button.js) useCallback Hook will return a copies of incrementSalary and incrementAge function 
    and those function will not created every time ParentComponent.js re-renders so props of salary button will not change when you click on age button (or vice versus)
    so salary button will not re-render

useMemo Hook : 
    * like useCallback Hook but will return a value of excuted function and will excute this function only if one of the Dependancies has changed
    * Exp in (MemoCounter.js) when MemoCounter Component renders isEven Function(contains while loop) will excute and take long time
    and MemoCounter component will re-render when you click on Count One or Two because you are changing state from incrementOne or incrementTwo Functions
    but by using useMemo Hook isEven function will be excuted only if click on Count One not two because you add counterOne in dependency array

useRef Hook : 
    * with useRef Hook you can access DOM Node directly from Functional Component.
    * same concept of using ref inside Class Component instead of using const inputRef = React.createRef() we will use useRef(null) and add inputRef to ref attribute inside DOM element
    and you can access the DOM element by inputRef.current see (FocusInput.js)
    ** Note : i tried const inputRef = React.createRef() and still works with functional Component

    * useRef Hook can be used as generic container which can hold a mutable value similar to instance property in class component see(HookTimer.js and ClassTimer.js)
    in HookTimer.js we used const interValRef = useRef() (like global variable because if we created this variable inisde useEffect we can not access it in onClick Event in Button) 
    so we created interValRef and we can access it's value by interValRef.current same concept of using interval (instance field) inside ClassTimer.js

custome Hook :
    * you can create your own custome Hook
    * custome Hook is a JS Function starts with "use"
    * custome Hook can call other Hooks if required
    * custome Hook can share Logic like HOCs(higher order Components) and Render Props
    * EXP1. useDocumentTitle is a custome Hook and we use it with DoctitleOne.js and DocTitleTwo.js
    * EXP2. useCounter is a custome Hook and we use it with CounterOnee.js and CounterTwoo.js
    * EXP3. useinput is a custome Hook and we use it with UserForm.js

Render (initial Render ) steps in React : 
    [A] Render Phase : 
        React start from Root Component Tree and move downwards and at each element invoke createElement() Method to convert JSX to React Elements and store it

    [B] Commit phase : 
        Take the React Elements from Render Phase and apply them to the DOM using React DOM Package 


Re-render Steps in React : 
    [A] Render Phase : 
        When the component needs to update the component will be flagged and React will start from Root Component Tree and move downwards till finds flagged Component 
        then React will invoke createElement() Method to convert JSX to React Elements for each flagged component and then compare previous render to new render 
        then go to Commit phase . ( if no changes between previous render and new render will not go to commit phase and will not change DOM ) 
        
        The Component can flag itself for update by calling useState setter function or useReducer dispatch function 

    [B] Commit phase : 
        Take the changes from Re-Render Phase and apply them to the DOM using React DOM Package 

** if state value is primitive : 
useState setter function : if you update to the same value of current state will not re-render (will re-render one more time then will not re-render again but if after initial render will not re-render one more time ) 
(if this is 1st re-render cycle and value is the same of initial Value the React will exit before comparing previous render to new Render
but if this is not 1st re-render and value is the same of current Value React will continue to comparing previous render to new Render and then Exit before commit phase)

useReducer dispatch function : after React 18 Update will re-render Even if the same Value

** if state value is array or object :
[1] if Object :
useState setter function : if you change the properties of the object React will not re-render
    because you are changing only properties but it's the same object with same reference 
    but if you change it to new object you changed the reference and then React will re-render (like in ObjectUseState.js )

[2] if Array :
useState setter function : same concept of object if you push values to the array you are not changing the array and still same Array and same reference
you have to change it to new Array with new reference (like in ArrayUseState.js)

useReducer dispatch function : after React 18 Update will re-render Even if the same reference but will not change UI on re-render (ObjectUseReducer.js & ArrayUseReducer.js)

Parent and Child Render behavior : 
    if Parent Re-render all Childs will re-render (default behavior of React)
    except in one case (if the value of state is the same and re-render not after initial Render cycle will re-render the parent only (only one time) ) see (parent.js & child.js and try count to 5 button)

    React render the top-level components and the other nested components within those components will not render they will be passed as props (this.props.children in class component or parameter of function component) 

    Difference between nested component and Child Component (<ChildOne/> inside ParentOne.js is Child Component but <OptimizedParentOne><ChildOne></ChildOne></OptimizedParentOne> in App.js is nested component )

    if you change the state of the component will re-render but will not re-render the child (child passed as parameter like in OptimizedParentOne.js) because React knows you can not change props 
    so for sure child component is the same and no need for re-render
    
    if you change state of grandParent Component (GrandParentOne.js) will re-render and will re-render parent(OptimizedParentOne.js) and also will re-render the grandChild (ChildOne.js) 
    because react now do not sure props of parent is the same or not because now you can change props so will re-render Child

to avoid unnecessary re-render of Child :
    [A] same Element reference : you can add child as nested component inside parent component in App.js then pass the Child as paramter (like in OptimizedParentOne.js).
    [B] React memo : is a higher order component that's prevent the functional component to re-render if the props or stats did not change (see ChildTwo.js and ParentTwo.js)
    
    ** Note : Difference between 2 options : 
    1st option works only if state of parent Changes but if props changes Child will re-render 
    2nd option Child will not re-render if props or state of parent changes


Incorrect Optimization : 

    [1] ChildThree.js (wrapped with memo) (will re-render when press name button beacause you are passing name as a prop from parent to child)
    will re-render even if you press count button in ParentThree.js because props.children is always a new reference 
    (if it's a HTML Element <strong></strong> same concept of reference in objects but if normal text same concept of primitive values will not be new reference so props will not change so ChildThree will not re-render) 
    when ParentThree.js re-render create new HTML with new reference) so you are changing the props of ChildThree every Time ParentThree.js re-render

    [2] same reason on ChildFive.js will re-render event if you press count button in ParentFour.js because prop is always a new reference (when ParentFour.js re-render create new person object or new handle function with new reference) so change props of ChildFive.js so will re-render

    [3] ChildFour.js has now Date in JSX but you are wrapping it with memo so when you press on count button in parentThree.js ChildFour.js will not re-render (because of memo) so Date will not be updated in UI (Impure component)

to Solve Incorrect Optimization you can use useMemo & useCallback Hooks (like in ParentFour.js) :
    we used useMemo(() => person, []) so we returned person object only one time because of empty Dependancy array event if ParentFour re-render person object is the same and same reference
    we used useCallback(handleClick, []) so we returned callBackFunction only one time because of empty Dependancy array event if ParentFour re-render callBackFunction is the same and same reference

Re-render behavior with Context (see ContextChildren.js & ContextParent.js): 
    React render Context Provider and then check if the Provider take a new value ( value property ) if yes will re-render Context Consumer
    but default behavior of React when Parent re-render all Childs will re-render so we have 2 options : 
    [1] React.memo : we used MemoizedChildA = React.memo(ChildA) in ContextChildren.js then ChildC only will re-render when you press on count button in ContextParent.js
    [2] same Element reference : you can add child as nested component inside parent component in App.js then pass the Child as paramter (like in ContextParent.js). 

how to create react typescript : 
    npx create-react-app react-typescript-demo --template typescript

Optional Props : 
    you can add ? to make props optional like (messageCount?: number) in Greet.tsx
    and we destructured const { messageCount = 0 } = props and added default value 0 if it's not exist in props

when you add children to component in App.tsx file you have to write the children type in component
    * children is just text in <Heading> so we added children : string in Heading.tsx
    * children is another component <Oscar><Heading></Heading></Oscar> so we added children : React.ReactNode in Oscar.tsx
    
You can add Event handler function as prop but you have to write () => void as type in component file and if we want to use event parameter : 
    * Event (Click Event) >>> event: React.MouseEvent<HTMLButtonElement> in Button.jsx 
    * Event (Input Change Event) >>> event: React.ChangeEvent<HTMLInputElement> in Input.jsx 

You can add css properties as a prop but you have to write styles: React.CSSProperties as type in component like in (Container.tsx)

Type inference means typescript is smart enough to know the type and you do not need to write it manually EXP : 
    * in LoggedIn.tsx => const [isLoggedIn, setIsLoggedIn] = useState(false) no need to write isLoggedIn : boolean 
    because typescript know it's boolean and this option called Type inference

if you want to add type to setState hook you can use <> like const [user, setUser] = useState<AuthUser | null>(null) in User.tsx
and when you try to use User.name typescript will automatically add ? like (User?.name) because you wrote <AuthUser | null> so maybe User is null (not exist)

Type assertion : 
    EXP : const [user, setUser] = useState<AuthUser>({} as AuthUser) in User.tsx 
    here you told typescript that even if user is empty object will be type AuthUser and no need to check (User?.name) if User exist or not 
    
    * and if you hover on setUser setter function will see React.setStateAction<AuthUser | null> because React infer that setter function will accept parameter
    of type AuthUser or null because you write type assertion useState<AuthUser>()

    * in Counter.tsx also if you hover on Disptach function will see React.dispatch<CounterAction>  because React infer that dispatch function will accept parameter
    of type CounterAction (dispatch's argument is useReducer's 2nd parameter = action ) and you wrote in useReducer that action:CounterAction 
    so React will infer the type

discriminated union :
    in Counter.tsx dispatch function accept parameter (action : CounterAction) but incase of reset will accept 
    action object with only type property no payload so typescript will give you an Error that action object should be two
    properties (type and payload) 
    [1] you can not use optional ? like (payload?:number) because incase of increment or decrement
    will give you an Error { count: state.count + action.payload } paylod can not be undefined
    [2] you can add payload = 0 on reset button but not the best solution
    [3] discriminated union : is the best solution you can create two different types (UpdateAction and ResetAction) and use 
    type CounterAction = UpdateAction | ResetAction now typescript will be smart enough to know which one will be used
    if you pass action parameter as an object with only one property(type) so will use ResetAction as type 
    if you pass action parameter as an object with two properties(type and payload) so will use UpdateAction as type

Context with typescript : 
    EXP1 : Box.tsx and theme.ts and ThemeContext.tsx
    EXP2 : User.tsx and UserContext.tsx

    **when creating context by (UserContext = createContext<UserContextType | null>(null)) in UserContext.tsx we are telling react 
    that the type context will be UserContextType or null so when we try to use userContext?.user?.name will put ?. after userContext
    because maybe userContext will be not exist
    so we used instead (const UserContext = createContext({} as UserContextType)) type assertion

non-null assertion operator : 
    operator tells the compiler to ignore the possibility of it being null.
    (but not recommended to use it bceause if became null will give you error and will crash the application)
    https://blog.logrocket.com/understanding-exclamation-mark-typescript/

Type predicate Function 
https://matiashernandez.dev/blog/post/what-are-type-predicates-in-typescript

useRef with typescript : 
    [1] ref for DOM Element (like in DomRef.tsx)
        * we can use null! (non-null assertion operator) instead of adding (?) in inputRef.current?.focus()
        * we added const inputRef = useRef<HTMLInputElement>(null!) because useRef() will be used in HTMLInputElement

    [2] generic container which can hold a mutable value similar to instance property (like in MutableRef.tsx)
        * here we added const interValRef = useRef<number | null>(null) number because we are assigning the id of interval to interValRef
        * we added if (interValRef.current) in stopTimer because const interValRef = useRef<number | null>(null) and 
        interValRef.current have possibility in window.clearInterval(interValRef.current) to be undefined and undefined not number or null
        so we added if (interValRef.current) in stopTimer or we can const interValRef = useRef<number | undefined>(undefined)
        

Difference between static field (or class variable or static variable) and instance field (instance variable) ?
    The static fields and methods can be accessed from the class itself 
    but Instances fields can be accessed from the instance object.

Difference between using state act as instance field (variable) or regular instance field (variable) ? 
    state act as instance variable serve different purposes. While calling setState with empty arguments will cause a render and will reflect the updated instance properties, 
    state can be used for many more features like comparing prevState and currentState in shouldComponentUpdate to decide whether you want to render or not, 
    or in lifecycle method like componentDidUpdate where you can take an action based on state change.
    state is a special instance property used by react to serve special purposes. 
    Also in setState, state updates are batched for performance reasons and state updates happen asynchronously unlike instance variable updates which happen synchronously. 
    
    A instance variable won't have these features.


class component with typescript (in counter.tsx) :
    we have to write the type of state and type of props :
    <type of props , type of state >
    export class Counter extends Component<CounterProps, CounterState> 
    * if you dont use props you can skip it by adding {} like <{} , type of state >
    * if you dont need state you can simply dont write it <CounterProps>

Component Prop with typescript (in Login.tsx , Private.tsx and Profile.tsx)
    * in Private.tsx we add Component: React.ComponentType<ProfileProps> React.ComponentType is type of react component and <ProfileProps> is type of props of this component
    * in Private.tsx we used Aliasing destructured variables (look there)

Generics with typescript and react (in List.tsx): 
    we should write <T extends > because it's not like Generic in function or Generic in classes (look at TS Elzero) you write <T> and then write the type when 
    you invoke the the function ( fnc<number>(5) ) or when you create instance ( new Obj<string>()) 
    but in react you are not invoking a function or creating instance you are adding the component to APP.tsx so you have to write <T extends theType> inside the component itself
    * <T extends String> 
    * <T extends Number> 
    * <T extends {}> means will accept anything like type any
    * <T extends { id: number }> means will accept object but this object must has property call id and it's value is number 

Restriction with typescript (in RandomNumber.tsx) :
    here we have 4 properties 
    [1] value : common with all possibilities
    [2] isPositive 
    [3] isNegative
    [4] isZero
    and we want to add 2 or 3 or 4 so we created 3 types and inside each type one is :boolean and the rest are ?: never
    then we add type RandomNumberProps = PositiveNumber | NegativeNumber | Zero and now typescript will be smart enough to know which one will be used 
    if you add isPositive typescript will use PositiveNumber 
    if you add isPositive and isNegative as properties inside APP.tsx typescript will throw an Error 

template literals with typescript (in Toast.tsx):
    * instead of writing 
    type ToastProps = {
        position : "left-center" | "left-top" | "left-bottom" | "center" | "center-top" | "center-bottom" | "right-center" | "right-top" | "right-bottom"
    }
    
    * we can write and react qill be smart enough to combine all possibilities
    type ToastProps = {
        position: `${HorizontalPosition}-${VerticalPosition}`
    }

    * but we have problem there is possibility center-center and we want it center only so we used Exclude 'center-center' and the add or center ( | "center")
    type ToastProps = {
        position: Exclude<`${HorizontalPosition}-${VerticalPosition}`, 'center-center'> | 'center'
    }

wrapping HTML Element (in Button.tsx and Input.tsx) : 
    * if you want to add types of all properties of an HTML Element you can use React.ComponentProps<'button'>
    * in Button.tsx we added custom property called variant so we have to write it's type so we added variant: 'primary' | 'secondary'
    * in Button.tsx we added type children : string but when you hover on children you will see string | React.ComponentProps
    and if you want to be only string you can use Omit keyword like Omit<React.ComponentProps<'button'>, 'children'> 
    and Omit means the use types (React.ComponentProps) of all properties except children
    * we can use ... to add rest of properties like ( {...rest})

Extracting a Components Prop Types (in CustomComponents.tsx) : 
    * you can use types from another Component (Greet.tsx) and use it inside CustomComponents.tsx by adding props: React.ComponentProps<typeof Greet>

Polymorphic Component (in Text.tsx) :
    * we added Omit<React.ComponentProps<E>, keyof TextOwnProps<E>> 
    because we do not want conflict between the types of textOwnProps and types of all default props of React.ComponentProps


------------------------------

- Redux : is a predictable state container for JS Apps.
- React-Redux : is a library that provides bindings to use React and Redux together in an application.

* React-Redux helps you to manage state and use it for different component because state container will be outside component tree
so no need to share state between parent and childs or grand childs
* useContext + useReducer can solve this problem also but React-Redux is more useful with big projects

Steps To create Redux project : 
[1] npm init --yes
[2] npm install redux

* JS doesn’t have access to change state in Redux state container directly it should tell mediator ( Reducer ) 
what changes to the state (object returned according to action.type in reducer function) and the mediator ( Reducer ) will inform the Store the required changes on the state 

* Reducer accepts two parameters ( previous state , action )  and return the new state to the application 


Action : 
* plain JS object 
* Must have type property ( string )

Action creator : is a function that return an action object


Redux Store : 
* allow access to state by getState() method
* Allow state to be updated by dispatch(action)
* Register listener via subscribe(listener) this is the link between store and JS application ( will execute listener function each time state in redux store changes) 
* You can unregister to the store by calling the function returned by subscribe(listener) 

To create Redux store 
[1] Const redux = require(‘redux’)
[2] const store = redux.createStore(reducer) 
[3] const unsubscribe = store.subscribe(listener)
[4] store.dispatch(action creator)
[5] unsubsrcibe() 


Combine reducers :
You can use one reducer for multiple actions but for large projects it’s better to use multiple reducers with multiple actions 

Steps : 
[1] const rootReducer =redux.combinereducers({cake: cakeReducer , iceCream : iceCreamReducer })

Middleware : 
Provides a 3rd party extension point between dispatching an action and the moment it reaches the reducer 
steps : 
[1] const applyMiddleware = redux.applyMiddleware
[2] const store = createStore(reducer , applyMiddleware(middleware Func like logger or thunk))

* To install Logger ( npm install redux-logger ) ( will show you what happend , will show you each step at console)
Steps : 
[1] const reduxLogger = require(“redux-logger”)
[2] const logger = reduxLogger.createLogger()
[3] const store = redux.configureStore(rootReducer , reduxLogger.applyMiddleware(logger))

* To install Redux-Thunk ( npm install redux-thunk) (to allow action creator to return a function instead of action object and this function accept dispatch as parameter)
Steps : 
[1] const thunkMiddleware = require(“redux-thunk).default
[3] const store = redux.configureStore(rootReducer , redux.applyMiddleware(thunkMiddleware))
** note ( in userActions.js) : disptach(fetchUsers()) when this line get excuted then redux Middleware checks what it return , if it's object then excute as always 
if it returns a function then pass dispatch as an argument to that function.

* Steps to create react redux project: 
[1] npx create-react-app <project name>
[2] npm install redux react-redux

* The connect() function connects a React component to a Redux store.
    steps of connect: 
    [1] mapStateToProps allow access to state like getState() method 
    [2] mapDispatchToProps Allow state to be updated like dispatch(action)
    [3] Connect method from redux connects your React component to store and subscribe it to state changes

* The mapStateToProps and mapDispatchToProps deals with your Redux store’s state and dispatch, respectively. state and dispatch will be supplied to your mapStateToProps or mapDispatchToProps functions as the first argument.
    - mapStateToProps accept 2nd parameter (ownProps) so you can access props of component like in (ItemContainer.js) in this EXP. we can use ItemContainer for both cake and ice cream depends on props passed to this component
    - mapDispatchToProps accept 2nd parameter (ownProps) so you can access props of component like in (ItemContainer.js) in this EXP. we can use ItemContainer for both cake and ice cream depends on props passed to this component

* useSelector hook : is a function that accepts argument another function and the parameter of this function is state ( like mapStateToProps ) and useSelector hook returns what ever it’s argument function returns 
* UseDispatch hook : is a function that returns a reference to dispatch function 

* Steps of Middleware logger : 
    [1] npm i redux-logger
    [2] import { createStore , applyMiddleware} from 'redux'
    [3] const store = createStore(rootReducer , applyMiddleware(logger)) in rootReducer.js

* Steps of redux devtools extension to the Browser : 
    [1] npm install --save -redux-devtools-extension
    [2] import { composeWithDevTools } from 'redux-devtools-extension'
    [3] const store = createStore(rootReducer ,composeWithDevTools( applyMiddleware(logger)))

* in NewCakeContainer.js we added input html element to ask customer how many cakes he wants to buy 
then add the number as argument to action creator function then this number will be added as payload property in action object

* Steps of Async in react-redux in (userContainer.js): 
    [1] you need axios (for Async API calls) 
    [2] you need Thunk Middleware (to allow action creator to return a function instead of action object and this function accept dispatch as parameter)
    ** you can install both packages by ( npm install axios redux-thunk )
    [3] you need to use useEffect hook with empty array as Dependancy array
    
* conclusion how react-redux works : 
    [1] create component inside components folder ( mapStateToProps & mapDispatchToProps with connect like in CakeContainer) or (useSelector and UseDispatch Hooks)
    [2] create Actions , Types and Reducer inside redux folder  
    [3] create rootReducer.js if we want to combine more than one Reducer
    [4] create store.js to create store and add applyMiddleware if needed
    [5] create index.js if we want to import from ../redux folder without write specific location like import { buyCake, buyIceCream } from '../redux'
    [6] wrap the the main component in App.js with Provider 
    ** incase of Async we need to add thunk Middleware in store.js and use useEffect Hook in component and make async calls in Actions.js


---------------------------------

*React router library : is fully featured client and server side routing library for React
    -Helps to create and navigate between different URLs to make up your web application
    -Provides unique URLs for different components
    In the app and makes the UI easily shareable with other users

*Steps to create React-router app : 
    [1] create react app : 
    npx create-react-app react-router-demo
    [2] add react router liberty: 
    yarn add react-router-dom@6
    or 
    npm install react-router-dom@6

*Steps for configuring route in react: 
    [1] import BrowserRouter inside index.js :
    Import { BrowserRouter } from ‘react-router-dom’ 
    [2] wrap app with BrowserRouter inside index.js
    [3] import Routes and Route inside App.js: 
    Import { Routes , Route } from ‘react-router-dom’ 
    [4] add two props to Route component ( path & element) 
    <Route path=‘about’ element={<Abou/t>}/>

*Steps for creating navbar : 
    [1] Create Navbar component and inside it import Link or NavLink component:
    Import { Link }  from ‘react-router-dom’ 
    Import { NavLink }  from ‘react-router-dom’ 
    [2] if you want to add styles add it inside index.css
    [3] add prop (to) Link component : 
    <Link to=‘/about’>About</Link> 

*Difference between Link and NavLink 
    When you press NavLink will add class (active) 
    To the clicked link and then you can is this in css styling ( inside index.css ) 
    or use style property in NavLink and inside this style prop add function which accepts isActive as parameter 
    and returns object contains the css styles

* The useNavigate hook returns a function (navigate function) that lets you navigate programmatically(navigates to the other routers using the push or replace methods)
    note : If using replace: true (as second parameter in navigate function), the navigation will replace the current entry in the history stack instead of adding a new one (by using push method).
    see OrderSummary.js and Home.js

* if the user try to write wrong route you can add <Route path='*' element={<NoMatch/>}/> in App.js to route the user to NoMatch page
 - note : path='*' means any path not exist in Routes

* nested Routes :  you can easily nest <Route><Route/></Route> see App.js and Products.js 
    - note : do not forget to import { Link, Outlet } from 'react-router-dom' and use Outlet component inside Products.js
    An <Outlet> should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered

* index Route : if you want to render child nested component automatically when parent render you can use 
    <Route index element={<FeaturedProducts/>}/> with index instead of path prop now when go to /products will 
    render product parent and FeaturedProducts child and url will be /products not /products/feature
    - note : Difference between adding <Route path="/users/admin" element /> and <Route path="user" element><Route path="admin" element/></Route>
    is nested child will render under parent so on webpage you will see both parent and child 
    but incase path="/users/admin" you will see only admin page without users page
    
* Dynamic Route : ":" colon is used to make the route dynamic and the parameters can be accessed using the name "userId" (by using useParam hook )as provided in the route path after colon.
    see Users.js , 

* useParam Hook see(UserDetails.js): 
    [1] import { useParams } from 'react-router-dom'
    [2] useParams() returns object contains dynamic Route ( ":" colon )
    [3] you can destructuring it const { userId } = useParams()

* useSearchParams Hook see(Users.js) : 
    [1] import { useSearchParams } from 'react-router-dom'
    [2] const [searchParams, setSearchParams] = useSearchParams() ( same concept of useState Hook)
    note : setSearchParams({filter : active}) will add search param filter=active to url 
    and you can check the if the url has a search param by using searchParams.get("filter") 

* Relative Links see(Products.js) : 
    <Link to='featured'>Featured</Link>
    here if we write to='/featured' the link will be from Root not from the current URL

* Lazy Loading see(App.js) : 
    <Suspense> component that lets you “wait” for some code to load 
    and you can add component (fallback='component') or just string (fallback='Loading...') that will be shown to webpage while we’re waiting
    [1] import React from 'react'
    [2] const LazyAbout = React.lazy(() => import('./components/About'))
    [3] <React.Suspense fallback='Loading...'><LazyAbout /></React.Suspense>
    * note : to understand lazy (https://mikeguoynes.medium.com/the-ultimate-guide-to-react-lazy-loading-4cacd8bd3cf0)

* Authentication and protected Routes
    https://youtu.be/X8eAbu1RWZ4
    -note : A <Navigate> element changes the current location when it is rendered. It's a component wrapper around useNavigate, and accepts all the same arguments as props.
    Having a component-based version of the useNavigate hook makes it easier to use this feature in a React.Component subclass where hooks are not able to be used.

---------------------------


*Steps to create React-table app : 
    [1] create react app : 
    npx create-react-app react-table-demo
    [2] add react table liberty: 
    yarn add react-table
    or 
    npm install react-table

* Steps to create basic table (BasicTable.js , MOCK_DATA.json , columns.js , table.css) : 
    [1] Get the date you want to display 
        (to create MOC-data (JSON File) use https://mockaroo.com/)
    [2] Define the Columns for you table ( in columns.js)
        - Header : your custom name of column Header
        - Footer : your custom name of column Footer
        - Accessor : the name of column inside JSON file
        * You can choose what columns you want to extract from JSON file you should not extract all columns from JSON file
        * useMemo hook to ensure data doesn’t recreated every render
        If we didn't use React.useMemo, the table would think it was receiving new data on every render and attempt to recalculate a lot of logic every single time. Not cool!
    [3] Use the data and columns defined to create a table instance 
        -using useTable Hook from react-table (in BasicTable.js )
    [4] Define a basic table structure using plain HTML
        - in BasicTable.js
    [5] Use the table instance created in step 3 to bring life to the HTML defined in step 4 
        - in BasicTable.js
    [6] Include the desired CSS
        - in table.css

* Header Groups : instead of accessor : "" use column : [] in (columns.js)

* Sorting (in SortingTable.js): 
    useSortBy hook : you can add it as 2nd argument to useTable hook so will add sorting feature to the table
    now you can pass column.getSortByToggleProps() as an argument to ...column.getHeaderProps() in <th> inside <thead> so will add props related to sorting features on this column 

* Formatting : 
    - react table needs a proper date format ( ISO ) to support sorting features 
    JSON file has data format ( ISO )
    but we can change UI Format (dd/mm/yyyy) to user after Sorting

    -To format data in column you can : 
        Add cell after header , footer and accessor in column.js 
        - Cell is function accepts alot of arguments but we needs only value 
        - Cell function returns format(new Date(value) , dd/mm/yyyy) 
        - 1st argument we used new Date because in JSON file value is just a string and we want convert it to date
        - 2nd argument of format function is the new format that we want the value changes to it 

    * note : 
        To install date package :
        yarn add date-fns
        Or 
        Npm install date-fns


 * Filtering (in FilteringTable.js) : 
    [1] Global filter : for all columns
        - useGlobalFilter hook : you can add it as 2nd argument to useTable hook so you can destructuring state and setGlobalFilter from useTable hook  then we can destructuring globalFilter from state
        - Add GlobalFilter component from GlobalFilter.js and add globalFilter and setGlobalFilter as props to this component 
    [2] Column filter : for specific column
        - useFilters hook : you can add it as 2nd argument to useTable hook 
        - Add ColumnFilter component (Filter: ColumnFilter) to every column in columns.js
        - column.render('Filter') in FilteringTable.js means will render ColumnFilter component ( from columns.js)

    * note : if you do not need to add (Filter: ColumnFilter) to every column you can use defaultColumn (dont forget to add it as an argument to useTable hook)will add it automatically to each column
    * useAsyncDebounce : incase of big data for better performance recommended to use useAsyncDebounce hook 
    will filter every 1 sec not every time to type a letter 
        - import { useAsyncDebounce } from 'react-table'
        - const [value, setValue] = useState(filter)
        - const onChange = useAsyncDebounce(value => {setFilter(value || undefined)}, 1000)


 * Pagination (in PaginationTable.js) :
    - usePagination : you can add it as 2nd argument to useTable hook so you can destructuring (
    page ,
    nextPage,
    previousPage,
    canPreviousPage,(Boolean value true if not first page and can go back false if first page)  
    canNextPage,(Boolean value true if not last page and can go forward false if last page)
    pageOptions, (can get number of pages by pageOptions.length)
    state, (then we can destructuring pageIndex, pageSize from state)
    gotoPage,
    pageCount,
    setPageSize,
    )

    * note : if we want to start page at specific page add this (initialState: { pageIndex: 2 }) as an argument to useTable Hook
    * note : if we want to change page size we can use setPageSize function and destructuring pageSize from state

* Row Selection :
    - useRowSelect hook : you can add it as 2nd argument to useTable hook so you can destructure selectedFlatRows
    - add arrow function to return array of selected Rows

* Column Order (in ColumnOrder.js) :
    - useColumnOrder hook : you can add it as 2nd argument to useTable hook so you can destructure setColumnOrder method from the useTable Hook
    then you can use setColumnOrder method which accepts array of column (accessor) and will change the order of table like order of accessors in this array

* Column Hiding (in ColumnHiding.js) : 
    - you can destructure (allColumns,getToggleHideAllColumnsProps) from useTable Hook directly no need to add another hook as 2nd argument
    - add getToggleHideAllColumnsProps if you want to hide all columns
    - add column.getToggleHiddenProps() if you want to hide one column only

* Sticky Columns  (in StickyTable.js):
    - install package ( npm i react-table-sticky )
    - install package ( npm i styled-components )
    - useBlockLayout, useSticky hooks : you can add them as 2nd argument to useTable hook
    - in columns.js add sticky: 'left' to the desired column

-----------------------

* Storybook : is an isolated development environment and playground for UI Component ( create component independently ) 
when you work with a team and you want to try and see component away from your project or you want to show it to a client
* Note : better to watch Videos not explained here well .
 
* Install storybook package: 
- npx create-react-app react-storybook-v6
- npx sb init

* in Button.stories.js export default = { title : "Button" , component : Button } 
title is the name of story will be shown on the left side , component Button from Button.js

* In main.js in .storybook folder there is *.stories.@(js|jsx|ts|tsx) that means will search for any file called .stories.js 
and will search inside this file for default export and named exports and run them so we don’t add button component to App.js


* You can change story name like in ( Input.stories.js) Small.storyName = “Small Input”

* If you want to sort stories alphabetically you can copy options object from stories docs and paste it in preview.js .storybook folder 

* You can merge stories in one story ( story within story ) like in ( Subscription.stories.js ) import Primary from input.stories and Large from Button.stories to Subsriptions.Stories.js

* Args in(Button.stories.js): 
    - Args can be used to dynamically change props, slots, styles, inputs, etc. It allows Storybook and its addons to live edit components
    - When an arg’s value changes, the component re-renders, allowing you to interact with components in Storybook’s UI via addons that affect args.
    - The args object can be defined at the story story level or component level ( in export default and will be applied to all stories components but if story component has same property will override it ) or global level

* Decorator : 
    for EXP. to center button without decorator:
        [1] Create center.css and center.js
        [2] wrap every story button with <Center></Center>
    with decorator :
        write this (decorators: [story => <Center>{story()}</Center>],) to default export in Button.stories.js 
        and will wrap every story with <Center></Center> 

        * note : every entry inside array of decorators is a function whichs accept story as an argument
        * note : addDecorator no longer supported in V6 or V7

    to add global decorators : 
        decorators: [Story => (<Center><Story/></Center>)] in preview.js

* Theming : 
    - install Chakra UI Packages : npm i @chakra-ui/react @emotion/react @emotion/styled framer-motion
    - same concept of decorators you wrap stories with theme (like wrap stories with <Center></Center> in Button.stories.js)
    to add global decorators in preview.js ( in V6): 
        decorators: [(Story) => (
                <ThemeProvider theme={theme}>
                    <CSSReset />
                    <Box m='4'>
                    <Story />
                    </Box>
                </ThemeProvider>
                )] 
                

    * note : <Box m="4"> to add margin to the button    
             <CSSReset/> to add CSS from Chakra UI Packages

* Addon : 
    * Controls : ( by default in V7 ) be sure that you are using arg (const Template =  args => <Button {...args} /> in ChakraButton.stories.js) without args controls addon will not work
    * Actions : ( by default in V7 ) Log user action and work really well with args mechanism for EXP. onClick Action we added ({ onClick: { action: 'clicked' } } to argTypes in in ChakraButton.stories.js)
    * Docs : ( by default in V7 ) in V6 was a tab in toolbar but in V7 is a seperate file and if you need to add it be sure to write (docs: {autodocs: true}) in main.js 
    * viewport :(by default in V7) will add icons to toolbar 
        - if you want to add more options of viewport like more mobile phones steps :
            [1] import {INITIAL_VIEWPORTS} from '@storybook/addon-viewport'in preview.js
            [2] viewport: {viewports: INITIAL_VIEWPORTS,} in parameters in preview.js
    * Console : not supported yet in V7
    * Knobs : supported in V7 
        steps : 
            [1] install Knobs package ( npm install @storybook/addon-knobs --dev )
            [2] add "@storybook/addon-knobs" in main.js
            [3] add import { withKnobs } from '@storybook/addon-knobs'; and add withKnobs to Decorators
            [4] add import { text, boolean } from '@storybook/addon-knobs' in story
        - note : but when disable button you can not see stop sign like in V5 but still diabled no problem 
    * A11y : Test component compliance with web accessibility standards
        steps : 
        [1] install a11 package (npm i -D @storybook/addon-a11y)
        [2] add "@storybook/addon-a11y" in main.js

* Environment Variable : 
    [1] STORYBOOK_ in package.json file in scripts ("storybook": "STORYBOOK_THEME=dark && storybook dev -p 6006",)
    [2] access it by (process.env.STORYBOOK_THEME)
    * note in window add (set STORYBOOK_THEME=dark &&) in mac without (set and &&)

--------------------------

* Formik : is a small library helps you to 
- Handle form data
- Validation 
- Visual feedback with error messages 
- Form submission 

* install formik package : 
npm i formik

* useFormik hook (in OldYoutubeFormik.js): is a function thats return a formik object has proberties and methods like (values , initialValues , handleChange ,...) 
and accepts argument object and this object can has  properties like  :
[1] intialValues : and value of this property is an object and properties of this object should be the same name attribute in input element 
[2] onSubmit : and value of this property is a function which accept form state object (formik.values )  as an argument and this function automatically executes once you press on Submit Button
[3] validate : and value of this property is a function which accept form state object (formik.values )  as an argument and return error object which change errors proberty inside formik object

* useFormik hook will return an object which is has handleChange method (formik.handleChange() or formik.handleSubmit() ) and value (formik.values) .  Like setState and state in useState Hook 

- note : formik.handleSubmit() will invoke onSubmit function inside the argument object of useFormik hook and will stop refresh the page automatically when press submit button 

- note : onBlur={formik.handleBlur} will add proberty (name of property is the name of element and the value is boolean true if you blur inside input element) to formik.touched 
    then we can use formik.touched.name or email or channel to check if you clicked inside this input element or not
    so you will validate only this input element not all input elements

* Yup liberary : liberary to validate form 
    to install : npm i Yup

* instead of adding [ onChange={formik.handleChange} onBlur={formik.handleBlur} value={formik.values.name}] to each input element in Form 
we can add {...formik.getFieldProps("name")} (argument is the value of name attribute) and will add onChange , onBlur and value attribute automatically
in Video 12 in React Formik tutorial

* Formik component is a substitute for useFormik hook and steps are (in YoutubeFrom.js) : 
[1] import Formik instead of useFormik
[2] wrap the entire form with Formik component <Formik></Formik> 
[3] add the arguments we added before to useFormik hook () as attributes to Formik Component 

* Form component instead of form element (in YoutubeForm.js) : 
[1] import {Form} form “formik”
[2] add Form component instead of <form></form> element
[3] remove onSubmit event prop because Form component will add it automatically 

* Field component instead of input element (in YoutubeForm.js) : 
[1] import {Field} form “formik”
[2] add Field component instead of <input></input> element
[3] remove {...formik.getFieldProps("email")} because Field component will add it automatically 


* ErrorMessage component instead of {formik.errors.email && formik.touched.email? (<div className='error'>{formik.errors.email}</div>) : null} (in YoutubeForm.js) : 
[1] import {ErrorMessage} form “formik”
[2] add ErrorMessage component and will render only when the input element is visited and there is an Error
[3] add name property (same like name proberty in Field Component which is also the same name attribute in input element in OldYoutubeForm.js )


* Field component render as input element but if you want Field component to render as text area you should add (as=‘textarea’ or component =‘textarea) prop to it 

* Render Props :
    In YoutubeForm.js you can easily add Field component and will render as input element but we have another option 
    to add function as a children to this Field component and this function returns input element ( but you have to link to to formik by add {...field} or {...form.getFieldProps("address")})
    This function accepts props and this props object has (field , form , meta ) properties : 
        [1] field prop : values of this prop is object of ( name , onBlur , onChange and value ) to help you to manage state 
        [2] form prop : values of this prop is the same formik object that return from useFormik hook 
        [3] meta prop : gives you information if field visited or not , error exists or not and value ( used to render error messages ) 

* ErrorMessage render text not html element to force ErrorMessage to render html element instead of just rendering a text : 
    [1] add  component=‘div’ prop 
    Or 
    [2] add component={TextError} * TextError is a component ( TextError.js ) 
    Or 
    [3] Render props : Children of ErrorMessage will be a function and parameter of this function is the error message text : 
    <ErrorMessage name='email'>{error => <div className='error'>{error}</div>}</ErrorMessage>

* Nested Object: 
    steps :
        [1] add nested object to initialValue 
        [2] in Field Component add name='social.facebook' instead of name='facebook'

* Arrays (): 
    steps :
        [1] add the array to initialValue (phoneNumbers: ['', '']) so will be only 2 fields if you want to add or remove field dynamically use FieldArray component
        [2] in Field Components add name="phoneNumbers[0]" and name="phoneNumbers[1]"

* FieldArray (will give you dynamic array - you can add or remove to phNumber array ): 
    steps : 
        [1] import FieldArray from 'formik'
        [2] add the array to initialValue (phNumbers: [""])
        [3] in FieldArray add name="phNumber"
        [4] use Render Props pattern ( children is a function and inside this function will accept fieldArrayProps as parameter ( code inside FieldArray parent Component is return props.children({form , remove , push}) ) 
            and destructure form , remove , push from fieldArrayProps then will destructure values from form then will destructure phNumbers array from values ) 
        [5] map on phNumbers array to render Field Component and you can add more element to phNumbers array using push method (that will render more Field component) 
            and you can remove element from phNumbers array (that will remove Field Component)

* Field Component vs FastField (address vs address2 fields in YoutubeForm.js): 
    * Any changes to form ( like typing inside Field input component will render all Field Components in the form to re-render ) 
    FastField Component will solve this problem will re-render FastField component only when you type in it not when you type in any other Field


* When Validation runs in formik : 
    [1] change event ( when you type inside field input component)  you can stop validation on change event by adding validateOnChange={false} as a prop to Formik 

    [2] blur event ( when you click inside field input component and then click outside ) you can stop validation on blur event by adding validateOnBlur={false} as a prop to Formik 

    [3] submit the form (if the validation not ok on submit handler will not executed ) 

* Field level Validation (for specific Field) : 
    - before in OldYoutubeForm.js we used two ways for validation [1] validate [2] validateSchema Yup liberary
    and both of validations ways are top level whichs means can validate all Field from validate function or validateSchema object
    - steps for Field level Validation : 
        [1] define validate function (like validate function in top level validation ... the function (validateComments) accept value of comments Field as parameter )
        [2] add validate property to comments Field and assign validateComments function to this prop 

* Manually triger validation : 
    [1] you needs to use render props pattern on entire From : children of Formik Component is a function whichs accept 
    formik object as parameter ( with formik object we can control manual triger of validation) values of this parameter is the same formik object that return from useFormik hook and also same value of form object in render props in address field
    [2] add onClick event and the function is formik.validateField() ... empty paramter means will validate all field (or use formik.validateForm()) or you can write which field you want to validate 
        (but also will not give you the Error because we have 2 conditions to give you error 1st condition is didn't write anything in Field and 2nd condition is touching the Field (click inside and then click outside))
    [3] add onClick event and the function is formik.setTouched() ... here you should write which fields you want to set as touched fields empty parameter not allowed
        (now will give you the Error)
        (or use formik.setFieldTouched("comments") and add name of field as parameter)

* How to Stop Submit : [1] when form is invalid [2] during submitting process
    [1] when form is invalid :
        (a) formik.isValid : readonly prop true if error object is empty 
        (b) add disabled={!formik.isValid} to submit button so the button will be disabled when form is invalid
        - note : if you want to disable the submit button once page mount you can add validateOnMount prop to Formik Field
        - formik.dirty : boolean value prop true if you change a value of any field from initail values (not blur should type inisde the field and change the value)

    [2] during submitting process (means when you press on submit we want to disable submit button till submition process to server finish then we can submit again to prevent double submittion at the same time)
        (a) formik.isSubmitting : boolean value true if submission is in process
        (b) disabled={formik.isSubmitting} to disable the button during submission process
        - note formik does not know when the server respond so you have to return formik.isSubmitting back to false by (submitProps.setSubmitting(false)) (submitProps is a 2nd argument in onSubmit Method)


* Load saved Data as initial values of the From : 
    [1] import {useState} from 'react' 
    [2] destructure const [formValues, setFormValues] = useState(null) then initialValues={formValues || initialValues}
    [3] create savedData object (that set values of the Form using setFormValues when click load button)
    [4] add enableReinitialize prop to Formik Component to enables the form to change initial values after initialized once and state changed (formValues)
    [5] add button load data and onClick event and inside this event setFormValues(savedValues) (to simulate API Call)

* Reset Data in the Form : 
    [1] add reset button to the form
    [2] reset the form after submiting by (submitProps.resetForm() in onSubmit method)

* formik videos end at video 30 ... from video 31 we are building an Example and use what we learned

* ChakraInput library in(chakraInput.js) to take care of styling: 
    -Form control component has isInvalid prop if false will not render FormErrorMessage component 
    -Benefits of using ChakraInput Library is no need to write css or create TextError.js and pass it as component prop inside ErrorMessage 

-----------------------------
Benefits of React styled component : 
* Automatic critical CSS ( inject css styling only to the components will render )
* No class name ( if you have two css files maybe will one will override the other if you use same class name like styles.css and app.css ) 
* Easier deletion on css style ( because each css style is linked to specific component so when you delete a component will delete automatically it’s css style ) 
* Dynamic CSS styling (means now css style can be different according to props of component )
* Painless maintenance 
* Automatic vendor prefixing ( no need to write different vendor prefixes to be compatible with different browsers this library will handle this ) 

npm install styled-components

* Steps ( like in Button.styles.js ) : 
[1] import styled from "styled-components"
[2] const StyledButton = styled.button`` (inside template literal add css styles)
[3] you can use StyledButton Component as button with added css styles

Extending styles : you can reuse styles of one component and add extra styles to it ( like in Button.styles.js …. Const FancyButton = styled(styledButton) this means FancyButton will take styles of styledButton and then you can add extra style like linear-gradient)

Dynamic CSS : when you use a function inside Es6 template string this function will accept component prop as an argument ( like in Button.styles.js ) 

Pseudo classes : 
Add (&:hover ) ( like in Button.styles.js ) 

Passed props to be element attributes :
When you add type=‘submit’ to StyledButton will be passed automatically to button element  ( like in Button.styles.js ) 

Adding attributes: instead of adding props to every component you can add attribute to component by using attrs constructor and this constructor accepts object or function : 
[1] object (has the attribute ) as argument 
[2] accept a function which is returns an object (has the attribute ) and this function accepts props as an argument ( like in Button.styles.js ) 
* note : we use function 
if we need to get other props from the component

Animation : 
Import { keyframes } from ‘styled-component’
and you can assign this keyframes to variable and then use this variable to animation inside component ( like AnimatedLogo component in Button.styles.js )

Theme : 
[1] Import { ThemeProvider } from ‘styled-component’
[2] wrap all jsx in App.js with ThemeProvider
[3] add theme prop 
Now you can access theme prop from any component under ThemeProvider

createGlobalStyle : There are times where you want to style your React application globally and not each component individually. 
For this, we can make use of the createGlobalStyle API and the component created by createGlobalStyle ( GlobalStyle ) is under ThemeProvider so has access also to theme 



---------------------
* Material UI : is an open-source React component library that implements Google's Material Design

To install react app with typescript: 
npx create-react-app react-mui-demo --template typescript 

To install mui library: 
npm install @mui/material @emotion/react @emotion/styled

* Typography: 

[1] Import { Typography } from ‘mui/matrial’

[2] add variant prop to Typography component to render different HTML Elements with specific css styles you can check want you can type to variant pro from this link (section typography) 
https://mui.com/material-ui/customization/default-theme/

- note : if you want to take default css styles from material ui default theme but you want to render different html element you can add variant prop for styles and component prop for html element ( like in h4 element in MuiTypography.tsx) 
- gutterbottom prop to add bottom margin to the element and depends on variant if variant is h1 will have bigger margin than h6 

* Button  ( like in MuiButton.tsx): 
- variant text : (no need for user attention ) used for exp. in footer button and see more buttons
- Variant contained: (need for user attention ) used for exp. Login or register buttons 
- Variant outlined: ( in between contained and text we need attention but not too much ) used for exp. Cancel or go back buttons 
- Stack : is a wrapper component than you can wrap buttons and you can add props like spacing and direction 
- If you add href prop to button will render <a> 
- You can add color prop check this link ( section palette) https://mui.com/material-ui/customization/default-theme/
- You can add size prop to button component 
- You can add display prop ( default is flex ) 
- To install icon package ( npm install @mui/icons-material ) 
- You can search for the icons from this link ( https://mui.com/material-ui/material-icons/ ) and then copy the import line and use it by adding startIcon ( before the text ) or EndIcon (after the text ) prop ( startIcon={<SendIcon/>} )
- If you want to add icon only without text use IconButton component as a wrapper to <SendIcon/> and add aria-label=‘send’ prop ( for accessibility reasons ) to  IconButton component —— color and size props can be used also in IconButton component 
- disableElevation prop to disable shadow on the button
- disableRipple prop to disable ripple effect when you click on the button

* ButtonGroup component ( like in MuiButton.tsx): 
- if you want to create group of buttons beside each others better to wrap buttons components with ButtonGroup component 
- add variant prop ( or any prop ) to ButtonGroup component not to buttons component 
- Orientation prop vertical to render buttons vertically 
- Arial-label prop for accessibility 
- note : UI of ButtonGroup component better than Stack component

* ToggleButtonGroup ( like in MuiButton.tsx) : 
- onChange event : 2nd argument of onChange event is values of value prop of ToggleButton Component ( single value if you add exclusive prop if not will be array of values)
- exclusive prop : if you want toggle only one button not selecting multiple buttons

* TextField ( in MuiTextField.tsx) :  
- helper prop : text below text field
- Required prop : will add * to text field 
- InputProps prop : you can make the text field read only by adding InputProps=‘{ readonly : true }’ 
- InputProps prop : you can add InputAdornment component inside field text by add InputProps=‘{ startAdornment : <InputAdornment position=‘start’ >$<\InputAdornment>  }’  or endAdornment ( for exp. Will add $ before amount of money in text field ) 
- You can add another props like : variant , type , label , color , size , disabled , error (for validation  )

* Select ( in MuiSelect.tsx ) : if you want to create select from Mui first import Box and MenueItem components and wrap MenueItem and TextField components with Box Component 
- width prop in box component : to add width to select element but you have to add fullWidth prop to TextField component 
- SelectProps prop : if you want to select multiple options add SelectProps prop to TextField Component like SelectProps={{multiple: true }} 

* Radio button ( in MuiRadioButton.tsx) : 
- FormControl component: is the wrapper for RadioGroup and FormLabel components 
- RadioGroup component: is a wrapper for FormControlLabel Components and you link it with FormLabel component by using id prop in FormLabel and aria-labelledby in RadioGroup. 
- FormControlLabel Component: accepts control prop ( control={<Radio/>} ) , value prop and label prop 
- FormHelperText : to display error message

* CheckBox (in MuiCheckbox.tsx) : 
- FormControlLabel Component: accepts control prop ( control={<CheckBox/>} )  and label prop 
- CheckBox component : accepts checked prop ,  icon and checked icon props 
- If you want group use same technique of Radio button ( FormControl is a wrapper for FormLabel and FormGroup components then FormGroup is a wrapper for FormControlLabel component then add CheckBox component as a control prop )

* Switch ( in MuiSwitch.tsx) : 
- FormControlLabel Component: accepts control prop ( control={<Switch/>} )  and label prop 
- If you want group use same technique of Radio button or CheckBox

* Rating component (in MuiRating.tsx) : 
- onChange event : 2nd argument will be a number if you press on 2nd star so the value of 2nd arguments will be 2 if you press at the same star again will reset the rating and the value of 2nd argument will be null
- Precision prop : if you write precision={0.5} now you can choose half star 
- icon and emptyIcon props : if you want to change the star to different icon shape

* AutoComplete component ( in MuiAutoComplete.tsx) : 
- options prop : is an array 
- renderInput prop : is a function that return extField Component and accepts parameters then you can spread those parameters as props to TextField Component 
- onChange event : 2nd argument will be a the chosen value ( newValue ) and if you press on X to clear the chosen value the 2nd argument will be null
- freeSolo prop : to allow to type any string not only the options values 

* Box Component ( in MuiLayout.tsx) : 
- The Box component serves as a wrapper component for most of the CSS utility needs
- component prop : if you want to render box to other html element like span
- sx prop : if you want to add css styles 
- You can add css directly to Box component no need for sx prop ( but those css styles must be supported by Mui ) ( there is shortcuts for some css styles like bgcolor = background color )

* Stack component ( in MuiLayout.tsx) :
- is a wrapper component
- sx prop : to add css styles 
- Direction prop : by default of stack component display is flex and direction is column and you can change the direction by direction prop 
- Spacing prop : to add space between components inside stack ( is a number and this number is multiplied by 8 px … spacing={2} means 16px )
- divider prop : accepts Divider components to add Divider component between flex items and Divider component accepts orientation and flexItem props 

* Grid component ( in MuiLayout.tsx) :
- Stack used for one dimensional Layout but Grid used for two dimensional Layout
- You can make Grid component as Grid parent by adding container prob and you can make Grid Component as Grid item by adding item prop
- Grid under the hood uses Flexbox module 
- Breakpoints: xs for mobile devices, sm for tablets , md for desktops lg and xl for larger monitors 
- Grid contains 12 column and you can write what the numbers of columns will you used for each item ( like xs={6} means this item will use 6 columns which is 50% of width of grid ) ( if you didn’t write any numbers to breakpoints will divide the width equally between grid items … if you write auto will give the grid item width only for the text inside the grid item ) 

* Paper component ( in MuiLayout.tsx) :
- you can change background color by adding it to body in app.css 
- You can change the shadow of paper or card by using elevation prop in Paper component

* Card component ( in MuiCard.tsx) : 
- Card component: a wrapper for CardMedia , CardContent and CardActions components 
- CardMedia component accepts component, height, image ( source of the image ) and alt ( for accessibility) props 
- CardContent is a wrapper for typography components 
- CardActions is a wrapper for button components 

* Accordion Component ( in MuiAccordion.tsx ) :
- Accordion component: is a wrapper component for AccordionDetails and AccordionSummary components and accepts expand prop and onChange event ( onchange event accepts two parameters event and isExpanded ) 
- AccordionSummary component accepts id , aria-controls( for accessibility) and expandIcon ( accepts ExpandMoreIcon component ) props 
- AccordionDetails component wrap typography component 

* ImageList Component ( in MuiAImageList.tsx ) :
- ImageList component: is a wrapper component for ImageListItem and ImageListItemBar components and accepts sx ( for css styles) , cols and rowHeight props or variant (woven or masonry) and gap (if you use gap remove rowHeight)
- ImageListItem component wrap imag html element
- note : if you want to use varaint masonry wrap ImageList with Box component and add sx prop to the Box component noy yo ImageList component

* Navbar ( in MuiNavbar.tsx) : 
- AppBar component is a wrapper component for toolbar component and toolbar component is a wrapper component for IconButton component and IconButton component is a wrapper component for Icon component ( like CatchingPokemonIcon ) and typography component and Stack component 
- NavLinks  : add stack component then inside it Buttons 
- NavMenu : Menu Component is a wrapper component for MenueItem components 
    to link navMenu to specific button you should follow those steps : 
        [1] add id prop to Menu Component and Button Component
        [2] add MenuListProps prop to Menu Component and inside this prop add ('aria-labelledby': id of the Button )
        [3] add anchorEl prop to Menu Component and assign to it anchorEl variable (the Button Element) ( use useState Hook to store button element to anchorEl variable  when you click on it)
            - note : adding anchorEl prop(inside it button html element) to Menu to position the menu to this html element
        [4] add anchorOrigin and transformOrigin props to Menu Component to customize the position of menu
        [5] add open prop to Menu Component if true menu will show up
        [6] add onClick event to Button Component to save the Button HTML element to anchorEl variable so open will be true so menu will show up
        [7] add onClose prop (callback fires when the component requests to close)
        [8] add onClick prop (inside it handleClose function) to MenuItem Components 
        [9] add aria-controls={open ? id of Menu Component : undefined} and aria-haspopup and aria-expanded to Button Component for accessibility purposes

* Link ( in MuiLink.tsx) : 
- Stack component is a wrapper for Link Components 
- Link component’s props : href and underline ( underline=“hover” ) means will underline will appears only when you hover 
- you can add variant prop to Link component and will take styles and also you can wrap Link component with Typography component with variant prop and Link will inherit variant from Typography Component 

* BreadCrumbs (in MuiBreadcrumbs.tsx) : 
- Breadcrumbs component is a wrapper component for Link components to separate the Link by / 
- You can change the default separator / by adding separator prop 
- You can use maxItems prop for example if you add maxItems={2} and you have 4 Links will show only 1st and last Link and in-between will add …
- You can change number of links shown before and after … by using itemsAfterCollapse or itemsBeforeCollapse for example if you add itemsAfterCollapse={2} will show after … last 2 Links not only Last link 

* Drawer (in MuiDrawer.tsx) : 
- Drawer component is a wrapper component for Box Component and Box Component is a wrapper for Typography Component
- you can chose the position of Drawer by using anchor prop (anchor="left")
- onClose prop (callback fires when the component requests to close)
- open prop if true (isDrawerOpen variable by using useState Hook) menu will show up
- we use IconButton Component (contains MenuIcon Component) and add onClick event (handle isDrawerOpen variable value true or false ) to it
- role prop for accessibility and screen readers

* Speed Dial (in MuiSpeedDial.tsx) : 
- SpeedDial component is a wrapper component for SpeedDialAction Components
- SpeedDial component props : ariaLabel ( for accessibility) , sx (css tyling ) , icon and openIcon (to change icon when opened)
- SpeedDialAction component props : tooltipTitle (text will show up when you hover ) , icon and tooltipOpen (text will show always no need for hover)

* BottomNavigation (MuiBottomNavigation.tsx) :
- BottomNavigation Component is a wrapper component for BottomNavigationAction components
- BottomNavigation Component props : showLabels (to always show the label not only clicked one) , onChange event : 2nd argument will be a the chosen value ( newValue ) , value , sx (css styling)

* Avatar ( in MuiAvatar.tsx ):
- Stack Component is a wrapper component for Avatar Components 
- Avatar Components props : ( src and alt) , variant ( rounded or square) , sx ( css styling) 
- AvatarGroup component is a wrapper component for Avatar Component and it's prop like : max (max={2} will show only 2 Avatars )


* Badge ( in MuiBadge.tsx ) : 
- Stack component is a wrapper for Badge components 
- Badge component is a wrapper for Icons ( MailIcon ) 
- badgeContent prop: badgeContent={5} (will show number 5 as notification ) 
    - if you write 0 will not show 0 as notification number if you want to show it add showZero prop 
    - If you write 100 will show 99+ because default max numb is 99 and you can change that by using max prop like max={999} 
- Variant prop : if you write variant=“dot” instead of badgeContent prop will add dot only as notification without number 
- Invisible prop : invisible={true} to hide badge 

* list ( in MuiList.tsx) :
- you can use all those Component to create the list : Box,List,ListItem,ListItemText,ListItemButton,ListItemIcon,Divider,ListItemAvatar,Avatar 
- Box > List > ListItem > ListItemText 
- Box > List > ListItemButton > ListItemIcon  > Icon
- Box > List > ListItemAvatar > Avatar 

* Chip ( in MuiChip.tsx) : 
- Stack component is a wrapper for Chip Components.
- Chip props : label , color , onClick , onDelete , variant , Avatar , icon.
- icon prop can add icon to chip , avatar prop can add Avatar Component to the Chip.
- onDelete prop will add x icon to Chip as delete button

* Tooltip ( in MuiTooltip.tsx) : 
- Tooltip is a wrapper for IconButton Component (contains Icon)
- Tooltip props : title , placment (to change position of title when hover) , arrow (to add arrow to title) , enterDelay & leaveDelay (delay for title text when hover)

* Table ( in MuiTable.tsx ) : 
- stickyHeader prop ( in Table Component) will make Header sticky when you scroll 
- align prop ( in TableCell component) : align=“center” 
- 


* Alert ( in MuiAlert.tsx) : 
- severity prop : error (red) , warning (yellow), info (blue) , success (green) 
- Variant prop : outlined, filled 
- OnClose prop will add automatically x icon to Alert Component 
- You can change the icon by using Icon prop and add to it any Icon you want 
- You can add AlertTitle Component inside Alert Component 
-  action prop can be used to provide an alternative action, for example using a Button or IconButton.

* Snackbar ( MuiSnackbar.tsx) : 
- if you want to use default Snackbar use Snackbar component then add props :
    open (visible or not ), autoHideDuration , onClose , message , anchorOrigin (position)
- if you want to use custome made Snackbar component as a wrapper component and add to it ( open , onClose , autoHideDuration)
then add inside Snackbar component your custome made Component ( SnackbarAlert ) and add to it (onClose , severity) props
- onClose : you should add if condition ( if reason === "clickaway" return ) to handleClose function to stop clicking away from closing Snackbar

* Dialog ( in MuiDialog.tsx) :
- Dialog > DialogTitle > DialogContent ( > DialogContentText ) & DialogActions ( > Button )

* Progress ( in MuiProgress.tsx) :
- CircularProgress : to give you loading circle ... props ( color , variant='determinate' ,  value)
- The variant prop : Use indeterminate when there is no progress value.
- LinearProgress : to give you loading straight line ... props ( color , variant='determinate' ,  value)

* Skeleton ( in MuiSkeleton.tsx) : 
- Skeleton Props : animation , variant , width , height

* Loading Button ( in MuiLoadingButton.tsx) :
- 1st EXP. if loading is true will display loading circle (  default ) instead of displaying Text 
- 2nd EXP. if loading is true will display loadingIndicator ( if you add this prop ) instead of displaying Text
- 3rd EXP. if loading is true will display loading circle (  default ) instead of SaveIcon

* Date Picker ( in MuiDateTimePicker.tsx) :
- see the file 

* DateRange Picker ( in MuiDateRangePicker.tsx) :
- see the file 

* Tabs ( in MuiTabs.tsx) :
- onChange event (on TabList Component) : 2nd argument will be a the value of the chosen Tab ( newValue ) 
- Box > TabContext > Box (> TabList > Tab) & TabPanel 
- value prop on TabContext will decide which Tab will be selected and which TabPanel will be shown 

* Time Line ( in MuiTimeline.tsx) : 
- Timeline > TimelineItem > TimelineSeparator (> TimelineDot & TimelineConnector) & TimelineContent 
- if you want to  add content on other side also you can add TimelineOppositeContent Component under TimelineItem

* masonry ( in MuiMasonry.tsx) : 
Masonry maintains a list of content blocks with a consistent width but different height. The contents are ordered by row. 
If a row is already filled with the specified number of columns, the next item starts another row, and it is added to the shortest column in order to optimize the use of space.
- Box > Masonry > Paper or Box > Masonry > Accordion > AccordionSummary & AccordionDetails

* Custome theme :
[1] import createTheme and invoke it and assign it to theme variable 
[2] wrap entire component tree in App.tsx with ThemeProvider component and add theme variable to Theme prop 
- note : if you want to add new option in theme will give you an Error you should creat new file ( theme.d.ts) and import ThemeOptions this is a link how to write interface ( https://github.com/mui/material-ui/blob/v5.13.5/packages/mui-material/src/styles/createPalette.d.ts ) 


---------------------
Testing 

* Jest vs React testing library : 
    Jest => JS Testing Framework 
    RTL => JS utility provides Virtual Dom for testing React components ( the main objective of RTL is how the component behaves when a user interacts with it and the final result is correct not how by details the component works )
    * note : will use Jest and RTL together they are not alternative to each other 

* Types of tests : 
[1] unit test : 
    * Focus on testing an individual building blocks of an application such as function , class or a component 
    * Each unit test in isolation, independent of other units
    * dependencies are mocked
[2] integration test : 
    * Focus on testing a combination of units and ensuring they work together 
[3] E2E test ( End to End test ) :
    * Focus on testing the entire application flow and ensure it works as designed from start to finish 


* create react testing :
    npx create-react-app . --template typescript 

* to run test (npm test) 
    To run all test press a
    To filter test by file name press p
    To filter test by test name press t 
    To quit test mode press w 

* Test(test name , fn , timeout ) 
    1st argument: test name 
    2nd argument: function thats contain the expectation to test
    3rd argument: is optional timeout( for how long should wait before aborting the test the default is 5 secs ) 
    * note : test.only() to rub this test only , test.skip() to skip this test
    * note : you can use it() instead of test() , you can use xit() instead of test.skip() , you an use fit() instead of test.only()

* How to create a test RTL ( in app.test.tsx) : 
    [1] import { render, screen } from '@testing-library/react';
    [2] create virtual Dom by passing App component as an argument to render method
    [3] use screen.getByText() query method (Queries are the methods that Testing Library gives you to find elements on the page. ) and pass a string or regular expression or function  as an argument  
    [4] expect(linkElement).toBeInTheDocument(); 
    * Note : we did not import text or expect (from Jest) becuase they are available globally when you create React app
    thats mean now we used RTL and Jest together

* Test Driven Development ( TDD ) ( red to green test ) (in greet2.test.tsx) : 
    Is a process that you write the test before you write the code

* Watch mode is an option that we can pass to Jest asking to watch files that have changed since the last commit and execute tests related only to those changed files .

* Tests Grouping (in greet2.test.tsx):
    You can use describe method ( no need to import it it’s available globally) 
    describe (name, fn)
    The first argument is the group name
    The second argument is a function that contains the expectations to test
    * note : you can use describe.only() and describe.skip() 
    * Note : you can use nested describe ( describe inside describe ) 
    * Note : you can add more than one describe in same file 

* Filename Conventions
    * Files with .test.js or test.tsx suffix. ( in greet2.test.tsx)
    * Files with .spec.js or .spec.tsx suffix. ( in greet2.spec.tsx)
    * Files with .js or .tsx suffix in __tests__ folders. ( in greetTest.tsx in __test__ folder)


* Code Coverage
    A metric that can help you understand how much of your software code is tested
    * Statement coverage: how many of the statements in the software code have been executed
    * Branches coverage: how many of the branches of the control structures (if statements for instance) have been executed
    * Function coverage: how many of the functions defined have been called and in tests folders.

* steps to run coverage : 
    [1] add "coverage" : "npm test -- --coverage" inside scripts in package.json   
    [2] add "coverage" : "npm test -- --coverage --watchAll" to watch all files 
    [3] add "coverage" : "npm test -- --coverage --watchAll --collectCoverageFrom='src/components/**/*.{ts,tsx}'" to coverage specific files
    [4] add "coverage" : "npm test -- --coverage --watchAll --collectCoverageFrom='src/components/**/*.{ts,tsx}' -collectCoverageFrom='!src/components/**/*.{types,stories,constants,test,spec}.{ts,tsx}'" to not coverage specific file ( like greet2.types.ts)
    [5] write ( npm run coverage ) in command 

* steps for coverage threshold : 
    [1] add in package.json 
        "jest" : {
            "coverageThreshold" : {
                "global" : {
                    "branches" : 80,
                    "functions" : 80,
                    "lines" : 80,
                    "statements" : -10
                }
            }
        }
    * note : means give you error if branches or funcion or lines less than 80% or more than 10 statement uncovered
    * note : if you coverage more than one file coverage branches will not work proberlly for example here if we write a {props.name  ? props.name : "Guest"} in 
    greet2.tsx so you need 2 tests one with name and one without name if you write only one test will give you branch 50%
    but (for reason i don't know ) if we coverage greet.tsx and greet2.tsx will give you branch 100%

* Assertions : 
    expect is global method accept an argument which will be checked by matcher method like (toBeInTheDocument())
    expect(textElement).toBeInTheDocument();

    * note : there are a lot of matcher methods like 
        - toHaveTextContent('2')
        - toHaveValue(10)
        - toHaveFocus()

* RTL Queries
    Every test we write generally involves the following basic steps
    1.Render the component 
    2.Find an element rendered by the component 
    3.Assert against the element found in step 2 which will pass or fail the test 
    To render the component, we use the render method from RTL like ( render(<Greet2/>); )
    To Find element we use RTL Queries (1st argument is called textMatch ( string or regex or function) , 2nd argument is options object)

    For assertion, we use expect passing in a value and combine it with a matcher function from jest or jest-dom like (expect(textElement).toBeInTheDocument();)

* RTL Queries
    Queries are the methods that Testing Library provides to find elements on the page like (const textElement = screen.getByText(/Hello/))
    To find a single element on the page, we have (getBy.. , queryBy.. , findBy..)
    To find multiple elements on the page, we have (getAllBy.. , queryAllBy.. , findAllBy..)
    The .. can be one of Role, LabelText, PlaceHolder Text, Text, Display Value, AltText, Title and finally Testld

* getBy... queries (in application.test.tsx) ( all queries in application.test.tsx)
    getBy.. class of queries return the matching node for a query, and throw a descriptive error if no elements match or if more than one match is found

[1] getByRole queries for elements with the given role
    Role refers to the ARIA (Accessible Rich Internet Applications) role which provides semantic meaning to content to ensure people using assistive technologies are able to use them ( Accessibility ) 

    By default, many semantic elements in HTML have a role
    Button element has a button role, anchor element has a link role, h1 to h6 elements have a heading role, checkboxes have a checkbox role, radio buttons have a radio role and so on
    If you're working with elements that do not have a default role or if you want to specify a different role, the role attribute can be used to add the desired role To use an anchor element as a button in the navbar, you can add role='button'

    * Note : we deleted App.test.tsx we don’t need it anymore

    -getByRole options (in application.test.tsx):
        if we have two HTML elements that has same Role so getByRole will throw an Error because it found more than one element
        to solve this problem (label and textarea elements has same Role "textbox") you can add option object 

* option object : 
    [1] name property : 
        The accessible name is for simple cases equal to
        1.the label of a form element
        2.the text content of a button or
        3.the value of the aria-label attribute

    [2] level proberty : 
        specific to heading h1,h2 ....
        level :1 means h1 , level :2 means h2 ....

[2] getByLabelText
    getByLabelText will search for the label that matches the given text, then find the element associated with that label

    -getByLabelText options 
    * Selector : 
        If it is important that you query a specific element (if more than one label has same Text) (e.g. an <input>) you can provide a selector in the options object
        
[3] getByPlaceholderText: 
getByPlaceholderText will search for all elements with a placeholder attribute and find one that matches the given text

[4] getByText : 
getByText will search for all elements that have a text node with textContent matching the given text
Typically, you'd use this to find paragraph, div or span elements
-note : accepts also selector option like getByLableText 


[5] getByDisplayValue: 
getByDisplay Value returns the input, textarea, or select element that has the matching display value

[6] getByAltText : 
getByAltText will return the element that has the given alt text
This method only supports elements which accept an alt attribute like <img», <input>, <area> or custom HTML elements


[7] getByTitle :
 getByTitle returns the element that has the matching title attribute

[8] getByTestld : 
getByTestld returns the element that has the matching data-testid attribute

*Priority Order for Queries
    1.getByRole
    2.getByLabelText
    3.getByPlaceholderText
    4.getByText
    5.getByDisplayValue
    6.getByAltText
    7.getByTitle
    8.getByTestld

* RTL getAllBy Queries : 
    Find multiple elements in the DOM
    getAllBy returns an array of all matching nodes for a query, and throws an error if no elements match

    [1] getAllByRole
    [2] getAllByLabelText
    [3] getAIlByPlaceholderText 
    [4] getAllByText
    [5] getAIlByDisplayValue
    [6] getAlIByAltText
    [7] getAllByTitle 
    [8] getAllByTestld

* RTL queries used so far ( Examples) : 
    const pageHeading = screen. getByRole("heading")
    const nameElement2 = screen.getByLabelText("Name")
    const nameElement3 = screen.getByPlaceholder Text("Fullname")
    const paragraphElement = screen.getBy Text("All fields are mandatory")
    const nameElement4 = screen.getByDisplayValue("Vishwas")
    const imageElement = screen.getByAltText("a person with a laptop")
    const closeElement = screen.getByTitle ("close")
    const customElement = screen.getByTestld("custom-element")
    const listitemElements = screen.getAllByRole("istitem")

* TextMatch :
    TextMatch represents a type which can be either a
    [1] string : 
        <div>Hello World</div>
        screen.getByText('Hello World*) // full string match screen.getByText(llo Worl', {exact: false}) // substring match screen.getByText('hello world', {exact: false}) // ignore case

    [2] regex : 
        <div>Hello World</div>
        screen.getByText(/World/) // substring match screen.getByText(/world/i) // substring match, ignore case screen.getByText(/^hello world$/i) // full string match, ignore case

    [3] function
        (content?: string, element?: Element | null) => boolean
        <div>Hello World</div>
        screen.getByText((content) => content.startsWith('Hello"))




* queryBy and queryAllBy ( in Skills.test.tsx)
    [1] queryBy
    *   Returns the matching node for a query, and return null if no elements match
    *   Useful for asserting an element that is not present ( so you can use expect(startLearningButton).not.toBeInTheDocument())
    *   Throws an error if more than one match is found
    [2] queryAllBy
    • Returns an array of all matching nodes for a query, and return an empty array if no elements match
    * note : Difference between queryBy and getBy is getBy returns error if no elements match or if more than one match is found
            but queryBy returns error if more than one match is found and return null if no elements match so you can use it if theelement not present 

* RTL queryBy and queryAllBy Queries
    queryByRole
    queryByLabelText
    queryByPlaceholderText
    queryByText
    queryByDisplayValue
    queryByAltText
    queryByTitle
    queryByTestld
    queryAllByRole
    queryAllByLabelText
    queryAllByPlaceholder Text
    queryAllByText
    queryAllByDisplayValue
    queryAllByAltText queryAllByTitle
    queryAllByTestld



* findBy and findAllBy ( incase of Appearance / Disappearance) ( in Skills.test.tsx):
    What if elements are not present in the DOM  but make their way into the
    DOM after some time?
    For example, data that is fetched from a server will be rendered only after a few milliseconds

    [1] findBy:
        Returns a Promise which resolves when an element is found which matches the given query
        The promise is rejected if no element is found or if more than one element is found after a default timeout of 1000ms
    [2] findAllBy :
        Returns a promise which resolves to an array of elements when any elements are found which match the given query
        The promise is rejected if no elements are found after a default timeout of 1000ms

    * note : if we want to add more time to default time out we can add object with timeout property as 3rd argument to findBy 

Manual Queries
    Manual queries - you can use the regular query Selector DOM API to find elements
    const {container} = render(<My Component />)
    const foo = container.querySelector(data-foo= "bar")


* screen.debug : 
    the debug() method can help us visualize the DOM tree before writing an assertion ( for Exp. to show the DOM before and after setTimeout in Skills.test.tsx) 


* logRoles: 

    This helper function can be used to print out a list of all roles of elements within a tree of DOM nodes
    steps : 
        [1] import logRoles
        [2] const view = render(<Skills skills={skills} />);
        [3] logRoles(view.container) 

* testing playground :
    Is a chrome extension to suggest you the best query to select an element when writing tests

* user-event
    A companion library for Testing Library that simulates user interactions by dispatching the events that would happen if the interaction took place in a browser
    It is the recommended way to test user interactions with RTL

* fireEvent vs user-event
    fireEvent is a method from RTL which is used to dispatch DOM events (not library)
    user-event simulates full interactions, which may fire multiple events and do additional checks along the way
    For example, we can dispatch the change event on an input field using fire vent
    When a user types into a text box, the element has to be focused, and then keyboard and input events are fired and the selection and value on the element 
    are manipulated as they type user-event allows you to describe a user interaction instead of a concrete event. It adds visibility and intractability checks along the way and manipulates the DOM just like a user interaction in the browser would. 
    It factors in that the browser e.g. wouldn't let a user click a hidden element or type in a disabled text box

* use event library is installed by default with React but version 13 to update it to version 14 ( npm install --save-dev @testing-library/user-event )

* Pointer Interactions : 

    [1] Convenience APIs :
        click()
        dbIClick()
        tripleClick()
        hover()
        unhover()
        type() // user.type(amountInput, '10') 1st argument is input element , 2nd argument is the amount will be added to this input element

    [2] Pointer APIs : 
        pointer({keys: '[MouseLeft]}) //  mouse left click
        pointer ({keys: '[Mouse Left][Mouseright]}) mouse left click followed by mouse right click
        pointer('[MouseLeft][Mouseright]') // like previous
        pointer('[MouseLeft>]') // hold mouse left click
        pointer('[/MouseLeft]) // realse the clicked mouse left 

* Steps to use pointer interactions ( in counter.test.tsx ): 
    [1] import user from '@testing-library/user-event'
    [2] inside test add ( user.setup() )
    [3] await user.click(incrementButton) // await because it's asynchronous



* Keyboard interactions : 

[A] Utility API
    [1] clear()

    test('clear', async () => {
        render (<textarea defaultValue="Hello,World!" />)
        await userEvent.clear(screen. getByRole( 'textbox' )) 
        expect (screen. getByRole('textbox')). toHaveValue('')
    })

    [2] selectOptions()

        test( 'selectOptions', async () =>{
        render(<select multiple>
            <option value="1">A</option> 
            <option value="2">B</option> 
            <option value="3">C</option>
        </select>)
        await userEvent.selectOptions(screen.getByRole( 'listbox'), ('1', 'C')) 
        expect (screen. getByRole( 'option' {name: 'A'}) .selected).toBe(true) 
        expect ( screen. getByRole( 'option {name: 'B'}).selected).toBe(false) 
        expect ( screen. getByRole( 'option {name:'C' }).selected).toBe(true)
        }）

    [3] deselectOptions()

        test 'deselectOptions', async () => {
        render(<select multiple>
            <option value="1">A</option> 
            <option value="2" selected>
        </select>)
        }）

        [4] upload()

        test('upload file', async () => {
            render ( <div>
                <label htmlfor="file-uploader">Upload file:</label>
                <input id="file-uploader" type="file" />
            </div>)
        const file = new File(['hello'], 'hello.png', {type: 'image/png'})
        const input = screen.getByLabelText(/upload file/i)
        await userEvent . upload( input, file) expect (input. files [0]). toBe( file) expect (input.files.item(0)).toBe(file) expect (input .files) . toHaveLength(1)
        })


[B] Clipboard APIs: 
    сору()
    cut()
    paste()

[C] Kevboard API: 
    keyboard('foo') // translates to: f, 0, o
    keyboard({Shift>}A{/Shifty}) // translates to: Shift(down), A, Shift(up) means holds

* Provider and testing ( in AppProvider.tsx , MuiMode.tsx , MuiMode.test.tsx )
    [1] wrap MuiMode component with AppProvider (inside it we created the theme and pass it as prop ) 
    [2] at MuiMode component use useTheme() to access theme created inside AppProvider from 

    
* Custom render (in MuiMode.test.tsx ): 
    If you test component MuiMode will test it without wrapper component 
    so you have to add 2nd argument to render method and this 2nd argument is an object with property wrapper ( like in Mui-Mode.test.tsx) 

    But with custom render you can add default wrapper component to all tested components
    By adding ( test-utils.tsx ) ( we copied it from docs ) and then (import { render, screen } from '../../test-utils') instead of (import { render, screen } from '@testing-library/react')

* custom React hooks (in useCounter.test.tsx): 
    Hooks doesn’t return jsx and only called inside body of a function component so we cannot use render method when test a hook we should use renderHook method instead 
    And this renderHook method wrap the hook with function component and invoke the hook to return an object then we can destructer a property called result 
    Then result.current is the return value from the custom hook 

    If you want to pass a prop to custom hook ( useCounter ) add an object as a 2nd argument to renderHook method 

* act() (in useCounter.test.tsx):
    When testing , code that cause state update should be wrapped into act() 
    like result.current.increment() will cause state update so you should wrap it with act()

* Mocking function (in CounterTwo.tsx , CounterTwo.test.tsx , CounterTwo.types.ts): 
    - read this to understand meaning of Mocking ( https://grantwinney.com/what-is-mocking-a-dependency/ )
    - steps of mocking function : 
        [1] use jest library to create mocked function ( const incrementHandler = jest.fn() )
        [2] click on button by using user ( search here for Steps to use pointer interactions  )
        [3] use matcher method to know if the function called when you click ( expect(incrementHandler).toHaveBeenCalledTimes(1) )

* Mocking HTTP Request : 
    - reason of Mocking HTTP Request is http requests used only in E2E Tests ( End to End test => test for entire application ) which will be one time only
    but iwth unit or function test you will make test several times and calling https requests alot of times will cost you money
    - we will use MSW library ( Mock Service Worker)

*  MSW library ( Mock Service Worker) : 
    - install ( npm install msw --save-dev )
    - steps of creating server : 
        [1] creat folder called mock inside src folder
        [2] add two files handlers.ts and server.ts ( copied from docs)
        [3] in handlers.ts : 
            [a] import { rest } from 'msw'
            [b] rest.get() accepts two arguments : 1st argument is API URL , 2nd argument is function 
            and this function accepts 3 arguments (request , response , context) and return response() function
        [4] in server.ts create server by using setupServer(...handlers) and accepts handlers as an argument

* (in Users.test.tsx )to use mocked server we add code to setupTests.ts (copied from docs)

* Error Handling : 
    we cannot add status(500) in handlers.ts because will give error to all tests using this server
    but you can use ( server.use(handler) ) (in Users.test.tsx) and add specific handler that has status(500) so will 
    give error only for this specific test

* Static analysis testing
    Process of verifying that your code meets certain expectations without actually running it
    All types of tests run the code and then compare the outcome against known expected outputs to see if everything works OK
    Testing checks if your code works or not, whereas static analysis checks if it is written well or not

    - Ensure consistent style and formatting
    - Check for common mistakes and possible bugs
    - Limit the complexity of code and
    - Verify type consistency

* Static analysis testing tools
    [1] TypeScript
    [2] ESlint
    [3] Prettier
    [4] Husky
    [5] lint-staged

* ESlint : 
    ESLint is a tool for identifying and reporting on patterns found in
    ECMAScript/JavaScript code, with the goal of making code more consistent and avoiding bugs
    
    - steps to install with npm : 
        [1] add ESlint extension from VSCode
        [2] npm install --save-dev eslint-plugin-jest-dom
        [3] add "plugin:jest-dom/recommended" inside "eslintConfig": inside package.json

    for exp. will give you error in application.test.tsx before running the code to tell 
    you that you should use toBeDisabled() instead of not.toBeEnabled()

    - steps to run lint on terminal : 
        [1] add "lint":"eslint --ignore-path .gitignore ." inside scripts inside package.json
        [2] npm run lint

* Prettier : 
    Prettier is an opinionated code formatter that ensures that all outputted code conforms to a consistent style

    - steps to install with npm : 
        [1] npm install --save-dev --save-exact prettier
        [2] add "format": "prettier --ignore-path .gitignore --write \"**/*.{ts,tsx,css,scss}\"" inside scripts inside package.json
        [3] npm run format

    - note : you can add .prettierrc.json file and then copy some code from docs to configure 
    prettier like replace single quote to double quote or remove ;

    - note : you can install prettier extension from VSCode to format when you save the file ( be sure that format on save enabled from VSCode setting)

    - note : if you use both eslint and prettier you should do those 2 steps to disable any conflicts between different rules : 
        [1] npm i eslint-config-prettier
        [2] add "eslint-config-prettier" inside "eslintConfig": inside package.json

* Husky : 
    Husky is a tool that helps improve your commits and more ( will run npm test when you commit )
    - steps to install : 
        [1] npx husky-init && npm install
        [2] write npm run lint && npm run format inside pre-commit folder in husky folder

    * note : if .git not as same level of package.json :
        [1] npx husky-init && npm install
        [2] add "prepare": "cd .. && husky install react-testing/.husky" to scripts inside package.json
        [3] npm install
        [4] npx husky add .husky/pre-commit "npm run lint && npm run format"
        [5] change directory in pre-commit file cd react-testing

* add lint-satged to husky (to test only staged files):
    [1] npm install --save-dev lint-staged
    [2] add this to package.json
        "lint-staged": {
            "*.tsx": "eslint"
         }
    [3] write  npx lint-staged inside pre-commit folder in husky folder

    * note (to test code before pushing ):
        npm husky add .husky/pre-push "npm test -- --watchAll=false"

----------------------------------

* Next.js

* Next.js
    A package that uses React for building user interfaces
    Loaded with a lot more features that enable you to build full fledged production ready applications.
    Features exactly like routing, styling, authentication, bundle optimization etc.
    There's no need to install additional packages. Next.js provides everything for you

* Next.js simplifies the process of building a react application for production
    1.File based routing
    2.Pre-rendering ( Generate html for each page in-advance instead of doing that at client side  ( so next.js give you better performance) )
    3.API routes (  You can create API with next.js ( so you can use next.js as full stack )) 
    4.Support for CSS modules
    5.Authentication
    6.Dev and Prod build system

* to create NEXT app ( npx create-next-app <name of  project>)
* to run server ( npm run dev)

* Scripts in package.json : 
    Dev ( run next app in development mode ) (npm run dev)
    Build ( compile the code and prepare it for production deployment) 
    Start ( starts compiled application with server side codes ( this is different from react )) 
    Lint ( to check for error in all files) 

* Routing : 
    why Routing in Next.js better than React : 
        - Routing in a React app
        [1] Install a third party packageroutes.js file to configure the routes
        [2] For each route, create a component file, export the component, import it in routes.js and configure the new route with a path property

    - Routing in Next.js file based (in about and profile folders in app folder) : 
        means you create folder of page name inside app folder and put inside it page.tsx file 
        now routing will be automatically handeled by next.js just go to \about of \profile on browser

    - nested routing (in first and second folders inside blog folder in app folder) 

    -Dynamic Routing (in [id] inside product folder in app folder) : 
        - in older version of nextjs to get the id number you have typed in URL you will use useRouter Hook 
        but in new version (13) you can use parameters of component to access the URL and get what you want
        
        - to make it dynamic name the folder between [] ( like [id] inside product folder ) now you can write in URL product/(any number you want)
        and to access the number you wrote (like product/50 ) you can access it from component props ( params.id) id beacuse the folder named [id]

        - if product folder has dynamic folder [id] and folder 100 what will happend when you write product/100 ? 
            nextjs will choose 100 folder page  not dynamic page
    
    - nested Dynamic Routing (in [reviewId] inside review Folder inside [id] folder inside product folder in app folder) : 
        you can access id and reviewId from component props ( params.id , params.reviewId) id beacuse the folder named [id] , reviewId because folder named [reviewId]

    
    - catch all routes (in [...catchAll] folder inside docs folder inside App folder ) : 
        adding ... will allow you to write any route and will render page.tsx inside [...catchAll] ( like docs/f/d/e/r/t)
        and you can access the routes by params.catchAll ( array of strings )

* Navigation : 
    [1] import Link from "next/link"
    [2] use Link Component and add href attribute to navigate (like in page.tsx in App and page.tsx in product)
    
* navigate programmatically (navigate to page when you click on buttton for EXP.) (in page.tsx in App folder): 
    [1] add "use client" to the top of the file
    [2] import { useRouter } from "next/navigation"
    [3] const router = useRouter()
    [4] router.push("./product")

* Custom 404 Page : 
    create not-found.tsx at App Folder

* Pre-rendering : 

    Next JS generates HTML for each page in advance instead of having it all done by client-side

    Benefits of pre-rendering : 
    [1] Pre-rendering improves performance
        * In a React app, you need to wait for the JavaScript to be executed
        * Perhaps fetch data from an external API and then render the UI
        * There is a wait time for the user
        * With a pre-rendered page, the HTML is already generated and loads faster
    [2] Pre-rendering helps with SEO (search engine optimization)
        * If you're building a blog or an e-commerce site, SEO is a concern
        * With a React app, if the search engine hits your page, it only sees a div tag with id equal to root
        * If search engine hits a pre-rendered page though, all the content is present in the source code which will help index that page

* Static Generation (a type of Pre-rendering) : 
    Next JS, by default, without any configuration, statically generates every page in our app when we build it for production. 
    This allows the page to be cached by a CDN and indexed by a search engine.
    * note : difference between development mode (npm run dev) and production builds : 
        For production builds, a page will be pre-rendered once when we run the build command 
        In development mode, the page is pre-rendered for every request you make

* Static Generation with data fetching (in page.tsx in users folder):
    in Nesxtjs 12 or below you will use getStaticProps but in Nextjs 13 getStaticProps not supported
    in Nextjs 13 : export default function component (UserList) ( async because will fetch inside it directly)

* note : if you want to add components files don’t add it to App folder create another folder (components)
* note : why console.log will be on terminal not in browser ?
    if your using next.js 13, every component is a server side component by default which means the component won't run on the browser, 
    if you want to use client side components write "use client" on the top of your file. ( like User.tsx in components folder )
    but I won't recommend putting "use client" on top just because you want the information to display in the browser.

* building your project : 
    -Npm run build to build your project ( your builded project is in .next folder ) 

    - Any <Link /> component will be prefetched by default (including the corresponding data) for pages using Static Generation
        For example : you have home page and have page will do fetch ( page.tsx in users folder ) 
        When you at home page will not fetch the data untill you go to homepage\users from address bar in browser ( will download html file from server ) 
        But if you add Link to this users page at home page will fetch data when you open home page and you have two options : 
            [1] when you go to users page from address bar will download users html file from the server
            [2] when you click on the link will not download users html file from server will use fetched data to create html at client side
            * note : both 2 options data will be fetched on home page to be ready if you click on the link

******** will learn NextJs 13 from dave Gray Youtube Channel *********

***************************************** NEXTJS  *****************************************

**** NextJs 13 ( Dave-Gary) *****
https://nextjs.org/docs


* why NextJs?
    1.Server-side rendering (SSR):  can improve website performance and user experience by pre-rendering pages and sending fully-formed HTML to the browser.
    2.Automatic code splitting: Next js automatically splits code into smaller chunks, making it easier to load and reducing the time it takes to load the site.
    3.SEO optimization
    4.Faster development: Next js includes many features that can speed up development, such as file-based routing, automatic code splitting, and built-in API routes.
    5.Great developer experience: Next js offers a great developer experience, including hot reloading, automatic code splitting, and easy integration with other popular technologies.
    6.Built-in support for TypeScript
    * note : Hot reload : is a feature that lets you inject updated source code into a running app. This means that you can see the effects of your code changes almost instantly, without waiting for the app to rebuild or relaunch.

* Hydration: 
    Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive.

* SSG ( static site generation ) vs SSR Server-side Rendering : 
    -Static Generation (Recommended): The HTML is generated at build time and will be reused on each request.
    -Server-side Rendering: The HTML is generated on each request.
    * you can use both method and that called hybrid nextJs 

* CDN(content delivery network): 
    CDN is a network of servers linked together with the goal of delivering content as quickly, cheaply, reliably, and securely as possible.

* to insall nextJs : npx create-next-app@latest

* layout.tsx : any code will be written there will be applied to all pages ( in layout.tsx in app folder)
    each page can have specific layout so code inside it will be applied to this specific page only ( in layout.tsx in about folder ).

* Metadata : is availabe at layout.tsx and each page can have layout.tsx file inside it you can add different Metadata ( you can also add Metadata at page.tsx)

* loading : you can add loading.tsx file to any page folder and you will see it if page take too long for loading
before in React we used suspense component 
<Suspense fallback={<Loading/>}> <SomeComponent> </Suspense>

* error handling : you can add error.tsx to any page folder and will render it when there is an error and will not crash all project

* Routes : 
    just create folder and the name of folder will be the route name then add page.tsx file inside it
    you have two options in ( users/[userId]) :
    [1] use promise.all to wait for user name and posts
    [2] await only user and use <Suspense> to show user name while waiting for Fetching Posts

* Dynamic Routes : 
    just create a folder and the name of the folder between [] ( like [userId] inside users folder) :

* types.d.ts : you can create this file and add all types you will need in project and you can use it directly without importing 

* Fetching Data : 
    - you can fetch data inside function inside page.tsx file but it's better for organization add those functions 
    inside lib folder and then import them like ( import getAllUsers from '@/lib/getAllUsers' )

    - in page.tsx of users folder :
        * we fetched data of user and rendered the users name
        * we added Metadata directly at page.tsx
        * const usersData: Promise<User[]> = getAllUsers() 
            because getAllUsers() will return promise and we added <User[]> for types (User type from types.d.ts file)
    
    in page.tsx of [userId] : 
        * we created Dynamic Metadata (generateMetadata function and it's params is userId from Url )
        * we have 2 options to do 2 fetch requests : 
            [1] parallel ( use Promise.all([userData, userPostsData])) will fetch 2 request at same time
            [2] Suspense to progressively render a page and show a result to the user while the rest of the content loads 
                steps of option 2 : 
                    [a] import { Suspense } from "react"
                    [b] wrap the UserPosts component with Suspense component and pass the Promise as prop
                    * note : Suspense component can accept a fallback prop to render it when loading ( fallback={<h2>Loading...</h2>}) 

        * note : in option 1 we will fetch userData, userPostsData at same time so maybe will take a long time
        so option 2 is better because you will fetch userData first to show user.name and Suspense userPostsData to show userPosts when it ready

* in page.tsx in [userId] folder we fetched two times by invoking getUser() function two times 
but in nextjs by default will combine those 2 fetches to one fetch.


- Any <Link /> component will be prefetched by default
    For example : you have home page and have users page 
    When you at home page will not fetch the data untill you go to homepage\users from address bar in browser ( will download html file from server ) 
    But if you add Link to this users page at home page will fetch data when you open home page and you have two options : 
        [1] when you go to users page from address bar will download users html file from the server
        [2] when you click on the link will not download users html file from server will use fetched data to create html at client side
        * note : both 2 options data will be fetched on home page to be ready if you click on the link

* SSG : Static Site Generation
* SSR : Server Site Rendering ( for Dynamic Routes for example)
* ISR : incremental Static Generation ( allows pages to be updated after a site has been built and deployed )

* SSG vs SSR : 
    [1] Static Site Generation is a technique for pre-rendering web pages , during the build process. 
    The generated HTML, CSS, and JavaScript files are then served to the client, 
    resulting in websites loading faster and providing heightened security.

    [2] Server Side Rendering  is a technique where web pages are rendered on the server at request time for each user. 
    This approach allows for dynamic data and interactive content to be generated on-the-fly, 
    providing a more personalized user experience.

* how to change SSR to SSG : 
    for Example you have dynamic routes [userId] so nextjs will consider it as SSR because it does not know 
    the numbers of userId but if you know you can tell nextJs what is the expected userId (by generateStaticParams())
    we created generateStaticParams() function inside page.tsx inside [userId] folder 
    and this function will return array of objects each object has userId prop
    now nextjs knows the expected userId so will convert users/[userId] from SSR to SSG

* 2nd parameter of fetch : 
    [1] fetch(url, {cache: "force-cache"}) this if the defaut Nextjs cache data by default
    [2] fetch(url, {cache: "no-store"}) will not cache data 
    [3] fetch(url, {next: {revalidate : 60 }}) will check every 60 sec if there is updated data or not
        and this can applied to SSG or SSR (this method is called ISR) (in getUserPosts.tsx)

* Revalidation : is the process of purging the Data Cache and re-fetching the latest data. 
    This is useful when your data changes and you want to ensure you show the latest information.
    steps of Revalidation : 
    when you request data for first time will fetch data and for example you added {next: {revalidate : 60 }}
        -if you request data again before 60 sec will give you the data from cache
        -if you request data after 60 sec will fetch a new data

* dynamicParams: you can add export const dynamicParams = false; to page.tsx inside [userId] folder
    so when you try to access page not returned from generateStaticParams() ( like users/999 ) will give you 404 page
    * note: the default value is  dynamicParams = true so you can access any page number because it's dynamic
    * note : maybe is a bug if generateStaticParams()  return({userId:1}, {userId:2} , ...) dynamicParams = false; will work
        but if generateStaticParams()  return(users.map(user=>{userId:user.id.toString()})) dynamicParams = false; will not work

* not-found page : 
    nextjs by default give you 404 not found page if you write wrong url
    but you can override it by creating not-found.tsx inside App folder

    * note : you can show 404 page to dynamic route 
        for example if you write users/999 will render blank page because you are using 
        dynamic route so will accept any number
        but you can use notFound() function : 
            [a] import {notFound} from "next/navigation"
            [b] if(!user.name) return  notFound()
        so when you write users/999 user.name not availabe because so will give you 404 page (or not-found.tsx page if you override it )

* API routes : 
    - you can create api inside directory (app/api/folderName/route.ts)
        export async function GET(){
            return new Response("Hello, nextJs")
            return NextResponse.json("Hello, nextJs")
        }
        * note : instead of returning response.json() we will use NextResponse.json() because response.json() not compatible with TypeScript
        * note : you can use POST or GET
        * note : to test api you can download Thunder Client extension in VSCODE
        * note : we created feedback page.tsx that uses feedback route.ts api (see files to understand)
        * note : Array.protoype.every(Boolean) will check if every element in array is truthy value (const canSave = [...Object.values(data)].every(Boolean) in page.tsx in feddback page folder)

    - we usually use API routes in nextjs to hide secret key or secret URL 
    - if you are fetching data in server component no need to use API routes because already hidden from client side
    - if you want github ignore a file and not upload it to repo add name of file to .gitignore 
    - you can put you API KEY in .env.local file and github will not upload it to reop because it's mentioned in .gitignore file
    - you can add dynamic route folder ( like [id] inside todos folder inside api folder) 
    * note : const { id }: Partial<Todo> ( in route.ts in todos folder) Partial means i can write only id without typescript error no need to write all properties

* difference between PUT , POST , DELETE ? 
    The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server. 
    The PUT method replaces all current representations of the target resource with the request payload. 
    The DELETE method deletes the specified resource

* in GET Method accept 2nd parameter and 2nd parameter is object has property id ( name of dynmaic route) 
    so you can access id instead of accesing it from request.url ( in route.ts inside [id] inside todos folder)
    this is like 2nd parameter in page.tsx in [userId] dynamic in app folder

* Middleware :
    - can modify request headers, response headers, and send responses
    - Middleware returns NextResponse.next() (Returns a NextResponse that will continue the middleware chain)

    - Middleware will be invoked for every route in your project ( for example when you start dev mode 
    of your application Middleware will be invoked for every request so we have to tell Middleware to 
    be invoked only for specific path  and that what Matcher Path do ) 
    - Matcher Path :
    you have two options to do matcher path :
    [1] conditional if : 
        [a] if(request.url.includes("/api/")){} 
        [b] const regex = new Regex("/api/*) if(regex.test(request.url)){} 
    [2] export const config = { matcher = "/api/:path/*}
        * note : :path means api/a or api/b .... but not api/a/b
        * note : :path/* means api/a or api/b or api/a/b

* difference between NextResponse.next() , NextResponse.json() and new NextResponse(JSON.stringify(),{headers}) ?
    [1] NextResponse.next() returned by Middleware to continue the middleware chain
    [2] NextResponse.json() returned by route.ts 
    [3] new NextResponse(JSON.stringify(),{headers}) returned by route.ts if you want 
        to add Access-Control-Allow-Origin headers

* Limiter : install ( npm i limiter)
    It's a tool that controls the rate at which an action can be performed by a user 
    or an IP address. This can prevent a single user from making too many requests in 
    a short period of time and overwhelming the server

    steps : 
        [1] create folder called config inside api folder and create limiter.ts file inside it ( see file to understand)
        [2] import limiter and use it with any route you want (by using limiter.removeTokens(1) at every request) ( we tried it at route.ts inside api/hello)
        * notes : 
            - tokens will be shared if you use limiter for more than one route ( for example if you add 3 
            tokens and use limiter in hello and about route and request 2 times from hello and then request 2 times from about 
            will allow you to request one time only then will give you status 429 too many requests)
            - if you want not to share token you can add limiter.ts file for each route you want
        
* Cross-origin resource sharing (CORS) :
    is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain 
    from which the first resource was served. A web page may freely embed cross-origin images, 
    stylesheets, scripts, iframes, and videos.

* Types of CORS requests: 
    [1] simple requests: GET, POST ( These methods are considered safe because they are not capable of causing a change in state on the server ) 
    [2] PUT , DELETE ( These methods can cause a change in state on the server, so the browser sends a request to the server to check if the request is allowed ) 

* CORS mechanism :
    The CORS mechanism works by adding HTTP headers to cross-origin HTTP requests and responses.
    These headers indicate whether the request or response is allowed to access the resources.

* How does CORS work?
    When a browser sends a request to a server, it includes an Origin header. This header contains the origin of the request, 
    which is the domain, protocol, and port of the page making the request.
    The server can then decide whether to allow or deny the origin of request according to Access-Control-Allow-Origin ( see route.ts in todos Folder). 

- API Routes do not specify CORS headers, meaning they are same-origin only by default.
    so we have to return new NextResponse(JSON.stringify(),{headers:{Access-Control-Allow-Origin:origin we want to allow}})
    
- Thunder client extension does not have origin so will be always allowed so if you want to block it 
    add || !origin to ( if(origin && !allowedOrigins.includes(origin)){} in middleware.ts file ) so will be if(origin && !allowedOrigins.includes(origin) || !origin){}

* The Route Segment Config Options allows you configure the behavior of a Page, Layout by directly exporting the a variable like : 
    [1] const dynamicParams = false;
    [2] const revalidate = 10;

    * Note : if you add revalidate as 2nd parameter of fetch , will override the revalidate of Route Segment Config ( )
    * Note : To test Revalidation test it in build mode not dev mode 
    * Note : when you change data on server and set revalidation=10 after 10 secs when you refresh the page , the page will not be updated with new data , will be updated with 2nd refresh , why ? 
    Because 1st refresh will trigger revalidation and 2nd refresh get the new version and to solve this issue you have to do on-demand revalidation .

* On-demand revalidation  : 
    [1] create revalidate.ts file inside pages/api (now with new version you can add it to app/api but you have to use revalidatePath() method check Final Project)
    [2] request it by this link for example ( http://localhost:3000/api/revalidate?path=/&secret=DaveGrayTeachesCode ) 
        * note : we added secret key in .env.local file 
        now we triggered revalidation so when new data added to server wil be shown on page with 1st refresh not 2nd refresh
        * note : On-demand revalidation used when you want only users who has secret token to see updated data

* Data Mutation : 
    is a common side-effect in programming. 
    To mutate a variable once it has been defined means to alter its value.
    here in NextJs we means by data mutation is changing data from server after page is rendered
    
* note : To get updated data immediately you have 2 options ( on 2nd parameter on fetch ) or Route Segment Config: 
    [1] { cache :  ‘no-store’ } 
    [2] { revalidate :  0 } 
    [3] const revalidate = 0;

* Hard navigation vs Soft Navigation ?
    Hard navigation : 
        On navigation, the cache is invalidated and the server refetches data and re-renders the changed segments.
    Soft Navigation: 
        On navigation, the cache for changed segments is reused (if it exists), and no new requests are made to the server for data.

* Partial re-render
    when navigating between two sibling routes, /dashboard/settings and /dashboard/analytics, the settings and analytics pages will be rendered, and the shared dashboard layout will be preserved.
    Without partial rendering, each navigation would cause the full page to re-render on the client. Rendering only the segment that changes reduces the amount of data transferred and execution time, leading to improved performance.
    Browsers perform a "hard navigation" when navigating between pages. The Next.js App Router enables "soft navigation" between pages, ensuring only the route segments that have changed are re-rendered (partial rendering). This enables client React state to be preserved during navigation.

- The push() and replace() methods will perform a soft navigation if the new route has been prefetched 
    ( for example when you check a box of todo list on item page and go back to home page by using push or replace method , 
    those method will do soft navigation so will use cached version of home page so the box of item on hime page will be unchecked not checked ) 
    This problem solved in newer versions on NextJS or before newer version use temporary solution by using prefetch={false} to each Link of item and to 
    Links on Home page but this solution will not work if you go back to home page by back button on browser works only when you press on home page link on item page 
    
    * note : to check data mutation , router.refresh and Hard navigation & Soft Navigation check ToDoList project 
        and ToDoList Project needs json server , to create json server : ( npx json-server -w db.json -p 3500 -H 127.0.0.1 )
    * note : router.refresh() with new version of nextjs Send a new request to the server, refetch data and rerender the page 


- check Final Project ( Lesson 12 ) :

* Markdown : 
    is an easy-to-use simplified markup language that is an alternative to using HTML. 
    and there are a lot of tools to convert it to HTML
    see this video to understand Markdown ( https://youtu.be/f49LJV1i-_w?si=X1VsAD5rdGQIh0nO )

* Frontmatter : 
    Metadata for your Markdown
    Variables that can later be injected into your components
    Must be:
        At the top of the file
        Valid YAML
        Between triple dashed lines

* Difference between md (mark down )  and mdx ?
    MDX allows you to use JSX in your markdown content. 
    You can import components inside compileMDX() 
    MDX doesn’t have a new or special syntax because it’s just a combination of Markdown and JSX in one place

    If your Markdown or MDX files do not live inside your application, you can fetch them dynamically on the server ( like github repo api ) 


* Steps of usin mdx-remote : 

[1] To install mdx remote ( npm i next-mdx-remote)
[2] import { compileMDX } from “next-mdx-remote/rsc”
[3] compileMDX accepts parameters ( source, components,  options )  (parsefrontmatter: true in options)
[4] destructure { frontmatter, content } = await compileMDX() 
[5] access data by frontmatter like ( frontmatter.title ) 

- note : Revalidate = 0 and generateStaticParams don’t mix because 0 means no-cache so no static pages
- note : github repo api 
    https://api.github.com/repos/Mido1971988/test-blogposts/git/trees/master?recursive=1
    [1] https://api.github.com/repos
    [2] Mido1971988 ( your username )
    [3] test-blogposts ( your repo name )
    [4] git/trees
    [5] master ( your branch name )
    [6] ?recursive=1
- note : to revalidate you can use thunder client or you can write it on browser ( because url in browser is a GET request )
    http://localhost:3000/api/revalidate?path=/&secret=DaveGrayTeachesCode  
    [1] http://localhost:3000/api/revalidate ( revalidate location )
    [2] path=/ ( / means home page)
    [3] &secret=DaveGrayTeachesCode ( we added secret token to do revalidation only with this token)


* Note : 
    If you import server component inside client component will be also client component 
    But if you pass server component as child to client component will remain server component that’s why you can wrap your app with client side provider and will not change your server side components
    See this ( https://youtu.be/9YuHTGAAyu0?si=vhW26hHqNPWTmRVM)
    
* server Actions ( check ToDoList project folder ) : 
    They enable server-side data mutations, reduced client-side JavaScript, 
    and progressively enhanced forms
    
    - means you can add form element inside server component and you have 3 methods to do this :
        You can invoke Server Actions using the following methods:
            
            [1] Using action: React's action prop allows invoking a Server Action on a <form>element.
                like in AddTodo.tsx file we added attribute action={addTodo} to Form Element ( addTodo imported from actions.ts)
                - Pass a Server Action to the action prop of form when the form is submitted. formData will be passed to the Server Action function as an argument so you can access the data submitted by the form
                -  Passing a Server Action to <form action> allow users to submit forms without JavaScript enabled or before the code has loaded.

            [2] Using formAtion: React's formAction prop allows handling <button>, <input type="submit">, and <input type="image"> elements in a <form>
                like in Todo.tsx file we added atttribute formAction={async () => {
                        'use server'
                        await deleteTodo(todo)
                    }}
                    ( deleteTodo imported from actions.ts)
                    This method you need to add 'use server' , 'use server' is at actions.ts file but you have to write it again

            [3] Custom Invocation with startTransition: Invoke Server Actions without using action or formAtion by using startTransition. 
                This method disables Progressive Enhancement.
                like in UpdateCheckbox.tsx file
                - note : to be sure that method disable Progressive Enhancement , disable Javascript from browser and try 
                    to check any box so when you refresh the box will be unchecked because there is no JS to change it on server
                - useTransition does not support Progressive Enhancement , why use it ? 
                    you have access to isPending value to know data still changing on server or finished already
                    const [ isPending , startTransition ] = useTransition()



    - note : Progressive Enhancement allows a <forms to function properly without JavaScript, 
        or with JavaScript disabled. This allows users to interact with the form and submit data 
        even if the JavaScript for the form hasn't been loaded yet or if it fails to load.
    - note : you can try this by clicking on three dots on console page in browser and select run comand then 
        select disable JavaScript
    - note : in UpdateCheckbox.tsx file 
        before was problem of soft and hard navigation and he used useRouter and useFormStatus to solve it
        but now in newer version no need of this
    - note : in UpdateCheckbox.tsx file
        he used useOptimistic because there is aproblem
        when you click on checkbox it will take sec because we updating data directly on the server
        but by using useOptimistic will check the box in UI then check the server if ok box remains checked 
        if not will uncheck the box

    
** Redux Toolkit with Nextjs 13 :
[1] create Store by const store = configureStore({reducer : {auth.reducer}})
[2] create slice by const auth = createSlice({ name : "auth" , intialState , reducers : { reducer functions}})
[3] export const { logIn , logOut } = auth.actions; (logIn annd logOut are automatically created action creator functions corresponding to reducers function)
[4] export default auth.reducer; (this will be added to configureStore )
[5] create Provider component and wrap childeren with this Provider in layout.tsx
[6] const dispatch = useDispatch()
[7] dispatch(logIn()) or dispatch(logOut()) onClick on Buttons
[8] const username = useSelector((state) => state.auth.reducer.value.username)  (useSelector to get state and show it to User )
* notes : 
    - configureStore ( all those steps done automatically for you):
        * Call combineReducers to combine your slices reducers into the root reducer function
        * Add the thunk middleware and called applyMiddleware
        * In development, automatically add more middleware to check for common mistakes like accidentally mutating the state
        * Automatically set up the Redux DevTools Extension connection to the Browser
        * Call createStore to create a Redux store using that root reducer and those configuration options

    - CeateSlice :
        A function that accepts an initial state, an object of reducer functions, 
        and a "slice name", and automatically generates action creators and action types that correspond to the reducers and state.
    
    - useDispatch hook does not cause re-render but useSelector cause re-render

* Steps of using Async Reducer function  ( before we used thunk middleware but with configureStore it adds thunk middleware automatically for you and you need another approach) :
    [1] import { createAsyncThunk } from "@reduxjs/toolkit";
    [2] export const fetchUsers = createAsyncThunk(redux action type string , callBack function (argument , ThunkAPI) => {do you fetch  method here}) -- the argument is the argument passed in dispatch like (  dispatch(fetchUsers(argument))) 
    [3] extraReducers: (builder) => { builder.addCase(fetchUsers.fulfilled , callBack function (state , action) => { here you can change state like -- state.listOfUsers = [...action.payload]})}
    [4] dispatch(fetchUsers(argument))
    [5] you can access state like before const listOfU = useAppSelector((state) => state.myReducer.listOfUsers);

    * note : fetchUsers.fulfilled (fetch succeeded), fetchUsers.rejected (fetch rejected), fetchUsers.pending (still fetching) created automatically for you 
    * note : redux action type string argument that passed to createAsyncThunk() you can access it from action.type in extraReducers  function 
 

***************************************** TailWind CSS *****************************************
* Tailwind CSS :  is an open source CSS framework

* Steps to use Tailwind CSS : 
    [1] install Tailwind ( npx tailwindcss init ) to install tailwind.config.js file
    [2] create two folders ( build and src ) inside build folder add index.html and inside src folder add input.css
    [3] add './build/*.html' inside content inside tailwind.config.js file to use tailwind on any html file inside build folder
    [4] inside input.css add those three lines ( @tailwind base; @tailwind components; @tailwind utilities; ) and add any custom class you want to add
    [5] compile by ( npx tailwindcss -i ./src/input.css -o ./build/css/style.css ) this will create css folder and create style.css file
    [6] to watch changes on live server ( npx tailwindcss -i ./src/input.css -o ./build/css/style.css --watch )

    - note : you can add Tailwind CSS IntelliSense extension to autocomplete the name of classes on html file
    - note : you can use Tailwind Website to sreach for classes names ( https://tailwindcss.com/ )
    - note : steps to use Tailwind with NextJs :
        [1] will be automatically installed with new version of nextjs 
        [2] be sure that those three lines ( @tailwind base; @tailwind components; @tailwind utilities; ) inside global.css
        [3] be sure that content: [
            './app/**/*.{js,ts,jsx,tsx,mdx}', // Note the addition of the `app` directory.
            './pages/**/*.{js,ts,jsx,tsx,mdx}',
            './components/**/*.{js,ts,jsx,tsx,mdx}',
 
            // Or if using `src` directory:
            './src/**/*.{js,ts,jsx,tsx,mdx}',
            ]
            inside tailwind.config.js file 
        [4] import global.css inside app/layout.tsx
 
* project in Lesson02 : 

    * to install package.json file (npm init -y)    
        then you can scripts to package.json so instead of writing ( npx tailwindcss -i ./src/input.css -o ./build/css/style.css --watch )
        you can write only npm run tailwind

    * to install prettier plugin (npm i -D prettier-plugin-tailwindcss )

    * some website will help you :
        - to get emoji : https://emojipedia.org
        - to get unicode symbols : https://symbl.cc/en/
    
* Custom classes in Tailwind : 
    [1] add custom class name :
        write your class inside input.css file ( like .radial-blue class in Lesson01)
    
    [2] change or mutate classes already in Tailwind :
        write it inside module.exports={ theme : {}} in tailwind.config.js
        like module.exports={ theme : { screens:{ sm : 480 px }}} => here we can change sm to any value we want 
        or like module.exports={ theme : { colors:{ blue : "1fb6ff" }}} => here we can change color of blue

    [3] arbitrary values :  if you want to add specific px or color not availabe in Tailwind use [] :
        - for exp. top-0 means top : 0 px , top-1 means top : 0.25 rem 
            so if you want to add top : 13 px , you can write top-[13px]
        - another exp. you want to use specific color like #bada55 you have two options : 
            [a] mutate any color in module.exports={ theme : { colors:{ blue : "#bada55" }}}
            [b] or use [] like bg-[#bada55]
            
    [4] extend in theme in tailwind.config.js: 
        - extend not like mutate classes ... extend add new classes not overrivde classes in Tailwind
        - colors extend (Lesson05):  
            Like module.exports={ theme : {  extend : { colors : {  papayawhip:{light:”” , DEFAULT:””, dark:””} }}}}
            So you have 3 options : papayawhip-light , papayawhip-darker , papayawhip ( this means papayawhip-DEFAULT ) 
        - keyframes and animation (Lesson04):  add animate-nameOfAnimation class to element
            Like module.exports={ theme : {  keyframes : { "open-menu" : {} } , animation : { "open-menu : {} }}}}

* directives in Tailwind : 
    [1] @apply : 
        use @apply to write tailwind css code inside class at input.css file and you can reuse
        this class name to different html elements instead of writing long tailwind css code 
        for each html element ( like header-directive in header in Lesson03)
        .header-directive { bg-teal-700 text-white sticky top-0 z-10 }
        so when you write header-directive class name will apply all this bg-teal-700 text-white sticky top-0 z-10 to the element
    
    [2] @layer :
        [a] solve the problem of order of overriding  
            the order of layer is : [1]base [2]components [3]utilities
            @layer allows you to write the CSS anywhere you like in input.css and this code will be be ordered like layers order
                for exp. you write :
                <button class="btn-blue bg-green-500">...</button> in html file
                .btn-blue {@apply bg-blue-500 text-white;} in input.css file
                the button color will not be green ( you wrote green after blue in html and should override it)
                the problem here is when you build your project , in the created css file ( build/css/style.css) 
                .btn-blue {@apply bg-blue-500 text-white;}  will be written after bg-green 
                because you wrote .btn-blue {@apply bg-blue-500 text-white;} after @tailwind utilities in input.css
                to solve this problem use @layer components{ .btn-blue {@apply bg-blue-500 text-white;} } 
                now you are sure this code is before @tailwind utilities and will be written in ( build/css/style.css)
                before bg-green
            * note : if you didn't understand visit ( https://bloggie.io/@kinopyo/organize-your-css-in-the-tailwind-style-with-layer-directive )
        
        [b] CSS defined inside layers ,they'll be removed in the generated CSS (build/css/style.css) if not used.

        [c] Any custom styles you add to Tailwind with @layer will automatically support Tailwind’s modifier syntax for handling things like hover states, responsive breakpoints, dark mode, and more.: 
            like md: and lg: ( like widescreen:section-min-height we used section-min-height with media query widescreen)
            * note : to understand how to customize media query visit ( https://tailwindcss.com/docs/screens )

* if you want to add class to element from JS you should use @apply so you can use class name at JS file
    because you can't write tailwind classes inside hamburgerBtn.classList.toggle() ( like toggle-btn in main.js in Lesson04)

* Media queries defined using the raw key will be output as-is, and the min and max keys will be ignored so you can add min width and height or add aspect ratio like widescreen : { "raw" : "(min-aspect-ratio : 3/2)" }. in tailwind.config.js in Lesson 05



* Animation in tailwind : 
    [1] custom animation 
        add keyframes and animation inside theme.extends in tailwind.config.js then add animate-nameOfAnimation class to element ( like in Lesson04)
    [2] default tailwind animation ( like animate-spin)

* to solve the Error of tailwind in global CSS File :
    1. Open the CSS file where you import Tailwind CSS
    2. Press Ctrl + Shift + P and search for “change language mode”
    3. Inside the search bar, type “tailwindcss” and select it.
    4. Now your CSS file is associated with Tailwind CSS instead of regular css and the warnings should be gone.


***************************************** SASS *****************************************

* Sass:
    - stands for Syntactically Awesome Stylesheet
    - Sass is an extension to CSS
    - Sass lets you use features that do not exist in CSS, like variables, nested rules, 
    mixins, imports, inheritance, built-in functions, and other stuff.

* to compile sass file ( main.scss ) to css file ( main.css ) will use live sass compiler extension 
    or use apps like koala or prepros .

* Import : 
    to compile css from different sass files (_global-rules.scss and _contact.scss) to one css file ( main.css) : 
        [1] add _ at the beginning of name of file ( _ means ignore this file and not compile it as a seperate css file)
        [2] @use "./path of file" 


* variables : 
    - difference between css variables and sass variables : 
    [1] css variables : written in :root{--main-color:red}
        and you can access it by writing var(--main-color)
        but in compiled file (main.css) will be shown as var(--main-color) not the accual color
    [2] sass variables : written like $alt-color:green
        and you can access it directly by writing the name $alt-color
        and have global or local scope ( check main.scss)
        and in compiled file will be shown as accual color not $alt-color

    - you can import variable from another file but you have two options to do this : 
    [1] @use "./sass/variables/colors" as *; then use name of variable (like in sidebar{color:$alt})
    [2] @use "./sass/variables/colors"; then use colors.name of variable ( like sidebar{color:colors.$alt})

* Nesting (check it on main.scss file)

* Property Declarations And Placeholder (check it on main.scss file)

* if & else (check it on main.scss file)

* Interpolation (check it on main.scss file)

* Comments (check it on main.scss file)

* Mixin And Include :
    - like extend but in mixin you can add parameter so will be dynamic like in (@include circle(100px);)

* For - Loop 
    - Difference between : 
        @for $i from 1 through 10
        And
        @for $i from 1 to 10

    - through number 10 is included in loop but to number 10 not included in loop 

* Each (check it on main.scss file)

* While Loop (check it on main.scss file)

* Create Grid System (check it on main.scss file)

* Function (check it on main.scss file)

* Mixin and content (check it on main.scss file)
    @content means that when you invoke mixin will write the content not when you create the mixin

* Mixin with media quieries (check it on main.scss file)

***************************************** NodeJs *****************************************

* NodeJs :
    - JS runtime environment ( execute JS code outside the browser)
    - NodeJs is C++ program and needs V8 engine to understand JS code that’s why you will find V8 folder in dependencies 
    - NodeJs is C++ program so you can combine between features in JS and Features in C++
    - Lib folder in dependencies help developers to access C++ features from JS 
    - In NodeJs you don’t have access to web Api

* Difference between NodeJs and Vanilla Js : 
[1] node runs on a server not in a browser 
[2] the console is in terminal ( you can write node on terminal then you can write js code in terminal )
[3] global object instead of window object 
[4] commonJs Module instead of ES Module 
[5] missing some JS Api like fetch

* Modules :
    A module is an encapsulated and reusable chunk of code that has its own context
    In Node.js, each file is treated as a separate module
    Types of Modules :
        1.Local modules - Modules that we create in our application ( like commonJs and ES module)
        2.Built-in modules - Modules that Node.js ships with out of the box
        3.Third party modules - Modules written by other developers that we can use in our application

* commonJs Module (require) : 
    require() is a built-in function to include external modules that exist in separate files. 
    require() statement basically reads a JavaScript file, executes it , 
    and return the module.exports object. ( require("./add.js") has the value of module.exports = add; in add.js file )

* Module Scope :
    Each loaded module in Node.js is wrapped with an IIFE that provides private scoping of code
    IIFE allows you to repeat variable or function names without any conflicts 
    (batman.js and superman.js has same variable name (superhero) and no conflict when we used require in index.js)
    * under the hood when you write require("./batman") and require("./superman") in index.js
    node will wrap then with IIFE ( you can see exp. of wrapping like in iife.js)
    * under the hood node inject 5 arguments (exports, require, module,__filename,__dirname ) when wrap module by iife

* difference between module.exports and exports ?
    module.exports is an object (which's returned from require() ) and exports just a reference to this object
    
    [1] when you write exports = superhero; in superman.js and try to console.log(require("./superman)) 
        - module.exports = {};
        - let exports = module.exports; now exports reference to module.exports object
        - exports = superhero; now you overwrite exports and break the reference
        - console.log(require("./superman)); will give you {}
    [2]  when you write exports.superhero = superhero; in superman.js and try to console.log(require("./superman))
        - module.exports = {}
        - let exports = module.exports; now exports reference to module.exports object
        - exports.superman = superhero; now same reference and you added superman property to same object
        - console.log(require("./superman)); will give you {superman : "Superman"}
    [3] when you write module.exports = superhero; in batman.js and try to console.log(require("./batman))
        - module.exports = {}
        - let exports = module.exports;
        - module.exports = superhero;
        - console.log(require("./superman)); will give you "Batman"


* ES Module : 
    if you want to use ES Module (export and import) instead of using commonJs ( module.exports and require())
    name file extension mjs ( like main.mjs and math.mjs)

* Importing JSON File : 
    when you create JSON file ( data.json ) you can use require("./data") directly no need to add module.exports = data; in JSON file
    and require will parse json data to js object automatically

* watch mode in nodeJs :
    supported from version 18 (node --watch file name)

* built-n Module ( path , events , fs , stream , http )

* Path check index.js

* Events (Built-in) : 
    steps : 
    [1] import EventEmitter Class const EventEmitter = require("node:events");
    [2] create emitter instance from EventEmitter Class ( emitter instance has on and emitt methods)
    [3] emitter.on (like addEventListener )
    [4] emitter.emitt ( like click or disptaching the event ) ( you can add arguments starting from 2nd parameters)

* Extend with buil-in Event check index.js

* To understand Character set , Encoding, Streams and buffer watch these Videos : 
    https://youtu.be/0LYXkL0pr1M?si=-HtSPPEvMQqL6kz0
    https://youtu.be/br8VB99qPzE?si=hzlOvXD3RO8_kPP2

* fs(file system) ( check Exp. in index.js) :
    * NodeJs has built-in Async methods ( like fs.readFile() or fs.writeFile() )  not like JS needs browsers or Web Api to do Async
    * fs.writeFile() method by default will overwrite any content in file so we can add {flag: "a",}
        to append to the file not to overwrite
    * promise with fs : performance in regular fs is better than fs promise (check Exp. in index.js)
    * fs.appendFile will create file if not exist the add text inside it 
* Stream :
    - is a sequence of data that is being moved from one point to another over time
    - Stream is infact a built-in node module that inherits from the event emitter class 
        that’s why readableStream has on method ( inherited it from event emitter class)

    - Types of Streams
        [1] Readable streams from which data can be read Ex: Reading from a file as readable stream
        [2] Writable streams to which we can write data Ex: Writing to a file as writable stream
        [3] Duplex streams that are both Readable and Writable Ex: Sockets as a duplex stream
        [4] Transform streams that can modify or transform the data as it is written and read 
            Ex: File compression where you can write compressed data and read de-compressed data to and from a file as a transform stream

    - default chunk size if 64 bits but you can change this by addin highWaterMark: 2 (2bits) to options object 
    - data event will be fired automatically ( no need to emitt it ) when data is received
    - you can use pipe method instead of data event ( check exp. in index.js)
    - chained pipe ( works only with specific destination stream types : readable , duplex or transform Streams)
    
* HTTP Module :
    - HTTP module extend EventEmitter Class 
    - const server = http.createServer((request , response) => {}) 
        To create server and accept callback function as argument 
        This callback function request event listener 
        Means when the server get request this callback function will be executed
    - server.listen() to tell server to start listening at which port 
        and can accept 2nd argument as callback function which will be executed when server start listening 
    - response.end() accepts only type string or an instance of Buffer or Uint8Array.
        So we use JSON.stringify() and we should add {"Content-Type" : "application/json"}
    - to send html response we should add {"Content-Type" : "text/html"}
    - you can send whole html file as a response like res.end(fs.readFileSync("./index.html"))
    - using pipe is better performance than fs.readFileSync
        fs.createReadStream("./index.html").pipe(res) 
        is better than 
        res.end(fs.readFileSync("./index.html"))
    - if you want to add dynamic html ( for exp. add name from server to html file before send it as response) ( you can't use here pipe)
        [1] let html = fs.readFileSync("./index.html" , "utf-8")
        [2] const name = "Soliman"
        [3] html = html.replace("{{name}}" , name) // string replace method
        [4] res.end(html)

* Routing (check index.js)


* Thread Pool
    - when you try to do Async in NodeJs , NodeJs will try to do it using native Async method ( kernal ) in 
        your operating system and if that not possible then will try to use Thread Pool 

    - Libuv thread pool as the name indicates is literally a pool of threads, 
    that NodeJS uses to offload time-consuming tasks ( like crypto.pbkdf2 ) 
    and ensures the main thread is not blocked for a long time (Asynchronous)
    
    - videos to understand better :
        https://youtu.be/I1sqnbJ1Fno?si=wCKSOM-EPqNCE610
        https://youtu.be/I1sqnbJ1Fno?si=fLkMJOxOy7sXRr5z 

    - you can change Thread pool size by ( process.env.UV_THREADPOOL_SIZE = 16;)
        * note : each thread take one cpu core from your laptop 
            for exp. if you have 4 cpu cores so for best performance make size of Thread pool to 4
            if you make size of thread pool to 8 so each core will take 2 threads so will not give you best performance
    - https.requesr is a network operation not CPU operation so will not use Thread pool will use native Async method
        so no matter what is the Thread pool size if you make a request or 12 request all will be same time
    
* Event Loop ( see Experiment in event-loop.js): 
    * note : see picture in 7:55 to understand event loop cycle ( https://youtu.be/L18RHG2DwwA?si=wt9JNr9wnrhR-nkf )
    Order of Executions : 
    1.Any callbacks in the micro task queues are executed. 
        First, tasks in the nextTick queue and only then tasks in the promise queue
    2.All callbacks within the timer queue are executed
    3.Callbacks in the micro task queues if present are executed. 
        Again, first tasks in the nextTick queue and then tasks in the promise queue
    4.All callbacks within the l/O queue are executed
    5.Callbacks in the micro task queues if present are executed. nextTick queue followed by
        Promise queue.
    6.All callbacks in the check queue are executed
    7.Callbacks in the micro task queues if present are executed. 
        Again, first tasks in the nextTick queue and then tasks in the promise queue
    8.All callbacks in the close queue are executed
    9.For one final time in the same loop, the micro task queues are executed. 
        nextTick queue followed by promise queue.

* npm :
    - is a package manager for the JavaScript programming language maintained by npm
    - npm registry is an online database of public and paid-for private packages
    - Package.json is the central place to configure and describe how to interact with and run your application. It is used by the npm CLI (and yarn) to identify your project and understand how to handle the project's dependencies.
    - Package.json file housed in the root directory of your project has name, version, description, and keywords, as well as dependencies and devDependencies.
    - You have two options to create Package.json :
        [1] manually by creating and writing the file
        [2] by command (npm init )and then enter the detail , or by (npm init —yes )and will enter all details automatically 

    - for Exp. we installed package ( upper-case ) and when you want to import methods from it we have two methods : 
        [1] ES module : import { upperCase , localUpperCase } from "upper-case"
        [2] commomJs :  const upperCase = require("upper-case").upperCase

    - if you write module name in dependencies in package.json and you did not install it
        when you write (npm install ) in terminal will automatically install any module written in dependencies
        this is usefull if you clone a repo without node-modules folder juts write npm install in terminal
        and node will read dependencies in package.json and will install all modules


    - version of package is writter in 3 numbers (semantic version) ( x.y.z) ( x = main version , y = minor version , z = patch)
        Versioning Rules : 
            [1] When you fix a bug and the code stays backwards-compatible you increment the patch version.
                For example 1.1.1 to 1.1.2
            [2] When you add new functionality but the code still stays backwards-compatible, you increment the minor version
                You also reset the patch version to zero
                For example 1.1.1 to 1.2.0
            [3] When you make changes and the code is no more backwards compatible, you increment the major version
                You have to reset the minor and patch version to zero
                For example 1.1.1 to 2.0.0
            * note : in dependencies and devDependencies ^ means allow to update minor version or patch but not update major version
            * note : in dependencies and devDependencies ~ means allow to update patch only
            * note : in dependencies and devDependencies * (without numbers) means allow to update all ( latest version)
            * note : to update packages in dependencies and devDependencies write npm update

    - global package ( you can use it on terminal no need to import it in index.js to use it)
        like nodemon package we installed it by ( sudo npm install -g nodemon ) ( nodemon like watch mode)
        * note : use terminal not VSCode when you use sudo  
            if you want to use VSCode edit sudoers file ( but will make computer slow so not recommended)
            steps : 
                [1] sudo nano /etc/sudoers 
                [2] add this line ( %sudo   ALL=(ALL) NOPASSWD: ALL) ( becarfull after %sudo 2 tabs not space)
        
        * note : to remove global package ( npm uninstall -g nodemon  ) but this does not work for me so 
            use these steps : 
                [1] cd /usr/local/lib/node_modules
                [2] sudo rm -rf nodemon

    - scripts : a shortcut written to use on terminal   
        for example instead of writting ( node index.js ) we can write in script ( "start" : "node index.js" )
        then on terminal we can write npm run start instead of node index.js

* difference between 
    - DevDependencies are the packages that are required for development and testing purposes only. 
    These packages are not required for the application to run properly, 
    but they are needed for tasks such as building, testing, and linting the code.
    to install package to dev add --save-d or -D (like -g means global package)

    - Dependencies are the packages that are required for your application to run properly. 
    These packages are installed when you run the npm install command. 

* CLI ( command line interface) you can create your own program like npm or git :
    - steps : 
        [1] create package ( npm init )
        [2] add (#!/usr/bin/env node) in index.js
        [3] add "bin" : {"pokemon" : "index.js"} to package.json
        [4] you can publish package to npm then install it or install it directly from computer
            by (sudo npm install -g) in terminal will automatically install any package written in bin package.json
            now when you write pokemon in terminal your program will run
            * note : you should install fetch by ( npm install node-fetch@2 ) 
                version 2 of node-fetch if you want to use commomJs 
                if you want to use ES Module ( import ) use latest version
        [5] if you want to pass an argument you can install yargs package ( npm install yargs)
            then in terminal write argument like ( pokemon --pokemon=mew)
        [6] if you want prompt user when the user start to run your package , you can use
            inquirer package by ( npm install inquirer@8.2.5 ) version 8 because compatible with commomJs newer version compatible with ES Module
        

* The cluster module (cluster.js and no-cluster.js):
    - provides a way of creating child processes that runs simultaneously and share the same server port. (bacause Node is single thread )
    - Master and Workers : 
        Master is only in charge of the workers 
        Workers are in charge of handling incoming requests, reading files etc
        Each worker gets its own event loop, memory, and V8 instance

        steps : 
            [1] const cluster = require("cluster");
            [2] cluster.isMaster to check if Master is running so you can create workers by (cluster.fork();) 
        * note : each worker take one core , so if you have 2 cpu cores so for best performance 2 workers is enough for you ( like Thread pool )
            you can check your CPU core by ( const numOfCPUs = require("os").cpus().length; )
    - you can use pm2 package to use cluster workers automatically without writing cluter code like in cluster.js
        to install ( sudo npm install -g pm2 ) 
        now you can use no-cluster.js file in cluster mode by (pm2 start no-cluster.js -i 0) 
        0 here means use best number of workers according to this computer but if you write number that's means specific number of worker
        and to stop using pm2 ( pm2 stop no-cluster.js)

* Worker Thread Module (worker_thread.js and main-thread.js): 
    - The worker threads module enables the use of threads that execute JavaScript in parallel
    - difference between cluster Module and Worker Thread Module :
        - The cluster module can be used to run multiple instances of Node.js that can distribute workloads
        - worker_threads module allows running multiple application threads within a single Node.js instance
            When process isolation is not needed, that is, no separate instances of V8, event loop and memory are needed, you should use worker_threads
    - Steps : 
        [1] const { Worker } = require("worker_threads");
        [2] const worker = new Worker("./worker-thread.js");
        [3] worker.on("message") // to take j variable from  worker-thread.js
        [4] const { parentPort } = require("worker_threads"); then parentPort.postMessage(j); in worker_thread.js to send j variable


* Exit on uncaught error 
process.on(‘uncaughtException’, err => { 
    console.error(‘there was an uncaught error : ${err} ‘ ) ;
    process.exit(1);
})


***************************************** ExpressJS *****************************************

Express : 
    - is a framework for node js
    - Steps :
        [1] npm i express
        [2] const express = require("express")
        [3] const app = express();
        [4] app has alot of methods like ( get , listen , ...)
    - express accepts regular expression like ("^/$|/index(.html)?") in app.get()
    - Express handle 404 page automatically

* custom 404 Page : 
    [1] app.get("/*",callback) /* means any page did not mention in code
    [2] res.status(404).sendFile(path.join(__dirname , "views" , "404.html")) inside callback function
        we added status(404) because without it the status will be 200 

* Route Hanlder 
    you can add 3rd parameter ( next ) so ypu can chain callback function and will invoke next callback when you write next()
    you can chain callback function in array like this ( app.get("/chain(.html)?" , [one , two , three]) )

* Middleware 
    - anything between request and response
    - there are 3 types : 
        [1] built-in 
            (a) app.use(express.json)
            (b) app.use("/" , express.static(path.join(__dirname, "/public" ))) without it you can cannot link css or images to html file
            (c) app.use(express.urlencoded({ extended: false})) // add before all routes so will be availabe for them
        [2] custom 
            like // custom Middleware logger in server.js
        [3] from 3rd party
            like // 3rd party Middleware cors in server.js
* Routes 
    steps (we moved index , new-page and old-page to root.js and then used Routes) : 
    [1] create file to handle Routes ( routes/subdir.js) and inside it use ( router.get() )
    [2] module.exports = router;
    [3] app.use('/subdir', require('./routes/subdir')); in server.js
    [4] app.use("/subdir" , express.static(path.join(__dirname, "/public" ))) to make css works

    * note : to chain get , post , put , delete in same route use router.route().get().post().put().delete() like in employees.js

* MVC Pattern (only pattern how to organize your code according to MVC pattern)
    see this video ( https://youtu.be/Dco1gzVZKVk?si=4V73LSbut3xV7pG3 )

* User Password Auhtentication (https://youtu.be/Nlg0JrUt0qg?si=2KXvX_9P0CYwdvzo)
 
* JWT Auhtentication (https://youtu.be/favjC6EKFgw?si=a8TlbibpPk9X6tr-)

* Authorization (https://youtu.be/fUWkVxCv4IQ?si=_MFzD8GLsJsqq1MR)

* difference between Auhtentication and Authorization :
    authentication is the process of verifying who someone is, 
    whereas authorization is the process of verifying what specific applications, 
    files, and data a user has access to

* MongoDB :
    SQL databases are used to store structured data 
    while NoSQL databases like MongoDB are used to save unstructured data

    see MongoDB Video from this list ( https://youtube.com/playlist?list=PL0Zuz27SZ-6PFkIxaJ6Xx_X46avTM1aYw&si=6DenB09VA9AZ5tS1)

* Authentication ( next-auth ) Steps : 
[1] npm i next-auth
[2] create folder api/auth/[...nextauth]/route.ts
[3] route.ts : inside hander add :
    [a] Providers 
    [b] async authorize (here you write your logic from where will you get username and        password from data base and compare them to credentials (what user typed at input fields))
    [c] pages (if you want to create custome page for signIn and signOut) 
    [d] secret token (from .ev.local ))
[4] use async signIn ( 2 parameters ( credentials , options object)) and signOut 
    (1 parameter options object) Methdos
[5] use useSession if you want to get data and status of Authorization (1 - authenticated , 2 - authenticated , 3 - loading )( user signed in or not or loading)




    
***************************************** Algorithm *****************************************


* Time complexity - Amount of time taken by an algorithm to run, as a function of input size
* Space complexity - Amount of memory taken by an algorithm to run, as a function of input size

1.Big-O Notation - Worst case complexity
2.Omega Notation - Best case complexity
3.Theta Notation - Average case complexity

Big-O notation : 
    - describes the complexity of an algorithm using algebraic terms
    - It has two important characteristics : 
        * It is expressed in terms of the input
        * It focuses on the bigger picture without getting caught up in the minute details
    * note : 
        - loop => Big O = O(n)
        - loop inside loop Big O = O(n ^ 2)
        - reduceed by half O = O(log n)
    - EXP1 :
    function summation(n) {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += 1;
        }
        return sum;
    }

    Count the number of times a statement executes based on the input size
    Here if n = 4 so number of execution is 6 
    1 execution:  let sum = 0;
    4 executions: sum +=1;
    1 execution : return sum;

    So the algorithm here is n + 2 ( so numbers of execution depended on input size ) 
    If n = 10 so n+2 = 12 executions 
    If n = 1000 so n+2 = 1002 executions ( we can consider it 1000 ) 
    So we can consider time complexity O(n) linear 

    - EXP2 :
    function summation(n) {
        return (n * (n + 1)) / 2;
    }

    time complexity O(1) constant 
    ( so numbers of execution does not depend on input size (n argument ) 
        return statment will be executed only once)
    
    - Exp3:
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= i; i++) {
        //Some code
        }
    }

    Time Complexity O(n2) - Quadratic 

    - EXP4 :
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= i; i++) {
            for (k = 1; k <= j; k++) {
                //Some code
            }
        }
    }

Time Complexity O(n3) - Cubic

* Object Big-O Notation:

    Insert - O(1)
    Remove - O(1)
    Access - O(1)
    Search - O(n)
    Object.keys()-O(n)
    Object.values()-O(n)

* Array Big-O Notation:

    Insert / remove at end - O(1)
    Insert / remove at beginning - O(n)
    Access - O(1)
    Search - O(n)
    Push / pop -O(1)
    Shift / unshift / concat slice / splice - O(n)
    forEach / map / filter / reduce - O(n)

----- Math algorithm
* Fibonacci sequence ( see Exp. in main.js)
 
    the Fibonacci sequence is a sequence in which each number is the sum of the two preceding ones.
    The first two numbers in the sequence are 0 and 1.
    fibonacci(2) = [0,1]
    fibonacci(3) = [0,1,1]
    fibonacci(7) = [0,1,1,2,3,5,8]

    Big-O = O(n) linear ( because for loop inside function)

* Factorial of a number ( see Exp. in main.js)

    In mathematics, the factorial of a non-negative integer 'n', denoted n!, 
    is the product of all positive integers less than or equal to 'n'.

    Factorial of zero is 1.
    factorial(4) = 4*3*2*1 = 24
    factorial(5) = 5*4*3*2*1 = 120

    Big-O = O(n) linear ( because for loop inside function)

* Prime Number ( see Exp. in main.js) : 

    A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.
    isPrime(5) = true (1*5 or 5*1)
    isPrime(4) = false ( 1*4 or 2*2 or 4*1)

    Big-O = O(n) linear ( because for loop inside function)

    - with optimized solution ( see main.js)
    - Optimized Primality Test
        Integers larger than the square root do not need to be checked because,
        whenever 'n=a*b', one of the two factors 'a' and 'b' is less than or equal to the square root of 'n' n=24, a=4 and b=6
        The square root of 24 is 4.89
        4 is less than 4.89
        a is less than the square root of n n=35, a=5 and b=7
        The square root of 35 is 5.91
        5 is less than 5.91
        a is less than the square root of n
    Big-O = O(sqrt(n))

* Power of Two  ( see Exp. in main.js) :
    Problem - Give a positive integer 'n', determine if the number is a power of 2 or not
    An integer is a power of two if there exists an integer 'x' such that 'n' === 2x
    isPowerOfTwo(1) = true (2 power 0)
    isPowerOfTwo(2) = true (2 power 1)
    isPowerOfTwo(5) = false

    Vishwas solution Big-O = O(logn)
    My solution Big-O = O(1)
    Optimized solution (Bitwise operator solution) Big-O = O(1)

* recursive algorithm : 
    A recursive algorithm simplifies a problem by breaking it down into sub-problems of the same type. 
    The output of one recursion becomes the input for another recursion.
    It assists you in breaking down large complex problems into smaller ones.
     
    - recursive algorithm consists of :
    [1] Base case, which consists of a state and condition that ends the recursive function
    [2] Recursive Step: It computes the output by reaching the same function repeatedly but with smaller or more complex inputs.

* Recursive Fibonacci sequence ( see Exp. in main.js) :
    Problem - Give a number 'n', find the nth element of the Fibonacci sequence
    In mathematics, the Fibonacci sequence is a sequence in which each number is the sum of the two preceding ones.
    The first two numbers in the sequence are 0 and 1. (0, 1, 1, 2, 3, 5, 8...)
    recursiveFibonacci(0) = 0
    recursiveFibonacci(1) = 1
    recursiveFibonacci(6) = 8

    Recursive solution (Vishwas Solution) Big-O = O(2^n) 
    iteration solution ( my Solution) Big-O = O(n)
    so iteration solution is better performance than Recursive solution for Fibonacci sequence

* Recursive Factorial of a number ( see Exp. in main.js)

    In mathematics, the factorial of a non-negative integer 'n', denoted n!, 
    is the product of all positive integers less than or equal to 'n'.

    recursiveFactorial of zero is 1.
    recursiveFactorial(4) = 4*3*2*1 = 24
    recursiveFactorial(5) = 5*4*3*2*1 = 120

    Big-O = O(n) linear 

* Search algorithm
    [1] linear
    [2] Binary
    [3] Recursive Binary

* Linear Search  ( see Exp. in main.js)
    Problem - Given an array of 'n' elements and a target element 't', 
    find the index of 't' in the array. Return -1 if the target element is not found.

    Big-O = O(n) linear

* Binary Seacrh ( see Exp. in main.js) : 
    Problem - Given a sorted array of 'n' elements and a target element 't', find the index of 't' in the array. 
    Return -1 if the target element is not found.

    Binary search pseudocode: 
        [1] If the array is empty, return -1 as the element cannot be found.
        [2] If the array has elements, find the middle element in the array. If target is equal to the middle element, return the middle element index.
        [3] If target is less than the middle element, binary search left half of the array.
        [4] If target is greater than middle element, binary search right half of the array.
    
    Big-O = O(log n) 

* Recursive Binary Search ( see Exp. in main.js) :

    Big-O = O(log n) 

* Sorting algorithm
    [1] Bubble Sort
    [2] Insertion Sort
    [3] Quick Sort
    [4] Merge Sort

* Bubble Sorting ( see Exp. in main.js):
    compare every two adjacent numbers in the array and swap and repeat this loop till sorting all numbers

    Big-O = O(n ^ 2) 

* Insertion Sorting ( see Exp. in main.js): : 
    - difference between Bubble Sorting and Insertion Sorting : 
        [1] Bubble sorting compare every two adjacent numbers and swap and repeat this loop till array is sorted 
            (https://youtube.com/shorts/e30RDr-A4T8?si=vII103GN-COD8A9R)

        [2] Insertion sorting compare one number to each number behind it and put this number in it's right position 
            ( https://youtube.com/shorts/ZZ-Oz1IFfPg?si=4jkeyJx67r4RyiUh) 

    Big-O = O(n ^ 2) (but better berformance than Bubble Sorting)

* Quick Sorting ( recursive) ( see Exp. in main.js):

    - Quick sort idea
    [1] Identify the pivot element ( as refernce for comparison ) in the array ( as you like 1st element , last element or even random)
    [2] Put everything that's smaller than the pivot into a 'left' array 
        and everything that's greater than the pivot into a 'right' array
    [3] Repeat the process for the individual 'left' and 'right' arrays 
        till you have an array of length 1 which is sorted by definition
    [4] Repeatedly concatenate the left array, pivot and right array till one sorted array remains

    Big-O = O(n ^ 2) worst case complexity ( when you try to sort already sorted array)
    Theta Notation = O(nlogn) Average case complexity

* Merge Sorting ( recursive + 2 functions ) ( see Exp. in main.js):
    Merge sort idea
    [1] first function : Divide the array into sub arrays, 
        each containing only one element (An array with one element is considered sorted)
    [2] repeatedly merge the sub arrays to poduce new sorted sub arrays until there is only one sub
        array remaining . that will be sorted array

    Big-O = O(nlogn)

* Cartesian product( see Exp. in main.js):
    Problem - Given two finite non-empty sets, find their Cartesian Product.
    In mathematics, specifically set theory, the Cartesian product of two sets A and B, 
    denoted AxB, is the set of all ordered pairs (a, b) where a is in A and b is in B
    
    const A = [1, 2]
    const B = [3, 4]
    
    AxB = [ [1, 3], [1, 4], [2, 3], [2, 4]]
    const C = [1, 2]
    const D = [3, 4, 5]
    CxD =[  [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5] ]

    Big-O = O(mn) 
    loop inside loop should be n ^ 2 but we have two arrays maybe those arrays with different length 
    so will be (m x n) not n ^ 2 (n x n)

* Climbing staircase ( see Exp. in main.js):
    
    Problem - Given a staircase of 'n' steps, count the number of distinct ways to climb to the top.
    You can either climb 1 step or 2 steps at a time.
    n=1, climbingStaircase(1) = 1 (1)
    n=2, climbingStaircase(2) =2 (1, 1) and (2)
    n=3, climbingStaircase(3) =3 (1,1,1) (1, 2) and (2, 1)
    n=4, climbingStaircase(4) = 5 (1,1,1,1) (1,1,2) (1,2,1) (2,1,1) and (2,2)

    n4 => sum of steps of n3 and n2 so steps of n4 is 5
    n5 => sum of steps of n4 and n3 so steps of n5 is 8

    Big-O = O(n) linear

* Tower of Hanio ( see Exp. in main.js):

    Tower of Hanoi
    The objective of the puzzle is to move the entire stack to the last rod, obeying the following rules:
        * Only one disk may be moved at a time.
        * Each move consists of taking the upper disk from one of the stacks 
            and placing it on top of another stack or on an empty rod. And lastly,
        * smaller disk should be on the top.

    Big-O = O(2^n)

* Algorithm design techniques
    Bruce force - Simple and exhaustive technique that evaluates every possible outcome to find the best solution. Ex: Linear search
    Greedy - Choose the best option at the current time, without any consideration for the future. Ex: Dijkstra's algorithm, Prim's algorithm and Kruskal's algorithm
    Divide and Conquer - Divide the problem into smaller sub-problems. Each sub-problem is then solved and the partial solutions are recombined to determine the overall solution. Ex: Binary Search, Quick Sort, Merge
    Sort and Tower of Hanoi
    Dynamic Programming - Divide the problem into smaller sub-problems. Break it down into smaller but overlapping sub problems. Store the result and reuse it for the same sub-problems. This is called memoization and is a optimization technique that improves the time complexity of your algorithm. Ex:
    Fibonacci numbers and climbing staircase
    Backtracking - Generate all possible solutions. Check if the solution satisfies all the given constrains and only then you proceed with generating subsequent solutions. If the constraints are not satisfied, backtrack and go on a different path to find the solution. Ex: N-Queens problem


* Next steps after algoritthm course : 
    Solve more problems
    *   Finding the GCD using Euclidian algorithm
    *   Finding permutations and combinations of a list of numbers
    *   Finding the longest common substring in a given string
    *   Knapsack problem

------------------------------------------
****** Data Structure

* What is a data structure?
    A data structure is a way to store and organize data so that it can be used efficiently
    A data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to that data

* Why learn data structures? contd.
    The difference between a function taking a few milliseconds vs a few seconds or even minutes comes down to the selection of the right data structure
    Data structures help you solve problems in a more efficient way, both in terms of time and memory

    DOM - Tree data structure
    Browser back and forward - Stack data structure
    OS job scheduling - Queue data structure

* Course overview
    [1] Built in data structures
        *   Arrays
        *   Objects
        *   Sets
        *   Maps
    [2] Custom data structures
        *   Stacks
        *   Queues
        *   Circular queues
        *   Linked lists
        *   Hash tables
        *   Trees
        *   Graphs

* Array : 
    An array is a data structure that can hold a collection of values
    Arrays can contain a mix of different data types. You can store strings, booleans, numbers or even objects all in the same array
    Arrays are resizable. You don't have to declare the size of an array before creating it
    JavaScript arrays are zero-indexed and the insertion order is maintained
    Arrays are iterables. They can be used with a for of loop

* Array - Big-O time complexity: 
    Insert / remove from end - 0(1)
    Insert / remove from beginning - O(n) ( because will change index of all items)
    Access - O(1)
    Search - O(n)
    Push / pop - 0(1)
    Shift / unshift / concat / slice / splice - O(n)
    forEach / map / filter / reduce - O(n)


* Object
    An object is an unordered collection of key-value pairs. 
    The key must either be a string or symbol data type where as the value can be of any data type To retrieve a value, 
    you can use the the corresponding key. This can be achieved using the dot notation or bracket notation
    An object is not an iterable. You cannot use it with a for of loop

Object - Big-O time complexity
Insert - O(1)
Remove - 0(1)
Access - 0(1)
Search - 0 (n)
Object.keys() - O(n)
Object.values() - O(n)
Object.entries() - O(n)

* Set
    A set is a data structure that can hold a collection of values. The values however must be unique
    Set can contain a mix of different data types. You can store strings, booleans, numbers or even objects all in the same set
    Sets are dynamically sized. You don't have to declare the size of a set before creating it
    Sets do not maintain an insertion order
    Sets are iterables. They can be used with a for of loop

- Set vs Array
    Arrays can contain duplicate values whereas Sets cannot
    Insertion order is maintained in arrays but it is not the case with sets
    Searching and deleting an element in the set is faster compared to arrays 
        because ( they use a hash table internally ( where each data value has its own unique index value ) for storing data and can be used to replace duplicates from other data types)


* Мар
    A map is an unordered collection of key-value pairs. 
    Both keys and values can be of any data type
    To retrieve a value, you can use the the corresponding key Maps are iterables. 
    They can be used with a for of loop

* Object vs Map
    - Objects are unordered whereas maps are ordered
    - Keys in objects can only be string or symbol type whereas in maps, 
        they can be of any type An object has a prototype and may contain a few default keys which may collide with your own keys if you're not careful. 
        A map on the other hand does not contain any keys by default
    - Objects are not iterables where as maps are iterables
    - The number of items in an object must be determined manually where as it is readily available with the size property in a map
    - Apart from storing data, you can attach functionality to an object whereas maps are restricted to just storing data


* Stack
    The stack data structure is a sequential collection of elements that follows the principle of Last In First Out (LIFO)
    The last element inserted into the stack is first element to be removed
    A stack of plates. The last plate placed on top of the stack is also the first plate removed from the stack.
    Stack is an abstract data type. It is defined by its behavior rather than being a mathematical model
    The Stack data structure supports two main operations
        - Push, which adds an element to the collection
        - Pop, which removes the most recently added element from the collection
    - Stack implementation video (https://youtu.be/SbjATifB2M8?si=FbgLnn-c0l-Gpg9o)


* Queue
    The queue data structure is a sequential collection of elements that follows the principle of First In First Out (FIFO)
    The first element inserted into the queue is first element to be removed
    A queue of people. People enter the queue at one end (rear/tail) and leave the queue from the other end (front/ head).
    Queue is an abstract data type. It is defined by its behavior rather than being a mathematical model
    The Queue data structure supports two main operations
        - Enqueue, which adds an element to the rear/tail of the collection
        - Dequeue, which removes an element from the front head of the collection

    - you can optimize Queue ( Enqueue and Dequeue ) to convert Big-O = O(n) to Big-O = O(1) see video ( https://youtu.be/ba15sgOiAOg?si=4v0wC7zjbmsdu_MW )

    -Queue implementation video (https://youtu.be/NuBWJ7kIlDg?si=VYlwdErJ5XvjcomE)


* Circular Queue :
    - The size of the queue is fixed and a single block of memory is used as if the first element is connected to the last element
    - Also referred to as circular buffer or ring buffer and follows the FIFO principle
    - A circular queue will reuse the empty block created during the dequeue operation 
        When working with queues of fixed maximum size, a circular queue is a great implementation choice
    - The Circular Queue data structure supports two main operations
        * Enqueue, which adds an element to the rear/tail of the collection
        * Dequeue, which removes an element from the front/head of the collection
    - Circle queue implementation video (https://youtu.be/oIR_DOOOACk?si=DHSO3g9p_f7XsmCf)

* Linked List :
    - A linked list is a linear data structure that includes a series of connected nodes
    - Each node consists of a data value and a pointer that points to the next node
    - The list elements can be easily inserted or removed without reallocation or reorganization of the entire structure
    - Random access of elements is not feasible and accessing an element has linear time complexity
    - The linked list data structure supports three main operations
        Insertion - to add an element at the beginning, end or at a given index in the list 
        Deletion - to remove an item given its index or value 
        Search - to find an element given its value


* Hash Table :
    A hash table, also known as hash map, is a data structure that is used to store key-value pairs
    Given a key, you can associate a value with that key for very fast lookup JavaScript's Object is a special implementation of the hash table data structure.
    However, Object class adds its own keys. Keys that you input may conflict and overwrite the inherited default properties
    Maps which were introduced in 2015 allow you to store key-value pairs
    Writing your own hash table implementation is a very popular JavaScript interview
    question

* Hash Table contd. :
    We store the key value pairs in a fix sized array
    Arrays have a numeric index
    How do we go from using a string as an index to number as an index?
    A hashing function accepts the string key, converts it into a hash code using a defined logic 
    and then maps it into a numeric index that is within the bounds of the array Using the index, store the value
    The same hashing function is reused to retrieve the value given a key
    *   Set to store a key-value pair
    *   Get to retrieve a value given its key
    *   Remove to delete a key value pair

* Tree :
    A tree is a hierarchical data structure that consists of nodes connected by edges
    A tree is a non-linear data structure, compared to arrays, linked lists, stacks and queues which are linear data structures.
    In linear data structures, the time required to search is proportional to the size of the data set
    Trees however, owing to the nonlinear nature allow quicker and easier access to the data
    A tree will not contain any loops or cycles.


* Graph :
    A graph is a non-linear data structure that consists of a finite number of vertices (also called nodes) connected by edges
    Trees are a specific type of graph data structure.
